function _slicedToArray(e, t) { return _arrayWithHoles(e) || _iterableToArrayLimit(e, t) || _unsupportedIterableToArray(e, t) || _nonIterableRest() } function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } function _iterableToArrayLimit(e, t) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) { var n = [], r = !0, i = !1, a = void 0; try { for (var o, s = e[Symbol.iterator](); !(r = (o = s.next()).done) && (n.push(o.value), !t || n.length !== t); r = !0); } catch (e) { i = !0, a = e } finally { try { r || null == s.return || s.return() } finally { if (i) throw a } } return n } } function _arrayWithHoles(e) { if (Array.isArray(e)) return e } function _get(e, t, n) { return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, n) { var r = _superPropBase(e, t); if (r) { var i = Object.getOwnPropertyDescriptor(r, t); return i.get ? i.get.call(n) : i.value } })(e, t, n || e) } function _superPropBase(e, t) { for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _getPrototypeOf(e));); return e } function _defineProperty(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function _createForOfIteratorHelper(e, t) { var n; if ("undefined" == typeof Symbol || null == e[Symbol.iterator]) { if (Array.isArray(e) || (n = _unsupportedIterableToArray(e)) || t && e && "number" == typeof e.length) { n && (e = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= e.length ? { done: !0 } : { done: !1, value: e[r++] } }, e: function (e) { throw e }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var a, o = !0, s = !1; return { s: function () { n = e[Symbol.iterator]() }, n: function () { var e = n.next(); return o = e.done, e }, e: function (e) { s = !0, a = e }, f: function () { try { o || null == n.return || n.return() } finally { if (s) throw a } } } } function _toConsumableArray(e) { return _arrayWithoutHoles(e) || _iterableToArray(e) || _unsupportedIterableToArray(e) || _nonIterableSpread() } function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } function _unsupportedIterableToArray(e, t) { if (e) { if ("string" == typeof e) return _arrayLikeToArray(e, t); var n = Object.prototype.toString.call(e).slice(8, -1); return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(e, t) : void 0 } } function _iterableToArray(e) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e) } function _arrayWithoutHoles(e) { if (Array.isArray(e)) return _arrayLikeToArray(e) } function _arrayLikeToArray(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } function asyncGeneratorStep(e, t, n, r, i, a, o) { try { var s = e[a](o), l = s.value } catch (e) { return void n(e) } s.done ? t(l) : Promise.resolve(l).then(r, i) } function _asyncToGenerator(e) { return function () { var t = this, n = arguments; return new Promise(function (r, i) { var a = e.apply(t, n); function o(e) { asyncGeneratorStep(a, r, i, o, s, "next", e) } function s(e) { asyncGeneratorStep(a, r, i, o, s, "throw", e) } o(void 0) }) } } function _classCallCheck(e, t) { if (!_instanceof(e, t)) throw new TypeError("Cannot call a class as a function") } function _defineProperties(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } function _createClass(e, t, n) { return t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), e } function _inherits(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && _setPrototypeOf(e, t) } function _createSuper(e) { var t = _isNativeReflectConstruct(); return function () { var n, r = _getPrototypeOf(e); if (t) { var i = _getPrototypeOf(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return _possibleConstructorReturn(this, n) } } function _possibleConstructorReturn(e, t) { return !t || "object" !== _typeof(t) && "function" != typeof t ? _assertThisInitialized(e) : t } function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function _wrapNativeSuper(e) { var t = "function" == typeof Map ? new Map : void 0; return (_wrapNativeSuper = function (e) { if (null === e || !_isNativeFunction(e)) return e; if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== t) { if (t.has(e)) return t.get(e); t.set(e, n) } function n() { return _construct(e, arguments, _getPrototypeOf(this).constructor) } return n.prototype = Object.create(e.prototype, { constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(n, e) })(e) } function _construct(e, t, n) { return (_construct = _isNativeReflectConstruct() ? Reflect.construct : function (e, t, n) { var r = [null]; r.push.apply(r, t); var i = new (Function.bind.apply(e, r)); return n && _setPrototypeOf(i, n.prototype), i }).apply(null, arguments) } function _isNativeReflectConstruct() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch (e) { return !1 } } function _isNativeFunction(e) { return -1 !== Function.toString.call(e).indexOf("[native code]") } function _setPrototypeOf(e, t) { return (_setPrototypeOf = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function _getPrototypeOf(e) { return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } function _instanceof(e, t) { return null != t && "undefined" != typeof Symbol && t[Symbol.hasInstance] ? !!t[Symbol.hasInstance](e) : e instanceof t } function _typeof(e) { return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } !function (e) { "use strict"; function t(e, t, n, i) { var a = t && t.prototype instanceof r ? t : r, o = Object.create(a.prototype), s = new d(i || []); return o._invoke = l(e, n, s), o } function n(e, t, n) { try { return { type: "normal", arg: e.call(t, n) } } catch (e) { return { type: "throw", arg: e } } } function r() { } function i() { } function a() { } function o(e) { ["next", "throw", "return"].forEach(function (t) { e[t] = function (e) { return this._invoke(t, e) } }) } function s(e) { function t(r, i, a, o) { var s = n(e[r], e, i); if ("throw" !== s.type) { var l = s.arg, c = l.value; return c && "object" == typeof c && v.call(c, "__await") ? Promise.resolve(c.__await).then(function (e) { t("next", e, a, o) }, function (e) { t("throw", e, a, o) }) : Promise.resolve(c).then(function (e) { l.value = e, a(l) }, o) } o(s.arg) } var r; this._invoke = function (e, n) { function i() { return new Promise(function (r, i) { t(e, n, r, i) }) } return r = r ? r.then(i, i) : i() } } function l(e, t, r) { var i = "suspendedStart"; return function (a, o) { if ("executing" === i) throw new Error("Generator is already running"); if ("completed" === i) { if ("throw" === a) throw o; return { value: void 0, done: !0 } } for (r.method = a, r.arg = o; ;) { var s = r.delegate; if (s) { var l = c(s, r); if (l) { if (l === M) continue; return l } } if ("next" === r.method) r.sent = r._sent = r.arg; else if ("throw" === r.method) { if ("suspendedStart" === i) throw i = "completed", r.arg; r.dispatchException(r.arg) } else "return" === r.method && r.abrupt("return", r.arg); i = "executing"; var u = n(e, t, r); if ("normal" === u.type) { if (i = r.done ? "completed" : "suspendedYield", u.arg === M) continue; return { value: u.arg, done: r.done } } "throw" === u.type && (i = "completed", r.method = "throw", r.arg = u.arg) } } } function c(e, t) { var r = e.iterator[t.method]; if (void 0 === r) { if (t.delegate = null, "throw" === t.method) { if (e.iterator.return && (t.method = "return", t.arg = void 0, c(e, t), "throw" === t.method)) return M; t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method") } return M } var i = n(r, e.iterator, t.arg); if ("throw" === i.type) return t.method = "throw", t.arg = i.arg, t.delegate = null, M; var a = i.arg; return a ? a.done ? (t[e.resultName] = a.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, M) : a : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, M) } function u(e) { var t = { tryLoc: e[0] }; 1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t) } function h(e) { var t = e.completion || {}; t.type = "normal", delete t.arg, e.completion = t } function d(e) { this.tryEntries = [{ tryLoc: "root" }], e.forEach(u, this), this.reset(!0) } function p(e) { if (e) { var t = e[y]; if (t) return t.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var n = -1, r = function t() { for (; ++n < e.length;)if (v.call(e, n)) return t.value = e[n], t.done = !1, t; return t.value = void 0, t.done = !0, t }; return r.next = r } } return { next: f } } function f() { return { value: void 0, done: !0 } } var m = Object.prototype, v = m.hasOwnProperty, g = "function" == typeof Symbol ? Symbol : {}, y = g.iterator || "@@iterator", b = g.asyncIterator || "@@asyncIterator", x = g.toStringTag || "@@toStringTag", _ = "object" == typeof module, w = e.regeneratorRuntime; if (w) _ && (module.exports = w); else { (w = e.regeneratorRuntime = _ ? module.exports : {}).wrap = t; var M = {}, S = {}; S[y] = function () { return this }; var T = Object.getPrototypeOf, E = T && T(T(p([]))); E && E !== m && v.call(E, y) && (S = E); var A = a.prototype = r.prototype = Object.create(S); i.prototype = A.constructor = a, a.constructor = i, a[x] = i.displayName = "GeneratorFunction", w.isGeneratorFunction = function (e) { var t = "function" == typeof e && e.constructor; return !!t && (t === i || "GeneratorFunction" === (t.displayName || t.name)) }, w.mark = function (e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, a) : (e.__proto__ = a, !(x in e) && (e[x] = "GeneratorFunction")), e.prototype = Object.create(A), e }, w.awrap = function (e) { return { __await: e } }, o(s.prototype), s.prototype[b] = function () { return this }, w.AsyncIterator = s, w.async = function (e, n, r, i) { var a = new s(t(e, n, r, i)); return w.isGeneratorFunction(n) ? a : a.next().then(function (e) { return e.done ? e.value : a.next() }) }, o(A), A[x] = "Generator", A[y] = function () { return this }, A.toString = function () { return "[object Generator]" }, w.keys = function (e) { var t = []; for (var n in e) t.push(n); return t.reverse(), function n() { for (; t.length;) { var r = t.pop(); if (r in e) return n.value = r, n.done = !1, n } return n.done = !0, n } }, w.values = p, d.prototype = { constructor: d, reset: function (e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(h), !e) for (var t in this) "t" === t.charAt(0) && v.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0) }, stop: function () { this.done = !0; var e = this.tryEntries[0].completion; if ("throw" === e.type) throw e.arg; return this.rval }, dispatchException: function (e) { function t(t, r) { return a.type = "throw", a.arg = e, n.next = t, r && (n.method = "next", n.arg = void 0), !!r } if (this.done) throw e; for (var n = this, r = this.tryEntries.length - 1; 0 <= r; --r) { var i = this.tryEntries[r], a = i.completion; if ("root" === i.tryLoc) return t("end"); if (i.tryLoc <= this.prev) { var o = v.call(i, "catchLoc"), s = v.call(i, "finallyLoc"); if (o && s) { if (this.prev < i.catchLoc) return t(i.catchLoc, !0); if (this.prev < i.finallyLoc) return t(i.finallyLoc) } else if (o) { if (this.prev < i.catchLoc) return t(i.catchLoc, !0) } else { if (!s) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return t(i.finallyLoc) } } } }, abrupt: function (e, t) { for (var n, r = this.tryEntries.length - 1; 0 <= r; --r)if ((n = this.tryEntries[r]).tryLoc <= this.prev && v.call(n, "finallyLoc") && this.prev < n.finallyLoc) { var i = n; break } i && ("break" === e || "continue" === e) && i.tryLoc <= t && t <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = e, a.arg = t, i ? (this.method = "next", this.next = i.finallyLoc, M) : this.complete(a) }, complete: function (e, t) { if ("throw" === e.type) throw e.arg; return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), M }, finish: function (e) { for (var t, n = this.tryEntries.length - 1; 0 <= n; --n)if ((t = this.tryEntries[n]).finallyLoc === e) return this.complete(t.completion, t.afterLoc), h(t), M }, catch: function (e) { for (var t, n = this.tryEntries.length - 1; 0 <= n; --n)if ((t = this.tryEntries[n]).tryLoc === e) { var r = t.completion; if ("throw" === r.type) { var i = r.arg; h(t) } return i } throw new Error("illegal catch attempt") }, delegateYield: function (e, t, n) { return this.delegate = { iterator: p(e), resultName: t, nextLoc: n }, "next" === this.method && (this.arg = void 0), M } } } }(function () { return this }() || Function("return this")()), function (e, t) { "object" === ("undefined" == typeof exports ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).ModelViewerElement = {}) }(this, function (e) { "use strict"; var t, n = Array.prototype.slice, r = Object.prototype.toString, i = Function.prototype.bind || function (e) { var t = this; if ("function" != typeof t || "[object Function]" !== r.call(t)) throw new TypeError("Function.prototype.bind called on incompatible " + t); for (var i, a = n.call(arguments, 1), o = Math.max(0, t.length - a.length), s = [], l = 0; l < o; l++)s.push("$" + l); if (i = Function("binder", "return function (" + s.join(",") + "){ return binder.apply(this,arguments); }")(function () { if (_instanceof(this, i)) { var r = t.apply(this, a.concat(n.call(arguments))); return Object(r) === r ? r : this } return t.apply(e, a.concat(n.call(arguments))) }), t.prototype) { var c = function () { }; c.prototype = t.prototype, i.prototype = new c, c.prototype = null } return i }, a = i.call(Function.call, Object.prototype.hasOwnProperty), o = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, s = o.Symbol, l = TypeError, c = Object.getOwnPropertyDescriptor; if (c) try { c({}, "") } catch (e) { c = null } var u = function () { throw new l }, h = c ? function () { try { return arguments.callee, u } catch (e) { try { return c(arguments, "callee").get } catch (e) { return u } } }() : u, d = "function" == typeof s && "function" == typeof Symbol && "symbol" === _typeof(s("foo")) && "symbol" === _typeof(Symbol("bar")) && function () { if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1; if ("symbol" === _typeof(Symbol.iterator)) return !0; var e = {}, t = Symbol("test"), n = Object(t); if ("string" == typeof t) return !1; if ("[object Symbol]" !== Object.prototype.toString.call(t)) return !1; if ("[object Symbol]" !== Object.prototype.toString.call(n)) return !1; for (t in e[t] = 42, e) return !1; if ("function" == typeof Object.keys && 0 !== Object.keys(e).length) return !1; if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length) return !1; var r = Object.getOwnPropertySymbols(e); if (1 !== r.length || r[0] !== t) return !1; if (!Object.prototype.propertyIsEnumerable.call(e, t)) return !1; if ("function" == typeof Object.getOwnPropertyDescriptor) { var i = Object.getOwnPropertyDescriptor(e, t); if (42 !== i.value || !0 !== i.enumerable) return !1 } return !0 }(), p = Object.getPrototypeOf || function (e) { return e.__proto__ }, f = "undefined" == typeof Uint8Array ? void 0 : p(Uint8Array), m = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": d ? p([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": d ? p(p([][Symbol.iterator]())) : void 0, "%JSON%": "object" === ("undefined" == typeof JSON ? "undefined" : _typeof(JSON)) ? JSON : void 0, "%JSONParse%": "object" === ("undefined" == typeof JSON ? "undefined" : _typeof(JSON)) ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && d ? p((new Map)[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && d ? p((new Set)[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": d ? p(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": d ? Symbol : void 0, "%SymbolPrototype%": d ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": h, "%TypedArray%": f, "%TypedArrayPrototype%": f ? f.prototype : void 0, "%TypeError%": l, "%TypeErrorPrototype%": l.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype }, v = i.call(Function.call, String.prototype.replace), g = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, y = /\\(\\)?/g, b = function (e, t) { if ("string" != typeof e || 0 === e.length) throw new TypeError("intrinsic name must be a non-empty string"); if (arguments.length > 1 && "boolean" != typeof t) throw new TypeError('"allowMissing" argument must be a boolean'); for (var n, r = (n = [], v(e, g, function (e, t, r, i) { n[n.length] = r ? v(i, y, "$1") : t || e }), n), i = function (e, t) { if (!(e in m)) throw new SyntaxError("intrinsic " + e + " does not exist!"); if (void 0 === m[e] && !t) throw new l("intrinsic " + e + " exists, but is not available. Please file an issue!"); return m[e] }("%" + (r.length > 0 ? r[0] : "") + "%", t), a = 1; a < r.length; a += 1)if (null != i) if (c && a + 1 >= r.length) { var o = c(i, r[a]); if (!(t || r[a] in i)) throw new l("base intrinsic for " + e + " exists, but the property is not available."); i = o ? o.get || o.value : i[r[a]] } else i = i[r[a]]; return i }, x = b("%TypeError%"), _ = function (e, t) { if (null == e) throw new x(t || "Cannot call method on " + e); return e }, w = b("%Function.prototype.apply%"), M = b("%Function.prototype.call%"), S = b("%Reflect.apply%", !0) || i.call(M, w), T = function () { return S(i, M, arguments) }; T.apply = function () { return S(i, w, arguments) }; var E, A, R, k, L = T(b("String.prototype.indexOf")), C = "function" == typeof (R = b(E = "Object.prototype.propertyIsEnumerable", !!A)) && L(E, ".prototype.") ? T(R) : R, P = function (e) { var t = _(e), n = []; for (var r in t) a(t, r) && C(t, r) && n.push(t[r]); return n }, O = Object.prototype.toString, I = function (e) { var t = O.call(e), n = "[object Arguments]" === t; return n || (n = "[object Array]" !== t && null !== e && "object" === _typeof(e) && "number" == typeof e.length && e.length >= 0 && "[object Function]" === O.call(e.callee)), n }; if (!Object.keys) { var N = Object.prototype.hasOwnProperty, D = Object.prototype.toString, F = I, U = Object.prototype.propertyIsEnumerable, z = !U.call({ toString: null }, "toString"), B = U.call(function () { }, "prototype"), H = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], G = function (e) { var t = e.constructor; return t && t.prototype === e }, V = { $applicationCache: !0, $console: !0, $external: !0, $frame: !0, $frameElement: !0, $frames: !0, $innerHeight: !0, $innerWidth: !0, $onmozfullscreenchange: !0, $onmozfullscreenerror: !0, $outerHeight: !0, $outerWidth: !0, $pageXOffset: !0, $pageYOffset: !0, $parent: !0, $scrollLeft: !0, $scrollTop: !0, $scrollX: !0, $scrollY: !0, $self: !0, $webkitIndexedDB: !0, $webkitStorageInfo: !0, $window: !0 }, j = function () { if ("undefined" == typeof window) return !1; for (var e in window) try { if (!V["$" + e] && N.call(window, e) && null !== window[e] && "object" === _typeof(window[e])) try { G(window[e]) } catch (e) { return !0 } } catch (e) { return !0 } return !1 }(); k = function (e) { var t = null !== e && "object" === _typeof(e), n = "[object Function]" === D.call(e), r = F(e), i = t && "[object String]" === D.call(e), a = []; if (!t && !n && !r) throw new TypeError("Object.keys called on a non-object"); var o = B && n; if (i && e.length > 0 && !N.call(e, 0)) for (var s = 0; s < e.length; ++s)a.push(String(s)); if (r && e.length > 0) for (var l = 0; l < e.length; ++l)a.push(String(l)); else for (var c in e) o && "prototype" === c || !N.call(e, c) || a.push(String(c)); if (z) for (var u = function (e) { if ("undefined" == typeof window || !j) return G(e); try { return G(e) } catch (e) { return !1 } }(e), h = 0; h < H.length; ++h)u && "constructor" === H[h] || !N.call(e, H[h]) || a.push(H[h]); return a } } var W = k, q = Array.prototype.slice, X = Object.keys, Y = X ? function (e) { return X(e) } : W, J = Object.keys; Y.shim = function () { Object.keys ? function () { var e = Object.keys(arguments); return e && e.length === arguments.length }(1, 2) || (Object.keys = function (e) { return I(e) ? J(q.call(e)) : J(e) }) : Object.keys = Y; return Object.keys || Y }; var Z = Y, K = "function" == typeof Symbol && "symbol" === _typeof(Symbol("foo")), Q = Object.prototype.toString, $ = Array.prototype.concat, ee = Object.defineProperty, te = ee && function () { var e = {}; try { for (var t in ee(e, "x", { enumerable: !1, value: e }), e) return !1; return e.x === e } catch (e) { return !1 } }(), ne = function (e, t, n, r) { var i; t in e && ("function" != typeof (i = r) || "[object Function]" !== Q.call(i) || !r()) || (te ? ee(e, t, { configurable: !0, enumerable: !1, value: n, writable: !0 }) : e[t] = n) }, re = function (e, t) { var n = arguments.length > 2 ? arguments[2] : {}, r = Z(t); K && (r = $.call(r, Object.getOwnPropertySymbols(t))); for (var i = 0; i < r.length; i += 1)ne(e, r[i], t[r[i]], n[r[i]]) }; re.supportsDescriptors = !!te; var ie, ae = re; ie = "function" == typeof Object.values ? Object.values : P, ae(Object, { values: ie }, { values: function () { return Object.values !== ie } }); "{{lit-".concat(String(Math.random()).slice(2), "}}"), window.trustedTypes && trustedTypes.createPolicy("lit-html", { createHTML: function (e) { return e } }); !function () { try { var e = { get capture() { return !0, !1 } }; window.addEventListener("test", e, e), window.removeEventListener("test", e, e) } catch (e) { } }(), "undefined" != typeof window && (window.litHtmlVersions || (window.litHtmlVersions = [])).push("1.3.0"), void 0 === window.ShadyCSS || void 0 === window.ShadyCSS.prepareTemplateDom && console.warn("Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1."), window.JSCompiler_renameProperty = function (e, t) { return e }; var oe = { toAttribute: function (e, t) { switch (t) { case Boolean: return e ? "" : null; case Object: case Array: return null == e ? e : JSON.stringify(e) }return e }, fromAttribute: function (e, t) { switch (t) { case Boolean: return null !== e; case Number: return null === e ? null : Number(e); case Object: case Array: return JSON.parse(e) }return e } }, se = function (e, t) { return t !== e && (t == t || e == e) }, le = { attribute: !0, type: String, converter: oe, reflect: !1, hasChanged: se }, ce = function (e) { _inherits(n, _wrapNativeSuper(HTMLElement)); var t = _createSuper(n); function n() { var e; return _classCallCheck(this, n), (e = t.call(this)).initialize(), e } return _createClass(n, [{ key: "initialize", value: function () { var e = this; this._updateState = 0, this._updatePromise = new Promise(function (t) { return e._enableUpdatingResolver = t }), this._changedProperties = new Map, this._saveInstanceProperties(), this.requestUpdateInternal() } }, { key: "_saveInstanceProperties", value: function () { var e = this; this.constructor._classProperties.forEach(function (t, n) { if (e.hasOwnProperty(n)) { var r = e[n]; delete e[n], e._instanceProperties || (e._instanceProperties = new Map), e._instanceProperties.set(n, r) } }) } }, { key: "_applyInstanceProperties", value: function () { var e = this; this._instanceProperties.forEach(function (t, n) { return e[n] = t }), this._instanceProperties = void 0 } }, { key: "connectedCallback", value: function () { this.enableUpdating() } }, { key: "enableUpdating", value: function () { void 0 !== this._enableUpdatingResolver && (this._enableUpdatingResolver(), this._enableUpdatingResolver = void 0) } }, { key: "disconnectedCallback", value: function () { } }, { key: "attributeChangedCallback", value: function (e, t, n) { t !== n && this._attributeToProperty(e, n) } }, { key: "_propertyToAttribute", value: function (e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : le, r = this.constructor, i = r._attributeNameForProperty(e, n); if (void 0 !== i) { var a = r._propertyValueToAttribute(t, n); if (void 0 === a) return; this._updateState = 8 | this._updateState, null == a ? this.removeAttribute(i) : this.setAttribute(i, a), this._updateState = -9 & this._updateState } } }, { key: "_attributeToProperty", value: function (e, t) { if (!(8 & this._updateState)) { var n = this.constructor, r = n._attributeToPropertyMap.get(e); if (void 0 !== r) { var i = n.getPropertyOptions(r); this._updateState = 16 | this._updateState, this[r] = n._propertyValueFromAttribute(t, i), this._updateState = -17 & this._updateState } } } }, { key: "requestUpdateInternal", value: function (e, t, n) { var r = !0; if (void 0 !== e) { var i = this.constructor; n = n || i.getPropertyOptions(e), i._valueHasChanged(this[e], t, n.hasChanged) ? (this._changedProperties.has(e) || this._changedProperties.set(e, t), !0 !== n.reflect || 16 & this._updateState || (void 0 === this._reflectingProperties && (this._reflectingProperties = new Map), this._reflectingProperties.set(e, n))) : r = !1 } !this._hasRequestedUpdate && r && (this._updatePromise = this._enqueueUpdate()) } }, { key: "requestUpdate", value: function (e, t) { return this.requestUpdateInternal(e, t), this.updateComplete } }, { key: "_enqueueUpdate", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e() { var t; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return this._updateState = 4 | this._updateState, e.prev = 1, e.next = 4, this._updatePromise; case 4: e.next = 8; break; case 6: e.prev = 6, e.t0 = e.catch(1); case 8: if (null == (t = this.performUpdate())) { e.next = 12; break } return e.next = 12, t; case 12: return e.abrupt("return", !this._hasRequestedUpdate); case 13: case "end": return e.stop() } }, e, this, [[1, 6]]) })); return function () { return e.apply(this, arguments) } }() }, { key: "performUpdate", value: function () { if (this._hasRequestedUpdate) { this._instanceProperties && this._applyInstanceProperties(); var e = !1, t = this._changedProperties; try { (e = this.shouldUpdate(t)) ? this.update(t) : this._markUpdated() } catch (t) { throw e = !1, this._markUpdated(), t } e && (1 & this._updateState || (this._updateState = 1 | this._updateState, this.firstUpdated(t)), this.updated(t)) } } }, { key: "_markUpdated", value: function () { this._changedProperties = new Map, this._updateState = -5 & this._updateState } }, { key: "_getUpdateComplete", value: function () { return this._updatePromise } }, { key: "shouldUpdate", value: function (e) { return !0 } }, { key: "update", value: function (e) { var t = this; void 0 !== this._reflectingProperties && this._reflectingProperties.size > 0 && (this._reflectingProperties.forEach(function (e, n) { return t._propertyToAttribute(n, t[n], e) }), this._reflectingProperties = void 0), this._markUpdated() } }, { key: "updated", value: function (e) { } }, { key: "firstUpdated", value: function (e) { } }, { key: "_hasRequestedUpdate", get: function () { return 4 & this._updateState } }, { key: "hasUpdated", get: function () { return 1 & this._updateState } }, { key: "updateComplete", get: function () { return this._getUpdateComplete() } }], [{ key: "_ensureClassProperties", value: function () { var e = this; if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) { this._classProperties = new Map; var t = Object.getPrototypeOf(this)._classProperties; void 0 !== t && t.forEach(function (t, n) { return e._classProperties.set(n, t) }) } } }, { key: "createProperty", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : le; if (this._ensureClassProperties(), this._classProperties.set(e, t), !t.noAccessor && !this.prototype.hasOwnProperty(e)) { var n = "symbol" === _typeof(e) ? Symbol() : "__".concat(e), r = this.getPropertyDescriptor(e, n, t); void 0 !== r && Object.defineProperty(this.prototype, e, r) } } }, { key: "getPropertyDescriptor", value: function (e, t, n) { return { get: function () { return this[t] }, set: function (r) { var i = this[e]; this[t] = r, this.requestUpdateInternal(e, i, n) }, configurable: !0, enumerable: !0 } } }, { key: "getPropertyOptions", value: function (e) { return this._classProperties && this._classProperties.get(e) || le } }, { key: "finalize", value: function () { var e = Object.getPrototypeOf(this); if (e.hasOwnProperty("finalized") || e.finalize(), this.finalized = !0, this._ensureClassProperties(), this._attributeToPropertyMap = new Map, this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) { var t, n = this.properties, r = _createForOfIteratorHelper([].concat(_toConsumableArray(Object.getOwnPropertyNames(n)), _toConsumableArray("function" == typeof Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(n) : []))); try { for (r.s(); !(t = r.n()).done;) { var i = t.value; this.createProperty(i, n[i]) } } catch (e) { r.e(e) } finally { r.f() } } } }, { key: "_attributeNameForProperty", value: function (e, t) { var n = t.attribute; return !1 === n ? void 0 : "string" == typeof n ? n : "string" == typeof e ? e.toLowerCase() : void 0 } }, { key: "_valueHasChanged", value: function (e, t) { return (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : se)(e, t) } }, { key: "_propertyValueFromAttribute", value: function (e, t) { var n = t.type, r = t.converter || oe, i = "function" == typeof r ? r : r.fromAttribute; return i ? i(e, n) : e } }, { key: "_propertyValueToAttribute", value: function (e, t) { if (void 0 !== t.reflect) { var n = t.type, r = t.converter; return (r && r.toAttribute || oe.toAttribute)(e, n) } } }, { key: "observedAttributes", get: function () { var e = this; this.finalize(); var t = []; return this._classProperties.forEach(function (n, r) { var i = e._attributeNameForProperty(r, n); void 0 !== i && (e._attributeToPropertyMap.set(i, r), t.push(i)) }), t } }]), n }(); ce.finalized = !0; var ue = function (e, t) { return "method" !== t.kind || !t.descriptor || "value" in t.descriptor ? { kind: "field", key: Symbol(), placement: "own", descriptor: {}, initializer: function () { "function" == typeof t.initializer && (this[t.key] = t.initializer.call(this)) }, finisher: function (n) { n.createProperty(t.key, e) } } : Object.assign(Object.assign({}, t), { finisher: function (n) { n.createProperty(t.key, e) } }) }, he = function (e, t, n) { t.constructor.createProperty(n, e) }; function de(e) { return function (t, n) { return void 0 !== n ? he(e, t, n) : ue(e, t) } } window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && CSSStyleSheet.prototype; (window.litElementVersions || (window.litElementVersions = [])).push("2.4.0"); var pe, fe, me, ve = null != navigator.xr && null != self.XRSession && null != navigator.xr.isSessionSupported, ge = ve && self.XRSession.prototype.requestHitTestSource, ye = null != self.ResizeObserver, be = null != self.IntersectionObserver, xe = ge, _e = (pe = navigator.userAgent || navigator.vendor || self.opera, fe = !1, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(pe) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(pe.substr(0, 4))) && (fe = !0), /\bCrOS\b/.test(navigator.userAgent), /android/i.test(navigator.userAgent)), we = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1, Me = (me = document.createElement("a"), Boolean(me.relList && me.relList.supports && me.relList.supports("ar"))), Se = /Safari\//.test(navigator.userAgent), Te = /firefox/i.test(navigator.userAgent), Ee = /OculusBrowser/.test(navigator.userAgent), Ae = we && /CriOS\//.test(navigator.userAgent), Re = we && Se, ke = _e && !Te && !Ee, Le = document.createElement("template"); Le.innerHTML = '\n<style>\n:host {\n  display: block;\n  position: relative;\n  contain: strict;\n  width: 300px;\n  height: 150px;\n}\n\n/* NOTE: This ruleset is our integration surface area with the\n * :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196 */\n:host([data-js-focus-visible]:focus:not(.focus-visible)),\n:host([data-js-focus-visible]) :focus:not(.focus-visible) {\n  outline: none;\n}\n\n.container {\n  position: relative;\n}\n\n.userInput {\n  width: 100%;\n  height: 100%;\n  display: block;\n  position: relative;\n  overflow: hidden;\n}\n\ncanvas {\n  position: absolute;\n  display: none;\n  pointer-events: none;\n  /* NOTE(cdata): Chrome 76 and below apparently have a bug\n   * that causes our canvas not to display pixels unless it is\n   * on its own render layer\n   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893\n   */\n  transform: translateZ(0);\n}\n\ncanvas.show {\n  display: block;\n}\n\n/* Adapted from HTML5 Boilerplate\n *\n * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */\n.screen-reader-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  white-space: nowrap;\n  width: 1px;\n}\n\n.slot {\n  position: absolute;\n  pointer-events: none;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.slot > * {\n  pointer-events: initial;\n}\n\n.annotation-wrapper ::slotted(*) {\n  opacity: var(--max-hotspot-opacity, 1);\n  transition: opacity 0.3s;\n}\n\n.pointer-tumbling .annotation-wrapper ::slotted(*) {\n  pointer-events: none;\n}\n\n.annotation-wrapper ::slotted(*) {\n  pointer-events: initial;\n}\n\n.annotation-wrapper.hide ::slotted(*) {\n  opacity: var(--min-hotspot-opacity, 0.25);\n}\n\n.slot.poster {\n  opacity: 0;\n  transition: opacity 0.3s 0.3s;\n  background-color: inherit;\n}\n\n.slot.poster.show {\n  opacity: 1;\n  transition: none;\n}\n\n.slot.poster > * {\n  pointer-events: initial;\n}\n\n.slot.poster:not(.show) > * {\n  pointer-events: none;\n}\n\n#default-poster {\n  width: 100%;\n  height: 100%;\n  /* The default poster is a <button> so we need to set display\n   * to prevent it from being affected by text-align: */\n  display: block;\n  position: absolute;\n  border: none;\n  padding: 0;\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-color: var(--poster-color, #fff);\n  background-image: var(--poster-image, none);\n}\n\n#default-progress-bar {\n  display: block;\n  position: relative;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  overflow: hidden;\n}\n\n#default-progress-bar > .mask {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: var(--progress-mask, #fff);\n  transition: opacity 0.3s;\n  opacity: 0.2;\n}\n\n#default-progress-bar > .bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: var(--progress-bar-height, 5px);\n  transition: transform 0.09s;\n  transform-origin: top left;\n  transform: scaleX(0);\n  overflow: hidden;\n}\n\n#default-progress-bar > .bar:before {\n  content: \'\';\n  display: block;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n\n  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));\n\n  transition: none;\n  transform-origin: top left;\n  transform: translateY(0);\n}\n\n#default-progress-bar > .bar.hide:before {\n  transition: transform 0.3s 1s;\n  transform: translateY(-100%);\n}\n\n.slot.interaction-prompt {\n  display: var(--interaction-prompt-display, flex);\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  align-items: center;\n  justify-content: center;\n\n  opacity: 0;\n  will-change: opacity;\n  overflow: hidden;\n  transition: opacity 0.3s;\n}\n\n.slot.interaction-prompt.visible {\n  opacity: 1;\n}\n\n.slot.interaction-prompt > .animated-container {\n  will-change: transform, opacity;\n}\n\n.slot.interaction-prompt > * {\n  pointer-events: none;\n}\n\n.slot.ar-button {\n  -moz-user-select: none;\n  -webkit-tap-highlight-color: transparent;\n  user-select: none;\n\n  display: var(--ar-button-display, block);\n}\n\n.slot.ar-button:not(.enabled) {\n  display: none;\n}\n\n.fab {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: 40px;\n  height: 40px;\n  cursor: pointer;\n  background-color: #fff;\n  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);\n  border-radius: 100px;\n}\n\n.fab > * {\n  opacity: 0.87;\n}\n\n#default-ar-button {\n  position: absolute;\n  bottom: 16px;\n  right: 16px;\n  transform: scale(var(--ar-button-scale, 1));\n  transform-origin: bottom right;\n}\n\n.slot.default {\n  pointer-events: none;\n}\n\n.slot.progress-bar {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button:not(.enabled) {\n  display: none;\n}\n\n#default-exit-webxr-ar-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  top: 16px;\n  left: 16px;\n  width: 40px;\n  height: 40px;\n  box-sizing: border-box;\n}\n\n#default-exit-webxr-ar-button > svg {\n  fill: #fff;\n}\n</style>\n<div class="container">\n  <div class="userInput" tabindex="0" role="img"\n      aria-label="A depiction of a 3D model"\n      aria-live="polite">\n    <canvas></canvas>\n  </div>\n\n  \x3c!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM\n        will have their <slot> elements removed by ShadyCSS --\x3e\n  <div class="slot poster">\n    <slot name="poster">\n      <button type="button" id="default-poster" aria-hidden="true" aria-label="Activate to view in 3D!"></button>\n    </slot>\n  </div>\n\n  <div class="slot ar-button">\n    <slot name="ar-button">\n      <a id="default-ar-button" class="fab"\n          tabindex="2"\n          aria-label="View this 3D model up close">\n        '.concat('\n<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"\n\t xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"\n\t viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">\n<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>\n<g id="Art_layer">\n\t<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>\n\t<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>\n\t<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>\n\t<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>\n\t<g>\n\t\t<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3\n\t\t\tl5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62\n\t\t\tl4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>\n\t</g>\n</g>\n</svg>', '\n      </a>\n    </slot>\n  </div>\n\n  <div class="slot interaction-prompt">\n    <div class="animated-container" part="interaction-prompt">\n      <slot name="interaction-prompt" aria-hidden="true">\n        ').concat('\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">\n    <defs>\n        <path id="A" d="M.001.232h24.997V36H.001z" />\n    </defs>\n    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">\n        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />\n        <g transform="translate(11 3)">\n            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />\n            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />\n            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />\n            <g transform="translate(0 .769)">\n                <mask id="B" fill="#fff">\n                    <use xlink:href="#A" />\n                </mask>\n                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />\n            </g>\n        </g>\n    </g>\n</svg>', '\n      </slot>\n    </div>\n  </div>\n\n  <div class="slot default">\n    <slot></slot>\n\n    <div class="slot progress-bar">\n      <slot name="progress-bar">\n        <div id="default-progress-bar" aria-hidden="true">\n          <div class="mask"></div>\n          <div class="bar"></div>\n        </div>\n      </slot>\n    </div>\n    \n    <div class="slot exit-webxr-ar-button">\n      <slot name="exit-webxr-ar-button">\n        <a id="default-exit-webxr-ar-button"\n            tabindex="3"\n            aria-label="Exit AR"\n            aria-hidden="true">\n          ').concat('\n<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">\n    \x3c!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement\n         support for dynamic re-coloring of UI components --\x3e\n    <defs>\n      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">\n        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>\n        <feOffset dx="0" dy="0" result="offsetblur"/>\n        <feFlood flood-color="#000000"/>\n        <feComposite in2="offsetblur" operator="in"/>\n        <feMerge>\n          <feMergeNode/>\n          <feMergeNode in="SourceGraphic"/>\n        </feMerge>\n      </filter>\n    </defs>\n    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>', "\n        </a>\n      </slot>\n    </div>\n  </div>\n</div>"); var Ce = 0, Pe = 1, Oe = 2, Ie = 1, Ne = 2, De = 3, Fe = 0, Ue = 1, ze = 2, Be = 0, He = 1, Ge = 2, Ve = 3, je = 4, We = 5, qe = 100, Xe = 101, Ye = 102, Je = 103, Ze = 104, Ke = 200, Qe = 201, $e = 202, et = 203, tt = 204, nt = 205, rt = 206, it = 207, at = 208, ot = 209, st = 210, lt = 0, ct = 1, ut = 2, ht = 3, dt = 4, pt = 5, ft = 6, mt = 7, vt = 0, gt = 1, yt = 2, bt = 0, xt = 1, _t = 2, wt = 3, Mt = 4, St = 5, Tt = 301, Et = 302, At = 303, Rt = 304, kt = 306, Lt = 307, Ct = 1e3, Pt = 1001, Ot = 1002, It = 1003, Nt = 1004, Dt = 1005, Ft = 1006, Ut = 1007, zt = 1008, Bt = 1009, Ht = 1010, Gt = 1011, Vt = 1012, jt = 1013, Wt = 1014, qt = 1015, Xt = 1016, Yt = 1017, Jt = 1018, Zt = 1019, Kt = 1020, Qt = 1021, $t = 1022, en = 1023, tn = 1024, nn = 1025, rn = en, an = 1026, on = 1027, sn = 1028, ln = 1029, cn = 1030, un = 1031, hn = 1032, dn = 1033, pn = 33776, fn = 33777, mn = 33778, vn = 33779, gn = 35840, yn = 35841, bn = 35842, xn = 35843, _n = 36196, wn = 37492, Mn = 37496, Sn = 37808, Tn = 37809, En = 37810, An = 37811, Rn = 37812, kn = 37813, Ln = 37814, Cn = 37815, Pn = 37816, On = 37817, In = 37818, Nn = 37819, Dn = 37820, Fn = 37821, Un = 36492, zn = 37840, Bn = 37841, Hn = 37842, Gn = 37843, Vn = 37844, jn = 37845, Wn = 37846, qn = 37847, Xn = 37848, Yn = 37849, Jn = 37850, Zn = 37851, Kn = 37852, Qn = 37853, $n = 2201, er = 2300, tr = 2400, nr = 2500, rr = 2, ir = 3e3, ar = 3001, or = 3007, sr = 3002, lr = 3003, cr = 3004, ur = 3005, hr = 3006, dr = 3200, pr = 3201, fr = 0, mr = 1, vr = 7680, gr = 519, yr = 35044, br = "300 es"; function xr() { } Object.assign(xr.prototype, { addEventListener: function (e, t) { void 0 === this._listeners && (this._listeners = {}); var n = this._listeners; void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t) }, hasEventListener: function (e, t) { if (void 0 === this._listeners) return !1; var n = this._listeners; return void 0 !== n[e] && -1 !== n[e].indexOf(t) }, removeEventListener: function (e, t) { if (void 0 !== this._listeners) { var n = this._listeners[e]; if (void 0 !== n) { var r = n.indexOf(t); -1 !== r && n.splice(r, 1) } } }, dispatchEvent: function (e) { if (void 0 !== this._listeners) { var t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; for (var n = t.slice(0), r = 0, i = n.length; r < i; r++)n[r].call(this, e) } } } }); for (var _r = [], wr = 0; wr < 256; wr++)_r[wr] = (wr < 16 ? "0" : "") + wr.toString(16); var Mr, Sr = 1234567, Tr = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { var e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return (_r[255 & e] + _r[e >> 8 & 255] + _r[e >> 16 & 255] + _r[e >> 24 & 255] + "-" + _r[255 & t] + _r[t >> 8 & 255] + "-" + _r[t >> 16 & 15 | 64] + _r[t >> 24 & 255] + "-" + _r[63 & n | 128] + _r[n >> 8 & 255] + "-" + _r[n >> 16 & 255] + _r[n >> 24 & 255] + _r[255 & r] + _r[r >> 8 & 255] + _r[r >> 16 & 255] + _r[r >> 24 & 255]).toUpperCase() }, clamp: function (e, t, n) { return Math.max(t, Math.min(n, e)) }, euclideanModulo: function (e, t) { return (e % t + t) % t }, mapLinear: function (e, t, n, r, i) { return r + (e - t) * (i - r) / (n - t) }, lerp: function (e, t, n) { return (1 - n) * e + n * t }, smoothstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, seededRandom: function (e) { return void 0 !== e && (Sr = e % 2147483647), ((Sr = 16807 * Sr % 2147483647) - 1) / 2147483646 }, degToRad: function (e) { return e * Tr.DEG2RAD }, radToDeg: function (e) { return e * Tr.RAD2DEG }, isPowerOfTwo: function (e) { return 0 == (e & e - 1) && 0 !== e }, ceilPowerOfTwo: function (e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) }, floorPowerOfTwo: function (e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) }, setQuaternionFromProperEuler: function (e, t, n, r, i) { var a = Math.cos, o = Math.sin, s = a(n / 2), l = o(n / 2), c = a((t + r) / 2), u = o((t + r) / 2), h = a((t - r) / 2), d = o((t - r) / 2), p = a((r - t) / 2), f = o((r - t) / 2); switch (i) { case "XYX": e.set(s * u, l * h, l * d, s * c); break; case "YZY": e.set(l * d, s * u, l * h, s * c); break; case "ZXZ": e.set(l * h, l * d, s * u, s * c); break; case "XZX": e.set(s * u, l * f, l * p, s * c); break; case "YXY": e.set(l * p, s * u, l * f, s * c); break; case "ZYZ": e.set(l * f, l * p, s * u, s * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i) } } }, Er = function () { function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; _classCallCheck(this, e), Object.defineProperty(this, "isVector2", { value: !0 }), this.x = t, this.y = n } return _createClass(e, [{ key: "set", value: function (e, t) { return this.x = e, this.y = t, this } }, { key: "setScalar", value: function (e) { return this.x = e, this.y = e, this } }, { key: "setX", value: function (e) { return this.x = e, this } }, { key: "setY", value: function (e) { return this.y = e, this } }, { key: "setComponent", value: function (e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } }, { key: "getComponent", value: function (e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } }, { key: "clone", value: function () { return new this.constructor(this.x, this.y) } }, { key: "copy", value: function (e) { return this.x = e.x, this.y = e.y, this } }, { key: "add", value: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this) } }, { key: "addScalar", value: function (e) { return this.x += e, this.y += e, this } }, { key: "addVectors", value: function (e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } }, { key: "addScaledVector", value: function (e, t) { return this.x += e.x * t, this.y += e.y * t, this } }, { key: "sub", value: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this) } }, { key: "subScalar", value: function (e) { return this.x -= e, this.y -= e, this } }, { key: "subVectors", value: function (e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } }, { key: "multiply", value: function (e) { return this.x *= e.x, this.y *= e.y, this } }, { key: "multiplyScalar", value: function (e) { return this.x *= e, this.y *= e, this } }, { key: "divide", value: function (e) { return this.x /= e.x, this.y /= e.y, this } }, { key: "divideScalar", value: function (e) { return this.multiplyScalar(1 / e) } }, { key: "applyMatrix3", value: function (e) { var t = this.x, n = this.y, r = e.elements; return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this } }, { key: "min", value: function (e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } }, { key: "max", value: function (e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } }, { key: "clamp", value: function (e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } }, { key: "clampScalar", value: function (e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } }, { key: "clampLength", value: function (e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } }, { key: "floor", value: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } }, { key: "ceil", value: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } }, { key: "round", value: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } }, { key: "roundToZero", value: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } }, { key: "negate", value: function () { return this.x = -this.x, this.y = -this.y, this } }, { key: "dot", value: function (e) { return this.x * e.x + this.y * e.y } }, { key: "cross", value: function (e) { return this.x * e.y - this.y * e.x } }, { key: "lengthSq", value: function () { return this.x * this.x + this.y * this.y } }, { key: "length", value: function () { return Math.sqrt(this.x * this.x + this.y * this.y) } }, { key: "manhattanLength", value: function () { return Math.abs(this.x) + Math.abs(this.y) } }, { key: "normalize", value: function () { return this.divideScalar(this.length() || 1) } }, { key: "angle", value: function () { var e = Math.atan2(-this.y, -this.x) + Math.PI; return e } }, { key: "distanceTo", value: function (e) { return Math.sqrt(this.distanceToSquared(e)) } }, { key: "distanceToSquared", value: function (e) { var t = this.x - e.x, n = this.y - e.y; return t * t + n * n } }, { key: "manhattanDistanceTo", value: function (e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } }, { key: "setLength", value: function (e) { return this.normalize().multiplyScalar(e) } }, { key: "lerp", value: function (e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } }, { key: "lerpVectors", value: function (e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this } }, { key: "equals", value: function (e) { return e.x === this.x && e.y === this.y } }, { key: "fromArray", value: function (e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this } }, { key: "toArray", value: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e } }, { key: "fromBufferAttribute", value: function (e, t, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this } }, { key: "rotateAround", value: function (e, t) { var n = Math.cos(t), r = Math.sin(t), i = this.x - e.x, a = this.y - e.y; return this.x = i * n - a * r + e.x, this.y = i * r + a * n + e.y, this } }, { key: "random", value: function () { return this.x = Math.random(), this.y = Math.random(), this } }, { key: "width", get: function () { return this.x }, set: function (e) { this.x = e } }, { key: "height", get: function () { return this.y }, set: function (e) { this.y = e } }]), e }(), Ar = function () { function e() { _classCallCheck(this, e), Object.defineProperty(this, "isMatrix3", { value: !0 }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } return _createClass(e, [{ key: "set", value: function (e, t, n, r, i, a, o, s, l) { var c = this.elements; return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = i, c[5] = s, c[6] = n, c[7] = a, c[8] = l, this } }, { key: "identity", value: function () { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } }, { key: "clone", value: function () { return (new this.constructor).fromArray(this.elements) } }, { key: "copy", value: function (e) { var t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this } }, { key: "extractBasis", value: function (e, t, n) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } }, { key: "setFromMatrix4", value: function (e) { var t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } }, { key: "multiply", value: function (e) { return this.multiplyMatrices(this, e) } }, { key: "premultiply", value: function (e) { return this.multiplyMatrices(e, this) } }, { key: "multiplyMatrices", value: function (e, t) { var n = e.elements, r = t.elements, i = this.elements, a = n[0], o = n[3], s = n[6], l = n[1], c = n[4], u = n[7], h = n[2], d = n[5], p = n[8], f = r[0], m = r[3], v = r[6], g = r[1], y = r[4], b = r[7], x = r[2], _ = r[5], w = r[8]; return i[0] = a * f + o * g + s * x, i[3] = a * m + o * y + s * _, i[6] = a * v + o * b + s * w, i[1] = l * f + c * g + u * x, i[4] = l * m + c * y + u * _, i[7] = l * v + c * b + u * w, i[2] = h * f + d * g + p * x, i[5] = h * m + d * y + p * _, i[8] = h * v + d * b + p * w, this } }, { key: "multiplyScalar", value: function (e) { var t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } }, { key: "determinant", value: function () { var e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], a = e[4], o = e[5], s = e[6], l = e[7], c = e[8]; return t * a * c - t * o * l - n * i * c + n * o * s + r * i * l - r * a * s } }, { key: "getInverse", value: function (e, t) { void 0 !== t && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate."); var n = e.elements, r = this.elements, i = n[0], a = n[1], o = n[2], s = n[3], l = n[4], c = n[5], u = n[6], h = n[7], d = n[8], p = d * l - c * h, f = c * u - d * s, m = h * s - l * u, v = i * p + a * f + o * m; if (0 === v) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); var g = 1 / v; return r[0] = p * g, r[1] = (o * h - d * a) * g, r[2] = (c * a - o * l) * g, r[3] = f * g, r[4] = (d * i - o * u) * g, r[5] = (o * s - c * i) * g, r[6] = m * g, r[7] = (a * u - h * i) * g, r[8] = (l * i - a * s) * g, this } }, { key: "transpose", value: function () { var e, t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } }, { key: "getNormalMatrix", value: function (e) { return this.setFromMatrix4(e).getInverse(this).transpose() } }, { key: "transposeIntoArray", value: function (e) { var t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } }, { key: "setUvTransform", value: function (e, t, n, r, i, a, o) { var s = Math.cos(i), l = Math.sin(i); this.set(n * s, n * l, -n * (s * a + l * o) + a + e, -r * l, r * s, -r * (-l * a + s * o) + o + t, 0, 0, 1) } }, { key: "scale", value: function (e, t) { var n = this.elements; return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this } }, { key: "rotate", value: function (e) { var t = Math.cos(e), n = Math.sin(e), r = this.elements, i = r[0], a = r[3], o = r[6], s = r[1], l = r[4], c = r[7]; return r[0] = t * i + n * s, r[3] = t * a + n * l, r[6] = t * o + n * c, r[1] = -n * i + t * s, r[4] = -n * a + t * l, r[7] = -n * o + t * c, this } }, { key: "translate", value: function (e, t) { var n = this.elements; return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this } }, { key: "equals", value: function (e) { for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)if (t[r] !== n[r]) return !1; return !0 } }, { key: "fromArray", value: function (e, t) { void 0 === t && (t = 0); for (var n = 0; n < 9; n++)this.elements[n] = e[n + t]; return this } }, { key: "toArray", value: function (e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); var n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e } }]), e }(), Rr = { getDataURL: function (e) { if (/^data:/i.test(e.src)) return e.src; if ("undefined" == typeof HTMLCanvasElement) return e.src; var t; if (_instanceof(e, HTMLCanvasElement)) t = e; else { void 0 === Mr && (Mr = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Mr.width = e.width, Mr.height = e.height; var n = Mr.getContext("2d"); _instanceof(e, ImageData) ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Mr } return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png") } }, kr = 0; function Lr(e, t, n, r, i, a, o, s, l, c) { Object.defineProperty(this, "id", { value: kr++ }), this.uuid = Tr.generateUUID(), this.name = "", this.image = void 0 !== e ? e : Lr.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : Lr.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : Pt, this.wrapT = void 0 !== r ? r : Pt, this.magFilter = void 0 !== i ? i : Ft, this.minFilter = void 0 !== a ? a : zt, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== o ? o : en, this.internalFormat = null, this.type = void 0 !== s ? s : Bt, this.offset = new Er(0, 0), this.repeat = new Er(1, 1), this.center = new Er(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ar, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== c ? c : ir, this.version = 0, this.onUpdate = null } Lr.DEFAULT_IMAGE = void 0, Lr.DEFAULT_MAPPING = 300, Lr.prototype = Object.assign(Object.create(xr.prototype), { constructor: Lr, isTexture: !0, updateMatrix: function () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this }, toJSON: function (e) { var t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; var n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { var r = this.image; if (void 0 === r.uuid && (r.uuid = Tr.generateUUID()), !t && void 0 === e.images[r.uuid]) { var i; if (Array.isArray(r)) { i = []; for (var a = 0, o = r.length; a < o; a++)i.push(Rr.getDataURL(r[a])) } else i = Rr.getDataURL(r); e.images[r.uuid] = { uuid: r.uuid, url: i } } n.image = r.uuid } return t || (e.textures[this.uuid] = n), n }, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (e) { if (300 !== this.mapping) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case Ct: e.x = e.x - Math.floor(e.x); break; case Pt: e.x = e.x < 0 ? 0 : 1; break; case Ot: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case Ct: e.y = e.y - Math.floor(e.y); break; case Pt: e.y = e.y < 0 ? 0 : 1; break; case Ot: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } }), Object.defineProperty(Lr.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }); var Cr = function () { function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1; _classCallCheck(this, e), Object.defineProperty(this, "isVector4", { value: !0 }), this.x = t, this.y = n, this.z = r, this.w = i } return _createClass(e, [{ key: "set", value: function (e, t, n, r) { return this.x = e, this.y = t, this.z = n, this.w = r, this } }, { key: "setScalar", value: function (e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } }, { key: "setX", value: function (e) { return this.x = e, this } }, { key: "setY", value: function (e) { return this.y = e, this } }, { key: "setZ", value: function (e) { return this.z = e, this } }, { key: "setW", value: function (e) { return this.w = e, this } }, { key: "setComponent", value: function (e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } }, { key: "getComponent", value: function (e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } }, { key: "clone", value: function () { return new this.constructor(this.x, this.y, this.z, this.w) } }, { key: "copy", value: function (e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this } }, { key: "add", value: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this) } }, { key: "addScalar", value: function (e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } }, { key: "addVectors", value: function (e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } }, { key: "addScaledVector", value: function (e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } }, { key: "sub", value: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this) } }, { key: "subScalar", value: function (e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } }, { key: "subVectors", value: function (e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } }, { key: "multiplyScalar", value: function (e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } }, { key: "applyMatrix4", value: function (e) { var t = this.x, n = this.y, r = this.z, i = this.w, a = e.elements; return this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * i, this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * i, this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * i, this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * i, this } }, { key: "divideScalar", value: function (e) { return this.multiplyScalar(1 / e) } }, { key: "setAxisAngleFromQuaternion", value: function (e) { this.w = 2 * Math.acos(e.w); var t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } }, { key: "setAxisAngleFromRotationMatrix", value: function (e) { var t, n, r, i, a = e.elements, o = a[0], s = a[4], l = a[8], c = a[1], u = a[5], h = a[9], d = a[2], p = a[6], f = a[10]; if (Math.abs(s - c) < .01 && Math.abs(l - d) < .01 && Math.abs(h - p) < .01) { if (Math.abs(s + c) < .1 && Math.abs(l + d) < .1 && Math.abs(h + p) < .1 && Math.abs(o + u + f - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; var m = (o + 1) / 2, v = (u + 1) / 2, g = (f + 1) / 2, y = (s + c) / 4, b = (l + d) / 4, x = (h + p) / 4; return m > v && m > g ? m < .01 ? (n = 0, r = .707106781, i = .707106781) : (r = y / (n = Math.sqrt(m)), i = b / n) : v > g ? v < .01 ? (n = .707106781, r = 0, i = .707106781) : (n = y / (r = Math.sqrt(v)), i = x / r) : g < .01 ? (n = .707106781, r = .707106781, i = 0) : (n = b / (i = Math.sqrt(g)), r = x / i), this.set(n, r, i, t), this } var _ = Math.sqrt((p - h) * (p - h) + (l - d) * (l - d) + (c - s) * (c - s)); return Math.abs(_) < .001 && (_ = 1), this.x = (p - h) / _, this.y = (l - d) / _, this.z = (c - s) / _, this.w = Math.acos((o + u + f - 1) / 2), this } }, { key: "min", value: function (e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } }, { key: "max", value: function (e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } }, { key: "clamp", value: function (e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } }, { key: "clampScalar", value: function (e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } }, { key: "clampLength", value: function (e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } }, { key: "floor", value: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } }, { key: "ceil", value: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } }, { key: "round", value: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } }, { key: "roundToZero", value: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } }, { key: "negate", value: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } }, { key: "dot", value: function (e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } }, { key: "lengthSq", value: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } }, { key: "length", value: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } }, { key: "manhattanLength", value: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } }, { key: "normalize", value: function () { return this.divideScalar(this.length() || 1) } }, { key: "setLength", value: function (e) { return this.normalize().multiplyScalar(e) } }, { key: "lerp", value: function (e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } }, { key: "lerpVectors", value: function (e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this } }, { key: "equals", value: function (e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } }, { key: "fromArray", value: function (e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } }, { key: "toArray", value: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } }, { key: "fromBufferAttribute", value: function (e, t, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } }, { key: "random", value: function () { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } }, { key: "width", get: function () { return this.z }, set: function (e) { this.z = e } }, { key: "height", get: function () { return this.w }, set: function (e) { this.w = e } }]), e }(); function Pr(e, t, n) { this.width = e, this.height = t, this.scissor = new Cr(0, 0, e, t), this.scissorTest = !1, this.viewport = new Cr(0, 0, e, t), n = n || {}, this.texture = new Lr(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Ft, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null } function Or(e, t, n) { Pr.call(this, e, t, n), this.samples = 4 } Pr.prototype = Object.assign(Object.create(xr.prototype), { constructor: Pr, isWebGLRenderTarget: !0, setSize: function (e, t) { this.width === e && this.height === t || (this.width = e, this.height = t, this.texture.image.width = e, this.texture.image.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Or.prototype = Object.assign(Object.create(Pr.prototype), { constructor: Or, isWebGLMultisampleRenderTarget: !0, copy: function (e) { return Pr.prototype.copy.call(this, e), this.samples = e.samples, this } }); var Ir = function () { function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1; _classCallCheck(this, e), Object.defineProperty(this, "isQuaternion", { value: !0 }), this._x = t, this._y = n, this._z = r, this._w = i } return _createClass(e, [{ key: "set", value: function (e, t, n, r) { return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this } }, { key: "clone", value: function () { return new this.constructor(this._x, this._y, this._z, this._w) } }, { key: "copy", value: function (e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } }, { key: "setFromEuler", value: function (e, t) { if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); var n = e._x, r = e._y, i = e._z, a = e._order, o = Math.cos, s = Math.sin, l = o(n / 2), c = o(r / 2), u = o(i / 2), h = s(n / 2), d = s(r / 2), p = s(i / 2); switch (a) { case "XYZ": this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p; break; case "YXZ": this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p; break; case "ZXY": this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p; break; case "ZYX": this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p; break; case "YZX": this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p; break; case "XZY": this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a) }return !1 !== t && this._onChangeCallback(), this } }, { key: "setFromAxisAngle", value: function (e, t) { var n = t / 2, r = Math.sin(n); return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this } }, { key: "setFromRotationMatrix", value: function (e) { var t = e.elements, n = t[0], r = t[4], i = t[8], a = t[1], o = t[5], s = t[9], l = t[2], c = t[6], u = t[10], h = n + o + u; if (h > 0) { var d = .5 / Math.sqrt(h + 1); this._w = .25 / d, this._x = (c - s) * d, this._y = (i - l) * d, this._z = (a - r) * d } else if (n > o && n > u) { var p = 2 * Math.sqrt(1 + n - o - u); this._w = (c - s) / p, this._x = .25 * p, this._y = (r + a) / p, this._z = (i + l) / p } else if (o > u) { var f = 2 * Math.sqrt(1 + o - n - u); this._w = (i - l) / f, this._x = (r + a) / f, this._y = .25 * f, this._z = (s + c) / f } else { var m = 2 * Math.sqrt(1 + u - n - o); this._w = (a - r) / m, this._x = (i + l) / m, this._y = (s + c) / m, this._z = .25 * m } return this._onChangeCallback(), this } }, { key: "setFromUnitVectors", value: function (e, t) { var n = e.dot(t) + 1; return n < 1e-6 ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize() } }, { key: "angleTo", value: function (e) { return 2 * Math.acos(Math.abs(Tr.clamp(this.dot(e), -1, 1))) } }, { key: "rotateTowards", value: function (e, t) { var n = this.angleTo(e); if (0 === n) return this; var r = Math.min(1, t / n); return this.slerp(e, r), this } }, { key: "identity", value: function () { return this.set(0, 0, 0, 1) } }, { key: "inverse", value: function () { return this.conjugate() } }, { key: "conjugate", value: function () { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } }, { key: "dot", value: function (e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } }, { key: "lengthSq", value: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } }, { key: "length", value: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } }, { key: "normalize", value: function () { var e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } }, { key: "multiply", value: function (e, t) { return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e) } }, { key: "premultiply", value: function (e) { return this.multiplyQuaternions(e, this) } }, { key: "multiplyQuaternions", value: function (e, t) { var n = e._x, r = e._y, i = e._z, a = e._w, o = t._x, s = t._y, l = t._z, c = t._w; return this._x = n * c + a * o + r * l - i * s, this._y = r * c + a * s + i * o - n * l, this._z = i * c + a * l + n * s - r * o, this._w = a * c - n * o - r * s - i * l, this._onChangeCallback(), this } }, { key: "slerp", value: function (e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); var n = this._x, r = this._y, i = this._z, a = this._w, o = a * e._w + n * e._x + r * e._y + i * e._z; if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = n, this._y = r, this._z = i, this; var s = 1 - o * o; if (s <= Number.EPSILON) { var l = 1 - t; return this._w = l * a + t * this._w, this._x = l * n + t * this._x, this._y = l * r + t * this._y, this._z = l * i + t * this._z, this.normalize(), this._onChangeCallback(), this } var c = Math.sqrt(s), u = Math.atan2(c, o), h = Math.sin((1 - t) * u) / c, d = Math.sin(t * u) / c; return this._w = a * h + this._w * d, this._x = n * h + this._x * d, this._y = r * h + this._y * d, this._z = i * h + this._z * d, this._onChangeCallback(), this } }, { key: "equals", value: function (e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } }, { key: "fromArray", value: function (e, t) { return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } }, { key: "toArray", value: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } }, { key: "fromBufferAttribute", value: function (e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } }, { key: "_onChange", value: function (e) { return this._onChangeCallback = e, this } }, { key: "_onChangeCallback", value: function () { } }, { key: "x", get: function () { return this._x }, set: function (e) { this._x = e, this._onChangeCallback() } }, { key: "y", get: function () { return this._y }, set: function (e) { this._y = e, this._onChangeCallback() } }, { key: "z", get: function () { return this._z }, set: function (e) { this._z = e, this._onChangeCallback() } }, { key: "w", get: function () { return this._w }, set: function (e) { this._w = e, this._onChangeCallback() } }], [{ key: "slerp", value: function (e, t, n, r) { return n.copy(e).slerp(t, r) } }, { key: "slerpFlat", value: function (e, t, n, r, i, a, o) { var s = n[r + 0], l = n[r + 1], c = n[r + 2], u = n[r + 3], h = i[a + 0], d = i[a + 1], p = i[a + 2], f = i[a + 3]; if (u !== f || s !== h || l !== d || c !== p) { var m = 1 - o, v = s * h + l * d + c * p + u * f, g = v >= 0 ? 1 : -1, y = 1 - v * v; if (y > Number.EPSILON) { var b = Math.sqrt(y), x = Math.atan2(b, v * g); m = Math.sin(m * x) / b, o = Math.sin(o * x) / b } var _ = o * g; if (s = s * m + h * _, l = l * m + d * _, c = c * m + p * _, u = u * m + f * _, m === 1 - o) { var w = 1 / Math.sqrt(s * s + l * l + c * c + u * u); s *= w, l *= w, c *= w, u *= w } } e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u } }, { key: "multiplyQuaternionsFlat", value: function (e, t, n, r, i, a) { var o = n[r], s = n[r + 1], l = n[r + 2], c = n[r + 3], u = i[a], h = i[a + 1], d = i[a + 2], p = i[a + 3]; return e[t] = o * p + c * u + s * d - l * h, e[t + 1] = s * p + c * h + l * u - o * d, e[t + 2] = l * p + c * d + o * h - s * u, e[t + 3] = c * p - o * u - s * h - l * d, e } }]), e }(), Nr = function () { function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; _classCallCheck(this, e), Object.defineProperty(this, "isVector3", { value: !0 }), this.x = t, this.y = n, this.z = r } return _createClass(e, [{ key: "set", value: function (e, t, n) { return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this } }, { key: "setScalar", value: function (e) { return this.x = e, this.y = e, this.z = e, this } }, { key: "setX", value: function (e) { return this.x = e, this } }, { key: "setY", value: function (e) { return this.y = e, this } }, { key: "setZ", value: function (e) { return this.z = e, this } }, { key: "setComponent", value: function (e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } }, { key: "getComponent", value: function (e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } }, { key: "clone", value: function () { return new this.constructor(this.x, this.y, this.z) } }, { key: "copy", value: function (e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } }, { key: "add", value: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this) } }, { key: "addScalar", value: function (e) { return this.x += e, this.y += e, this.z += e, this } }, { key: "addVectors", value: function (e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } }, { key: "addScaledVector", value: function (e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } }, { key: "sub", value: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this) } }, { key: "subScalar", value: function (e) { return this.x -= e, this.y -= e, this.z -= e, this } }, { key: "subVectors", value: function (e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } }, { key: "multiply", value: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this) } }, { key: "multiplyScalar", value: function (e) { return this.x *= e, this.y *= e, this.z *= e, this } }, { key: "multiplyVectors", value: function (e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } }, { key: "applyEuler", value: function (e) { return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Fr.setFromEuler(e)) } }, { key: "applyAxisAngle", value: function (e, t) { return this.applyQuaternion(Fr.setFromAxisAngle(e, t)) } }, { key: "applyMatrix3", value: function (e) { var t = this.x, n = this.y, r = this.z, i = e.elements; return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this } }, { key: "applyNormalMatrix", value: function (e) { return this.applyMatrix3(e).normalize() } }, { key: "applyMatrix4", value: function (e) { var t = this.x, n = this.y, r = this.z, i = e.elements, a = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]); return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * a, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * a, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * a, this } }, { key: "applyQuaternion", value: function (e) { var t = this.x, n = this.y, r = this.z, i = e.x, a = e.y, o = e.z, s = e.w, l = s * t + a * r - o * n, c = s * n + o * t - i * r, u = s * r + i * n - a * t, h = -i * t - a * n - o * r; return this.x = l * s + h * -i + c * -o - u * -a, this.y = c * s + h * -a + u * -i - l * -o, this.z = u * s + h * -o + l * -a - c * -i, this } }, { key: "project", value: function (e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } }, { key: "unproject", value: function (e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } }, { key: "transformDirection", value: function (e) { var t = this.x, n = this.y, r = this.z, i = e.elements; return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize() } }, { key: "divide", value: function (e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } }, { key: "divideScalar", value: function (e) { return this.multiplyScalar(1 / e) } }, { key: "min", value: function (e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } }, { key: "max", value: function (e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } }, { key: "clamp", value: function (e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } }, { key: "clampScalar", value: function (e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } }, { key: "clampLength", value: function (e, t) { var n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } }, { key: "floor", value: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } }, { key: "ceil", value: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } }, { key: "round", value: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } }, { key: "roundToZero", value: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } }, { key: "negate", value: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } }, { key: "dot", value: function (e) { return this.x * e.x + this.y * e.y + this.z * e.z } }, { key: "lengthSq", value: function () { return this.x * this.x + this.y * this.y + this.z * this.z } }, { key: "length", value: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } }, { key: "manhattanLength", value: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } }, { key: "normalize", value: function () { return this.divideScalar(this.length() || 1) } }, { key: "setLength", value: function (e) { return this.normalize().multiplyScalar(e) } }, { key: "lerp", value: function (e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } }, { key: "lerpVectors", value: function (e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this } }, { key: "cross", value: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e) } }, { key: "crossVectors", value: function (e, t) { var n = e.x, r = e.y, i = e.z, a = t.x, o = t.y, s = t.z; return this.x = r * s - i * o, this.y = i * a - n * s, this.z = n * o - r * a, this } }, { key: "projectOnVector", value: function (e) { var t = e.lengthSq(); if (0 === t) return this.set(0, 0, 0); var n = e.dot(this) / t; return this.copy(e).multiplyScalar(n) } }, { key: "projectOnPlane", value: function (e) { return Dr.copy(this).projectOnVector(e), this.sub(Dr) } }, { key: "reflect", value: function (e) { return this.sub(Dr.copy(e).multiplyScalar(2 * this.dot(e))) } }, { key: "angleTo", value: function (e) { var t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; var n = this.dot(e) / t; return Math.acos(Tr.clamp(n, -1, 1)) } }, { key: "distanceTo", value: function (e) { return Math.sqrt(this.distanceToSquared(e)) } }, { key: "distanceToSquared", value: function (e) { var t = this.x - e.x, n = this.y - e.y, r = this.z - e.z; return t * t + n * n + r * r } }, { key: "manhattanDistanceTo", value: function (e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } }, { key: "setFromSpherical", value: function (e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } }, { key: "setFromSphericalCoords", value: function (e, t, n) { var r = Math.sin(t) * e; return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this } }, { key: "setFromCylindrical", value: function (e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } }, { key: "setFromCylindricalCoords", value: function (e, t, n) { return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this } }, { key: "setFromMatrixPosition", value: function (e) { var t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } }, { key: "setFromMatrixScale", value: function (e) { var t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = n, this.z = r, this } }, { key: "setFromMatrixColumn", value: function (e, t) { return this.fromArray(e.elements, 4 * t) } }, { key: "setFromMatrix3Column", value: function (e, t) { return this.fromArray(e.elements, 3 * t) } }, { key: "equals", value: function (e) { return e.x === this.x && e.y === this.y && e.z === this.z } }, { key: "fromArray", value: function (e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } }, { key: "toArray", value: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } }, { key: "fromBufferAttribute", value: function (e, t, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } }, { key: "random", value: function () { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } }]), e }(), Dr = new Nr, Fr = new Ir, Ur = function () { function e(t, n) { _classCallCheck(this, e), Object.defineProperty(this, "isBox3", { value: !0 }), this.min = void 0 !== t ? t : new Nr(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== n ? n : new Nr(-1 / 0, -1 / 0, -1 / 0) } return _createClass(e, [{ key: "set", value: function (e, t) { return this.min.copy(e), this.max.copy(t), this } }, { key: "setFromArray", value: function (e) { for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.length; s < l; s += 3) { var c = e[s], u = e[s + 1], h = e[s + 2]; c < t && (t = c), u < n && (n = u), h < r && (r = h), c > i && (i = c), u > a && (a = u), h > o && (o = h) } return this.min.set(t, n, r), this.max.set(i, a, o), this } }, { key: "setFromBufferAttribute", value: function (e) { for (var t = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.count; s < l; s++) { var c = e.getX(s), u = e.getY(s), h = e.getZ(s); c < t && (t = c), u < n && (n = u), h < r && (r = h), c > i && (i = c), u > a && (a = u), h > o && (o = h) } return this.min.set(t, n, r), this.max.set(i, a, o), this } }, { key: "setFromPoints", value: function (e) { this.makeEmpty(); for (var t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } }, { key: "setFromCenterAndSize", value: function (e, t) { var n = Hr.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } }, { key: "setFromObject", value: function (e) { return this.makeEmpty(), this.expandByObject(e) } }, { key: "clone", value: function () { return (new this.constructor).copy(this) } }, { key: "copy", value: function (e) { return this.min.copy(e.min), this.max.copy(e.max), this } }, { key: "makeEmpty", value: function () { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } }, { key: "isEmpty", value: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } }, { key: "getCenter", value: function (e) { return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new Nr), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } }, { key: "getSize", value: function (e) { return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new Nr), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } }, { key: "expandByPoint", value: function (e) { return this.min.min(e), this.max.max(e), this } }, { key: "expandByVector", value: function (e) { return this.min.sub(e), this.max.add(e), this } }, { key: "expandByScalar", value: function (e) { return this.min.addScalar(-e), this.max.addScalar(e), this } }, { key: "expandByObject", value: function (e) { e.updateWorldMatrix(!1, !1); var t = e.geometry; void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), Gr.copy(t.boundingBox), Gr.applyMatrix4(e.matrixWorld), this.union(Gr)); for (var n = e.children, r = 0, i = n.length; r < i; r++)this.expandByObject(n[r]); return this } }, { key: "containsPoint", value: function (e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } }, { key: "containsBox", value: function (e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } }, { key: "getParameter", value: function (e, t) { return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new Nr), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } }, { key: "intersectsBox", value: function (e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } }, { key: "intersectsSphere", value: function (e) { return this.clampPoint(e.center, Hr), Hr.distanceToSquared(e.center) <= e.radius * e.radius } }, { key: "intersectsPlane", value: function (e) { var t, n; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant } }, { key: "intersectsTriangle", value: function (e) { if (this.isEmpty()) return !1; this.getCenter(Jr), Zr.subVectors(this.max, Jr), Vr.subVectors(e.a, Jr), jr.subVectors(e.b, Jr), Wr.subVectors(e.c, Jr), qr.subVectors(jr, Vr), Xr.subVectors(Wr, jr), Yr.subVectors(Vr, Wr); var t = [0, -qr.z, qr.y, 0, -Xr.z, Xr.y, 0, -Yr.z, Yr.y, qr.z, 0, -qr.x, Xr.z, 0, -Xr.x, Yr.z, 0, -Yr.x, -qr.y, qr.x, 0, -Xr.y, Xr.x, 0, -Yr.y, Yr.x, 0]; return !!zr(t, Vr, jr, Wr, Zr) && (!!zr(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], Vr, jr, Wr, Zr) && (Kr.crossVectors(qr, Xr), zr(t = [Kr.x, Kr.y, Kr.z], Vr, jr, Wr, Zr))) } }, { key: "clampPoint", value: function (e, t) { return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new Nr), t.copy(e).clamp(this.min, this.max) } }, { key: "distanceToPoint", value: function (e) { return Hr.copy(e).clamp(this.min, this.max).sub(e).length() } }, { key: "getBoundingSphere", value: function (e) { return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(Hr).length(), e } }, { key: "intersect", value: function (e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } }, { key: "union", value: function (e) { return this.min.min(e.min), this.max.max(e.max), this } }, { key: "applyMatrix4", value: function (e) { return this.isEmpty() ? this : (Br[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Br[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Br[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Br[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Br[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Br[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Br[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Br[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Br), this) } }, { key: "translate", value: function (e) { return this.min.add(e), this.max.add(e), this } }, { key: "equals", value: function (e) { return e.min.equals(this.min) && e.max.equals(this.max) } }]), e }(); function zr(e, t, n, r, i) { for (var a = 0, o = e.length - 3; a <= o; a += 3) { Qr.fromArray(e, a); var s = i.x * Math.abs(Qr.x) + i.y * Math.abs(Qr.y) + i.z * Math.abs(Qr.z), l = t.dot(Qr), c = n.dot(Qr), u = r.dot(Qr); if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > s) return !1 } return !0 } var Br = [new Nr, new Nr, new Nr, new Nr, new Nr, new Nr, new Nr, new Nr], Hr = new Nr, Gr = new Ur, Vr = new Nr, jr = new Nr, Wr = new Nr, qr = new Nr, Xr = new Nr, Yr = new Nr, Jr = new Nr, Zr = new Nr, Kr = new Nr, Qr = new Nr, $r = new Ur, ei = function () { function e(t, n) { _classCallCheck(this, e), this.center = void 0 !== t ? t : new Nr, this.radius = void 0 !== n ? n : -1 } return _createClass(e, [{ key: "set", value: function (e, t) { return this.center.copy(e), this.radius = t, this } }, { key: "setFromPoints", value: function (e, t) { var n = this.center; void 0 !== t ? n.copy(t) : $r.setFromPoints(e).getCenter(n); for (var r = 0, i = 0, a = e.length; i < a; i++)r = Math.max(r, n.distanceToSquared(e[i])); return this.radius = Math.sqrt(r), this } }, { key: "clone", value: function () { return (new this.constructor).copy(this) } }, { key: "copy", value: function (e) { return this.center.copy(e.center), this.radius = e.radius, this } }, { key: "isEmpty", value: function () { return this.radius < 0 } }, { key: "makeEmpty", value: function () { return this.center.set(0, 0, 0), this.radius = -1, this } }, { key: "containsPoint", value: function (e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } }, { key: "distanceToPoint", value: function (e) { return e.distanceTo(this.center) - this.radius } }, { key: "intersectsSphere", value: function (e) { var t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } }, { key: "intersectsBox", value: function (e) { return e.intersectsSphere(this) } }, { key: "intersectsPlane", value: function (e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } }, { key: "clampPoint", value: function (e, t) { var n = this.center.distanceToSquared(e); return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new Nr), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } }, { key: "getBoundingBox", value: function (e) { return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new Ur), this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } }, { key: "applyMatrix4", value: function (e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } }, { key: "translate", value: function (e) { return this.center.add(e), this } }, { key: "equals", value: function (e) { return e.center.equals(this.center) && e.radius === this.radius } }]), e }(), ti = new Nr, ni = new Nr, ri = new Nr, ii = new Nr, ai = new Nr, oi = new Nr, si = new Nr, li = function () { function e(t, n) { _classCallCheck(this, e), this.origin = void 0 !== t ? t : new Nr, this.direction = void 0 !== n ? n : new Nr(0, 0, -1) } return _createClass(e, [{ key: "set", value: function (e, t) { return this.origin.copy(e), this.direction.copy(t), this } }, { key: "clone", value: function () { return (new this.constructor).copy(this) } }, { key: "copy", value: function (e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } }, { key: "at", value: function (e, t) { return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new Nr), t.copy(this.direction).multiplyScalar(e).add(this.origin) } }, { key: "lookAt", value: function (e) { return this.direction.copy(e).sub(this.origin).normalize(), this } }, { key: "recast", value: function (e) { return this.origin.copy(this.at(e, ti)), this } }, { key: "closestPointToPoint", value: function (e, t) { void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new Nr), t.subVectors(e, this.origin); var n = t.dot(this.direction); return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin) } }, { key: "distanceToPoint", value: function (e) { return Math.sqrt(this.distanceSqToPoint(e)) } }, { key: "distanceSqToPoint", value: function (e) { var t = ti.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (ti.copy(this.direction).multiplyScalar(t).add(this.origin), ti.distanceToSquared(e)) } }, { key: "distanceSqToSegment", value: function (e, t, n, r) { ni.copy(e).add(t).multiplyScalar(.5), ri.copy(t).sub(e).normalize(), ii.copy(this.origin).sub(ni); var i, a, o, s, l = .5 * e.distanceTo(t), c = -this.direction.dot(ri), u = ii.dot(this.direction), h = -ii.dot(ri), d = ii.lengthSq(), p = Math.abs(1 - c * c); if (p > 0) if (a = c * u - h, s = l * p, (i = c * h - u) >= 0) if (a >= -s) if (a <= s) { var f = 1 / p; o = (i *= f) * (i + c * (a *= f) + 2 * u) + a * (c * i + a + 2 * h) + d } else a = l, o = -(i = Math.max(0, -(c * a + u))) * i + a * (a + 2 * h) + d; else a = -l, o = -(i = Math.max(0, -(c * a + u))) * i + a * (a + 2 * h) + d; else a <= -s ? o = -(i = Math.max(0, -(-c * l + u))) * i + (a = i > 0 ? -l : Math.min(Math.max(-l, -h), l)) * (a + 2 * h) + d : a <= s ? (i = 0, o = (a = Math.min(Math.max(-l, -h), l)) * (a + 2 * h) + d) : o = -(i = Math.max(0, -(c * l + u))) * i + (a = i > 0 ? l : Math.min(Math.max(-l, -h), l)) * (a + 2 * h) + d; else a = c > 0 ? -l : l, o = -(i = Math.max(0, -(c * a + u))) * i + a * (a + 2 * h) + d; return n && n.copy(this.direction).multiplyScalar(i).add(this.origin), r && r.copy(ri).multiplyScalar(a).add(ni), o } }, { key: "intersectSphere", value: function (e, t) { ti.subVectors(e.center, this.origin); var n = ti.dot(this.direction), r = ti.dot(ti) - n * n, i = e.radius * e.radius; if (r > i) return null; var a = Math.sqrt(i - r), o = n - a, s = n + a; return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t) } }, { key: "intersectsSphere", value: function (e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } }, { key: "distanceToPlane", value: function (e) { var t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; var n = -(this.origin.dot(e.normal) + e.constant) / t; return n >= 0 ? n : null } }, { key: "intersectPlane", value: function (e, t) { var n = this.distanceToPlane(e); return null === n ? null : this.at(n, t) } }, { key: "intersectsPlane", value: function (e) { var t = e.distanceToPoint(this.origin); return 0 === t || e.normal.dot(this.direction) * t < 0 } }, { key: "intersectBox", value: function (e, t) { var n, r, i, a, o, s, l = 1 / this.direction.x, c = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin; return l >= 0 ? (n = (e.min.x - h.x) * l, r = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, r = (e.min.x - h.x) * l), c >= 0 ? (i = (e.min.y - h.y) * c, a = (e.max.y - h.y) * c) : (i = (e.max.y - h.y) * c, a = (e.min.y - h.y) * c), n > a || i > r ? null : ((i > n || n != n) && (n = i), (a < r || r != r) && (r = a), u >= 0 ? (o = (e.min.z - h.z) * u, s = (e.max.z - h.z) * u) : (o = (e.max.z - h.z) * u, s = (e.min.z - h.z) * u), n > s || o > r ? null : ((o > n || n != n) && (n = o), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, t))) } }, { key: "intersectsBox", value: function (e) { return null !== this.intersectBox(e, ti) } }, { key: "intersectTriangle", value: function (e, t, n, r, i) { ai.subVectors(t, e), oi.subVectors(n, e), si.crossVectors(ai, oi); var a, o = this.direction.dot(si); if (o > 0) { if (r) return null; a = 1 } else { if (!(o < 0)) return null; a = -1, o = -o } ii.subVectors(this.origin, e); var s = a * this.direction.dot(oi.crossVectors(ii, oi)); if (s < 0) return null; var l = a * this.direction.dot(ai.cross(ii)); if (l < 0) return null; if (s + l > o) return null; var c = -a * ii.dot(si); return c < 0 ? null : this.at(c / o, i) } }, { key: "applyMatrix4", value: function (e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } }, { key: "equals", value: function (e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } }]), e }(), ci = function () { function e() { _classCallCheck(this, e), Object.defineProperty(this, "isMatrix4", { value: !0 }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } return _createClass(e, [{ key: "set", value: function (e, t, n, r, i, a, o, s, l, c, u, h, d, p, f, m) { var v = this.elements; return v[0] = e, v[4] = t, v[8] = n, v[12] = r, v[1] = i, v[5] = a, v[9] = o, v[13] = s, v[2] = l, v[6] = c, v[10] = u, v[14] = h, v[3] = d, v[7] = p, v[11] = f, v[15] = m, this } }, { key: "identity", value: function () { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } }, { key: "clone", value: function () { return (new e).fromArray(this.elements) } }, { key: "copy", value: function (e) { var t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this } }, { key: "copyPosition", value: function (e) { var t = this.elements, n = e.elements; return t[12] = n[12], t[13] = n[13], t[14] = n[14], this } }, { key: "extractBasis", value: function (e, t, n) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } }, { key: "makeBasis", value: function (e, t, n) { return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this } }, { key: "extractRotation", value: function (e) { var t = this.elements, n = e.elements, r = 1 / ui.setFromMatrixColumn(e, 0).length(), i = 1 / ui.setFromMatrixColumn(e, 1).length(), a = 1 / ui.setFromMatrixColumn(e, 2).length(); return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } }, { key: "makeRotationFromEuler", value: function (e) { e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var t = this.elements, n = e.x, r = e.y, i = e.z, a = Math.cos(n), o = Math.sin(n), s = Math.cos(r), l = Math.sin(r), c = Math.cos(i), u = Math.sin(i); if ("XYZ" === e.order) { var h = a * c, d = a * u, p = o * c, f = o * u; t[0] = s * c, t[4] = -s * u, t[8] = l, t[1] = d + p * l, t[5] = h - f * l, t[9] = -o * s, t[2] = f - h * l, t[6] = p + d * l, t[10] = a * s } else if ("YXZ" === e.order) { var m = s * c, v = s * u, g = l * c, y = l * u; t[0] = m + y * o, t[4] = g * o - v, t[8] = a * l, t[1] = a * u, t[5] = a * c, t[9] = -o, t[2] = v * o - g, t[6] = y + m * o, t[10] = a * s } else if ("ZXY" === e.order) { var b = s * c, x = s * u, _ = l * c, w = l * u; t[0] = b - w * o, t[4] = -a * u, t[8] = _ + x * o, t[1] = x + _ * o, t[5] = a * c, t[9] = w - b * o, t[2] = -a * l, t[6] = o, t[10] = a * s } else if ("ZYX" === e.order) { var M = a * c, S = a * u, T = o * c, E = o * u; t[0] = s * c, t[4] = T * l - S, t[8] = M * l + E, t[1] = s * u, t[5] = E * l + M, t[9] = S * l - T, t[2] = -l, t[6] = o * s, t[10] = a * s } else if ("YZX" === e.order) { var A = a * s, R = a * l, k = o * s, L = o * l; t[0] = s * c, t[4] = L - A * u, t[8] = k * u + R, t[1] = u, t[5] = a * c, t[9] = -o * c, t[2] = -l * c, t[6] = R * u + k, t[10] = A - L * u } else if ("XZY" === e.order) { var C = a * s, P = a * l, O = o * s, I = o * l; t[0] = s * c, t[4] = -u, t[8] = l * c, t[1] = C * u + I, t[5] = a * c, t[9] = P * u - O, t[2] = O * u - P, t[6] = o * c, t[10] = I * u + C } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } }, { key: "makeRotationFromQuaternion", value: function (e) { return this.compose(di, e, pi) } }, { key: "lookAt", value: function (e, t, n) { var r = this.elements; return vi.subVectors(e, t), 0 === vi.lengthSq() && (vi.z = 1), vi.normalize(), fi.crossVectors(n, vi), 0 === fi.lengthSq() && (1 === Math.abs(n.z) ? vi.x += 1e-4 : vi.z += 1e-4, vi.normalize(), fi.crossVectors(n, vi)), fi.normalize(), mi.crossVectors(vi, fi), r[0] = fi.x, r[4] = mi.x, r[8] = vi.x, r[1] = fi.y, r[5] = mi.y, r[9] = vi.y, r[2] = fi.z, r[6] = mi.z, r[10] = vi.z, this } }, { key: "multiply", value: function (e, t) { return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e) } }, { key: "premultiply", value: function (e) { return this.multiplyMatrices(e, this) } }, { key: "multiplyMatrices", value: function (e, t) { var n = e.elements, r = t.elements, i = this.elements, a = n[0], o = n[4], s = n[8], l = n[12], c = n[1], u = n[5], h = n[9], d = n[13], p = n[2], f = n[6], m = n[10], v = n[14], g = n[3], y = n[7], b = n[11], x = n[15], _ = r[0], w = r[4], M = r[8], S = r[12], T = r[1], E = r[5], A = r[9], R = r[13], k = r[2], L = r[6], C = r[10], P = r[14], O = r[3], I = r[7], N = r[11], D = r[15]; return i[0] = a * _ + o * T + s * k + l * O, i[4] = a * w + o * E + s * L + l * I, i[8] = a * M + o * A + s * C + l * N, i[12] = a * S + o * R + s * P + l * D, i[1] = c * _ + u * T + h * k + d * O, i[5] = c * w + u * E + h * L + d * I, i[9] = c * M + u * A + h * C + d * N, i[13] = c * S + u * R + h * P + d * D, i[2] = p * _ + f * T + m * k + v * O, i[6] = p * w + f * E + m * L + v * I, i[10] = p * M + f * A + m * C + v * N, i[14] = p * S + f * R + m * P + v * D, i[3] = g * _ + y * T + b * k + x * O, i[7] = g * w + y * E + b * L + x * I, i[11] = g * M + y * A + b * C + x * N, i[15] = g * S + y * R + b * P + x * D, this } }, { key: "multiplyScalar", value: function (e) { var t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } }, { key: "determinant", value: function () { var e = this.elements, t = e[0], n = e[4], r = e[8], i = e[12], a = e[1], o = e[5], s = e[9], l = e[13], c = e[2], u = e[6], h = e[10], d = e[14]; return e[3] * (+i * s * u - r * l * u - i * o * h + n * l * h + r * o * d - n * s * d) + e[7] * (+t * s * d - t * l * h + i * a * h - r * a * d + r * l * c - i * s * c) + e[11] * (+t * l * u - t * o * d - i * a * u + n * a * d + i * o * c - n * l * c) + e[15] * (-r * o * c - t * s * u + t * o * h + r * a * u - n * a * h + n * s * c) } }, { key: "transpose", value: function () { var e, t = this.elements; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this } }, { key: "setPosition", value: function (e, t, n) { var r = this.elements; return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this } }, { key: "getInverse", value: function (e, t) { void 0 !== t && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate."); var n = this.elements, r = e.elements, i = r[0], a = r[1], o = r[2], s = r[3], l = r[4], c = r[5], u = r[6], h = r[7], d = r[8], p = r[9], f = r[10], m = r[11], v = r[12], g = r[13], y = r[14], b = r[15], x = p * y * h - g * f * h + g * u * m - c * y * m - p * u * b + c * f * b, _ = v * f * h - d * y * h - v * u * m + l * y * m + d * u * b - l * f * b, w = d * g * h - v * p * h + v * c * m - l * g * m - d * c * b + l * p * b, M = v * p * u - d * g * u - v * c * f + l * g * f + d * c * y - l * p * y, S = i * x + a * _ + o * w + s * M; if (0 === S) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); var T = 1 / S; return n[0] = x * T, n[1] = (g * f * s - p * y * s - g * o * m + a * y * m + p * o * b - a * f * b) * T, n[2] = (c * y * s - g * u * s + g * o * h - a * y * h - c * o * b + a * u * b) * T, n[3] = (p * u * s - c * f * s - p * o * h + a * f * h + c * o * m - a * u * m) * T, n[4] = _ * T, n[5] = (d * y * s - v * f * s + v * o * m - i * y * m - d * o * b + i * f * b) * T, n[6] = (v * u * s - l * y * s - v * o * h + i * y * h + l * o * b - i * u * b) * T, n[7] = (l * f * s - d * u * s + d * o * h - i * f * h - l * o * m + i * u * m) * T, n[8] = w * T, n[9] = (v * p * s - d * g * s - v * a * m + i * g * m + d * a * b - i * p * b) * T, n[10] = (l * g * s - v * c * s + v * a * h - i * g * h - l * a * b + i * c * b) * T, n[11] = (d * c * s - l * p * s - d * a * h + i * p * h + l * a * m - i * c * m) * T, n[12] = M * T, n[13] = (d * g * o - v * p * o + v * a * f - i * g * f - d * a * y + i * p * y) * T, n[14] = (v * c * o - l * g * o - v * a * u + i * g * u + l * a * y - i * c * y) * T, n[15] = (l * p * o - d * c * o + d * a * u - i * p * u - l * a * f + i * c * f) * T, this } }, { key: "scale", value: function (e) { var t = this.elements, n = e.x, r = e.y, i = e.z; return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this } }, { key: "getMaxScaleOnAxis", value: function () { var e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, n, r)) } }, { key: "makeTranslation", value: function (e, t, n) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this } }, { key: "makeRotationX", value: function (e) { var t = Math.cos(e), n = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this } }, { key: "makeRotationY", value: function (e) { var t = Math.cos(e), n = Math.sin(e); return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this } }, { key: "makeRotationZ", value: function (e) { var t = Math.cos(e), n = Math.sin(e); return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } }, { key: "makeRotationAxis", value: function (e, t) { var n = Math.cos(t), r = Math.sin(t), i = 1 - n, a = e.x, o = e.y, s = e.z, l = i * a, c = i * o; return this.set(l * a + n, l * o - r * s, l * s + r * o, 0, l * o + r * s, c * o + n, c * s - r * a, 0, l * s - r * o, c * s + r * a, i * s * s + n, 0, 0, 0, 0, 1), this } }, { key: "makeScale", value: function (e, t, n) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } }, { key: "makeShear", value: function (e, t, n) { return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this } }, { key: "compose", value: function (e, t, n) { var r = this.elements, i = t._x, a = t._y, o = t._z, s = t._w, l = i + i, c = a + a, u = o + o, h = i * l, d = i * c, p = i * u, f = a * c, m = a * u, v = o * u, g = s * l, y = s * c, b = s * u, x = n.x, _ = n.y, w = n.z; return r[0] = (1 - (f + v)) * x, r[1] = (d + b) * x, r[2] = (p - y) * x, r[3] = 0, r[4] = (d - b) * _, r[5] = (1 - (h + v)) * _, r[6] = (m + g) * _, r[7] = 0, r[8] = (p + y) * w, r[9] = (m - g) * w, r[10] = (1 - (h + f)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this } }, { key: "decompose", value: function (e, t, n) { var r = this.elements, i = ui.set(r[0], r[1], r[2]).length(), a = ui.set(r[4], r[5], r[6]).length(), o = ui.set(r[8], r[9], r[10]).length(); this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], hi.copy(this); var s = 1 / i, l = 1 / a, c = 1 / o; return hi.elements[0] *= s, hi.elements[1] *= s, hi.elements[2] *= s, hi.elements[4] *= l, hi.elements[5] *= l, hi.elements[6] *= l, hi.elements[8] *= c, hi.elements[9] *= c, hi.elements[10] *= c, t.setFromRotationMatrix(hi), n.x = i, n.y = a, n.z = o, this } }, { key: "makePerspective", value: function (e, t, n, r, i, a) { void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); var o = this.elements, s = 2 * i / (t - e), l = 2 * i / (n - r), c = (t + e) / (t - e), u = (n + r) / (n - r), h = -(a + i) / (a - i), d = -2 * a * i / (a - i); return o[0] = s, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this } }, { key: "makeOrthographic", value: function (e, t, n, r, i, a) { var o = this.elements, s = 1 / (t - e), l = 1 / (n - r), c = 1 / (a - i), u = (t + e) * s, h = (n + r) * l, d = (a + i) * c; return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this } }, { key: "equals", value: function (e) { for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)if (t[r] !== n[r]) return !1; return !0 } }, { key: "fromArray", value: function (e, t) { void 0 === t && (t = 0); for (var n = 0; n < 16; n++)this.elements[n] = e[n + t]; return this } }, { key: "toArray", value: function (e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); var n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e } }]), e }(), ui = new Nr, hi = new ci, di = new Nr(0, 0, 0), pi = new Nr(1, 1, 1), fi = new Nr, mi = new Nr, vi = new Nr, gi = function () { function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.DefaultOrder; _classCallCheck(this, e), Object.defineProperty(this, "isEuler", { value: !0 }), this._x = t, this._y = n, this._z = r, this._order = i } return _createClass(e, [{ key: "set", value: function (e, t, n, r) { return this._x = e, this._y = t, this._z = n, this._order = r || this._order, this._onChangeCallback(), this } }, { key: "clone", value: function () { return new this.constructor(this._x, this._y, this._z, this._order) } }, { key: "copy", value: function (e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } }, { key: "setFromRotationMatrix", value: function (e, t, n) { var r = Tr.clamp, i = e.elements, a = i[0], o = i[4], s = i[8], l = i[1], c = i[5], u = i[9], h = i[2], d = i[6], p = i[10]; switch (t = t || this._order) { case "XYZ": this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, c), this._z = 0); break; case "YXZ": this._x = Math.asin(-r(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, a), this._z = 0); break; case "ZXY": this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, a)); break; case "ZYX": this._y = Math.asin(-r(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-o, c)); break; case "YZX": this._z = Math.asin(r(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(s, p)); break; case "XZY": this._z = Math.asin(-r(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-u, p), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, !1 !== n && this._onChangeCallback(), this } }, { key: "setFromQuaternion", value: function (e, t, n) { return yi.makeRotationFromQuaternion(e), this.setFromRotationMatrix(yi, t, n) } }, { key: "setFromVector3", value: function (e, t) { return this.set(e.x, e.y, e.z, t || this._order) } }, { key: "reorder", value: function (e) { return bi.setFromEuler(this), this.setFromQuaternion(bi, e) } }, { key: "equals", value: function (e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } }, { key: "fromArray", value: function (e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this } }, { key: "toArray", value: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } }, { key: "toVector3", value: function (e) { return e ? e.set(this._x, this._y, this._z) : new Nr(this._x, this._y, this._z) } }, { key: "_onChange", value: function (e) { return this._onChangeCallback = e, this } }, { key: "_onChangeCallback", value: function () { } }, { key: "x", get: function () { return this._x }, set: function (e) { this._x = e, this._onChangeCallback() } }, { key: "y", get: function () { return this._y }, set: function (e) { this._y = e, this._onChangeCallback() } }, { key: "z", get: function () { return this._z }, set: function (e) { this._z = e, this._onChangeCallback() } }, { key: "order", get: function () { return this._order }, set: function (e) { this._order = e, this._onChangeCallback() } }]), e }(); gi.DefaultOrder = "XYZ", gi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; var yi = new ci, bi = new Ir, xi = function () { function e() { _classCallCheck(this, e), this.mask = 1 } return _createClass(e, [{ key: "set", value: function (e) { this.mask = 1 << e | 0 } }, { key: "enable", value: function (e) { this.mask |= 1 << e | 0 } }, { key: "enableAll", value: function () { this.mask = -1 } }, { key: "toggle", value: function (e) { this.mask ^= 1 << e | 0 } }, { key: "disable", value: function (e) { this.mask &= ~(1 << e | 0) } }, { key: "disableAll", value: function () { this.mask = 0 } }, { key: "test", value: function (e) { return 0 != (this.mask & e.mask) } }]), e }(), _i = 0, wi = new Nr, Mi = new Ir, Si = new ci, Ti = new Nr, Ei = new Nr, Ai = new Nr, Ri = new Ir, ki = new Nr(1, 0, 0), Li = new Nr(0, 1, 0), Ci = new Nr(0, 0, 1), Pi = { type: "added" }, Oi = { type: "removed" }; function Ii() { Object.defineProperty(this, "id", { value: _i++ }), this.uuid = Tr.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ii.DefaultUp.clone(); var e = new Nr, t = new gi, n = new Ir, r = new Nr(1, 1, 1); t._onChange(function () { n.setFromEuler(t, !1) }), n._onChange(function () { t.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new ci }, normalMatrix: { value: new Ar } }), this.matrix = new ci, this.matrixWorld = new ci, this.matrixAutoUpdate = Ii.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new xi, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} } Ii.DefaultUp = new Nr(0, 1, 0), Ii.DefaultMatrixAutoUpdate = !0, Ii.prototype = Object.assign(Object.create(xr.prototype), { constructor: Ii, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix4: function (e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (e) { return this.quaternion.premultiply(e), this }, setRotationFromAxisAngle: function (e, t) { this.quaternion.setFromAxisAngle(e, t) }, setRotationFromEuler: function (e) { this.quaternion.setFromEuler(e, !0) }, setRotationFromMatrix: function (e) { this.quaternion.setFromRotationMatrix(e) }, setRotationFromQuaternion: function (e) { this.quaternion.copy(e) }, rotateOnAxis: function (e, t) { return Mi.setFromAxisAngle(e, t), this.quaternion.multiply(Mi), this }, rotateOnWorldAxis: function (e, t) { return Mi.setFromAxisAngle(e, t), this.quaternion.premultiply(Mi), this }, rotateX: function (e) { return this.rotateOnAxis(ki, e) }, rotateY: function (e) { return this.rotateOnAxis(Li, e) }, rotateZ: function (e) { return this.rotateOnAxis(Ci, e) }, translateOnAxis: function (e, t) { return wi.copy(e).applyQuaternion(this.quaternion), this.position.add(wi.multiplyScalar(t)), this }, translateX: function (e) { return this.translateOnAxis(ki, e) }, translateY: function (e) { return this.translateOnAxis(Li, e) }, translateZ: function (e) { return this.translateOnAxis(Ci, e) }, localToWorld: function (e) { return e.applyMatrix4(this.matrixWorld) }, worldToLocal: function (e) { return e.applyMatrix4(Si.getInverse(this.matrixWorld)) }, lookAt: function (e, t, n) { e.isVector3 ? Ti.copy(e) : Ti.set(e, t, n); var r = this.parent; this.updateWorldMatrix(!0, !1), Ei.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Si.lookAt(Ei, Ti, this.up) : Si.lookAt(Ti, Ei, this.up), this.quaternion.setFromRotationMatrix(Si), r && (Si.extractRotation(r.matrixWorld), Mi.setFromRotationMatrix(Si), this.quaternion.premultiply(Mi.inverse())) }, add: function (e) { if (arguments.length > 1) { for (var t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Pi)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) }, remove: function (e) { if (arguments.length > 1) { for (var t = 0; t < arguments.length; t++)this.remove(arguments[t]); return this } var n = this.children.indexOf(e); return -1 !== n && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(Oi)), this }, attach: function (e) { return this.updateWorldMatrix(!0, !1), Si.getInverse(this.matrixWorld), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Si.multiply(e.parent.matrixWorld)), e.applyMatrix4(Si), e.updateWorldMatrix(!1, !1), this.add(e), this }, getObjectById: function (e) { return this.getObjectByProperty("id", e) }, getObjectByName: function (e) { return this.getObjectByProperty("name", e) }, getObjectByProperty: function (e, t) { if (this[e] === t) return this; for (var n = 0, r = this.children.length; n < r; n++) { var i = this.children[n].getObjectByProperty(e, t); if (void 0 !== i) return i } }, getWorldPosition: function (e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new Nr), this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: function (e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new Ir), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ei, e, Ai), e }, getWorldScale: function (e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e = new Nr), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ei, Ri, e), e }, getWorldDirection: function (e) { void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new Nr), this.updateWorldMatrix(!0, !1); var t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() }, raycast: function () { }, traverse: function (e) { e(this); for (var t = this.children, n = 0, r = t.length; n < r; n++)t[n].traverse(e) }, traverseVisible: function (e) { if (!1 !== this.visible) { e(this); for (var t = this.children, n = 0, r = t.length; n < r; n++)t[n].traverseVisible(e) } }, traverseAncestors: function (e) { var t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); for (var t = this.children, n = 0, r = t.length; n < r; n++)t[n].updateMatrixWorld(e) }, updateWorldMatrix: function (e, t) { var n = this.parent; if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) for (var r = this.children, i = 0, a = r.length; i < a; i++)r[i].updateWorldMatrix(!1, !0) }, toJSON: function (e) { var t = void 0 === e || "string" == typeof e, n = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); var r = {}; function i(t, n) { return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid } if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) { r.geometry = i(e.geometries, this.geometry); var a = this.geometry.parameters; if (void 0 !== a && void 0 !== a.shapes) { var o = a.shapes; if (Array.isArray(o)) for (var s = 0, l = o.length; s < l; s++) { var c = o[s]; i(e.shapes, c) } else i(e.shapes, o) } } if (void 0 !== this.material) if (Array.isArray(this.material)) { for (var u = [], h = 0, d = this.material.length; h < d; h++)u.push(i(e.materials, this.material[h])); r.material = u } else r.material = i(e.materials, this.material); if (this.children.length > 0) { r.children = []; for (var p = 0; p < this.children.length; p++)r.children.push(this.children[p].toJSON(e).object) } if (t) { var f = b(e.geometries), m = b(e.materials), v = b(e.textures), g = b(e.images), y = b(e.shapes); f.length > 0 && (n.geometries = f), m.length > 0 && (n.materials = m), v.length > 0 && (n.textures = v), g.length > 0 && (n.images = g), y.length > 0 && (n.shapes = y) } return n.object = r, n; function b(e) { var t = []; for (var n in e) { var r = e[n]; delete r.metadata, t.push(r) } return t } }, clone: function (e) { return (new this.constructor).copy(this, e) }, copy: function (e, t) { if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (var n = 0; n < e.children.length; n++) { var r = e.children[n]; this.add(r.clone()) } return this } }); var Ni = new Nr, Di = new Nr, Fi = new Ar, Ui = function () { function e(t, n) { _classCallCheck(this, e), Object.defineProperty(this, "isPlane", { value: !0 }), this.normal = void 0 !== t ? t : new Nr(1, 0, 0), this.constant = void 0 !== n ? n : 0 } return _createClass(e, [{ key: "set", value: function (e, t) { return this.normal.copy(e), this.constant = t, this } }, { key: "setComponents", value: function (e, t, n, r) { return this.normal.set(e, t, n), this.constant = r, this } }, { key: "setFromNormalAndCoplanarPoint", value: function (e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } }, { key: "setFromCoplanarPoints", value: function (e, t, n) { var r = Ni.subVectors(n, t).cross(Di.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(r, e), this } }, { key: "clone", value: function () { return (new this.constructor).copy(this) } }, { key: "copy", value: function (e) { return this.normal.copy(e.normal), this.constant = e.constant, this } }, { key: "normalize", value: function () { var e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } }, { key: "negate", value: function () { return this.constant *= -1, this.normal.negate(), this } }, { key: "distanceToPoint", value: function (e) { return this.normal.dot(e) + this.constant } }, { key: "distanceToSphere", value: function (e) { return this.distanceToPoint(e.center) - e.radius } }, { key: "projectPoint", value: function (e, t) { return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new Nr), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) } }, { key: "intersectLine", value: function (e, t) { void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"), t = new Nr); var n = e.delta(Ni), r = this.normal.dot(n); if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0; var i = -(e.start.dot(this.normal) + this.constant) / r; return i < 0 || i > 1 ? void 0 : t.copy(n).multiplyScalar(i).add(e.start) } }, { key: "intersectsLine", value: function (e) { var t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end); return t < 0 && n > 0 || n < 0 && t > 0 } }, { key: "intersectsBox", value: function (e) { return e.intersectsPlane(this) } }, { key: "intersectsSphere", value: function (e) { return e.intersectsPlane(this) } }, { key: "coplanarPoint", value: function (e) { return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new Nr), e.copy(this.normal).multiplyScalar(-this.constant) } }, { key: "applyMatrix4", value: function (e, t) { var n = t || Fi.getNormalMatrix(e), r = this.coplanarPoint(Ni).applyMatrix4(e), i = this.normal.applyMatrix3(n).normalize(); return this.constant = -r.dot(i), this } }, { key: "translate", value: function (e) { return this.constant -= e.dot(this.normal), this } }, { key: "equals", value: function (e) { return e.normal.equals(this.normal) && e.constant === this.constant } }]), e }(), zi = new Nr, Bi = new Nr, Hi = new Nr, Gi = new Nr, Vi = new Nr, ji = new Nr, Wi = new Nr, qi = new Nr, Xi = new Nr, Yi = new Nr, Ji = function () { function e(t, n, r) { _classCallCheck(this, e), this.a = void 0 !== t ? t : new Nr, this.b = void 0 !== n ? n : new Nr, this.c = void 0 !== r ? r : new Nr } return _createClass(e, [{ key: "set", value: function (e, t, n) { return this.a.copy(e), this.b.copy(t), this.c.copy(n), this } }, { key: "setFromPointsAndIndices", value: function (e, t, n, r) { return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this } }, { key: "clone", value: function () { return (new this.constructor).copy(this) } }, { key: "copy", value: function (e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } }, { key: "getArea", value: function () { return zi.subVectors(this.c, this.b), Bi.subVectors(this.a, this.b), .5 * zi.cross(Bi).length() } }, { key: "getMidpoint", value: function (e) { return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new Nr), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } }, { key: "getNormal", value: function (t) { return e.getNormal(this.a, this.b, this.c, t) } }, { key: "getPlane", value: function (e) { return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new Ui), e.setFromCoplanarPoints(this.a, this.b, this.c) } }, { key: "getBarycoord", value: function (t, n) { return e.getBarycoord(t, this.a, this.b, this.c, n) } }, { key: "getUV", value: function (t, n, r, i, a) { return e.getUV(t, this.a, this.b, this.c, n, r, i, a) } }, { key: "containsPoint", value: function (t) { return e.containsPoint(t, this.a, this.b, this.c) } }, { key: "isFrontFacing", value: function (t) { return e.isFrontFacing(this.a, this.b, this.c, t) } }, { key: "intersectsBox", value: function (e) { return e.intersectsTriangle(this) } }, { key: "closestPointToPoint", value: function (e, t) { void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new Nr); var n, r, i = this.a, a = this.b, o = this.c; Vi.subVectors(a, i), ji.subVectors(o, i), qi.subVectors(e, i); var s = Vi.dot(qi), l = ji.dot(qi); if (s <= 0 && l <= 0) return t.copy(i); Xi.subVectors(e, a); var c = Vi.dot(Xi), u = ji.dot(Xi); if (c >= 0 && u <= c) return t.copy(a); var h = s * u - c * l; if (h <= 0 && s >= 0 && c <= 0) return n = s / (s - c), t.copy(i).addScaledVector(Vi, n); Yi.subVectors(e, o); var d = Vi.dot(Yi), p = ji.dot(Yi); if (p >= 0 && d <= p) return t.copy(o); var f = d * l - s * p; if (f <= 0 && l >= 0 && p <= 0) return r = l / (l - p), t.copy(i).addScaledVector(ji, r); var m = c * p - d * u; if (m <= 0 && u - c >= 0 && d - p >= 0) return Wi.subVectors(o, a), r = (u - c) / (u - c + (d - p)), t.copy(a).addScaledVector(Wi, r); var v = 1 / (m + f + h); return n = f * v, r = h * v, t.copy(i).addScaledVector(Vi, n).addScaledVector(ji, r) } }, { key: "equals", value: function (e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } }], [{ key: "getNormal", value: function (e, t, n, r) { void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new Nr), r.subVectors(n, t), zi.subVectors(e, t), r.cross(zi); var i = r.lengthSq(); return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0) } }, { key: "getBarycoord", value: function (e, t, n, r, i) { zi.subVectors(r, t), Bi.subVectors(n, t), Hi.subVectors(e, t); var a = zi.dot(zi), o = zi.dot(Bi), s = zi.dot(Hi), l = Bi.dot(Bi), c = Bi.dot(Hi), u = a * l - o * o; if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new Nr), 0 === u) return i.set(-2, -1, -1); var h = 1 / u, d = (l * s - o * c) * h, p = (a * c - o * s) * h; return i.set(1 - d - p, p, d) } }, { key: "containsPoint", value: function (e, t, n, r) { return this.getBarycoord(e, t, n, r, Gi), Gi.x >= 0 && Gi.y >= 0 && Gi.x + Gi.y <= 1 } }, { key: "getUV", value: function (e, t, n, r, i, a, o, s) { return this.getBarycoord(e, t, n, r, Gi), s.set(0, 0), s.addScaledVector(i, Gi.x), s.addScaledVector(a, Gi.y), s.addScaledVector(o, Gi.z), s } }, { key: "isFrontFacing", value: function (e, t, n, r) { return zi.subVectors(n, t), Bi.subVectors(e, t), zi.cross(Bi).dot(r) < 0 } }]), e }(), Zi = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Ki = { h: 0, s: 0, l: 0 }, Qi = { h: 0, s: 0, l: 0 }; function $i(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e } function ea(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function ta(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } var na = function () { function e(t, n, r) { return _classCallCheck(this, e), Object.defineProperty(this, "isColor", { value: !0 }), void 0 === n && void 0 === r ? this.set(t) : this.setRGB(t, n, r) } return _createClass(e, [{ key: "set", value: function (e) { return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this } }, { key: "setScalar", value: function (e) { return this.r = e, this.g = e, this.b = e, this } }, { key: "setHex", value: function (e) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this } }, { key: "setRGB", value: function (e, t, n) { return this.r = e, this.g = t, this.b = n, this } }, { key: "setHSL", value: function (e, t, n) { if (e = Tr.euclideanModulo(e, 1), t = Tr.clamp(t, 0, 1), n = Tr.clamp(n, 0, 1), 0 === t) this.r = this.g = this.b = n; else { var r = n <= .5 ? n * (1 + t) : n + t - n * t, i = 2 * n - r; this.r = $i(i, r, e + 1 / 3), this.g = $i(i, r, e), this.b = $i(i, r, e - 1 / 3) } return this } }, { key: "setStyle", value: function (e) { function t(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } var n; if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) { var r, i = n[1], a = n[2]; switch (i) { case "rgb": case "rgba": if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, t(r[5]), this; if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, t(r[5]), this; break; case "hsl": case "hsla": if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) { var o = parseFloat(r[1]) / 360, s = parseInt(r[2], 10) / 100, l = parseInt(r[3], 10) / 100; return t(r[5]), this.setHSL(o, s, l) } } } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(e)) { var c = n[1], u = c.length; if (3 === u) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this; if (6 === u) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this } return e && e.length > 0 ? this.setColorName(e) : this } }, { key: "setColorName", value: function (e) { var t = Zi[e]; return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this } }, { key: "clone", value: function () { return new this.constructor(this.r, this.g, this.b) } }, { key: "copy", value: function (e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } }, { key: "copyGammaToLinear", value: function (e, t) { return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this } }, { key: "copyLinearToGamma", value: function (e, t) { void 0 === t && (t = 2); var n = t > 0 ? 1 / t : 1; return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this } }, { key: "convertGammaToLinear", value: function (e) { return this.copyGammaToLinear(this, e), this } }, { key: "convertLinearToGamma", value: function (e) { return this.copyLinearToGamma(this, e), this } }, { key: "copySRGBToLinear", value: function (e) { return this.r = ea(e.r), this.g = ea(e.g), this.b = ea(e.b), this } }, { key: "copyLinearToSRGB", value: function (e) { return this.r = ta(e.r), this.g = ta(e.g), this.b = ta(e.b), this } }, { key: "convertSRGBToLinear", value: function () { return this.copySRGBToLinear(this), this } }, { key: "convertLinearToSRGB", value: function () { return this.copyLinearToSRGB(this), this } }, { key: "getHex", value: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 } }, { key: "getHexString", value: function () { return ("000000" + this.getHex().toString(16)).slice(-6) } }, { key: "getHSL", value: function (e) { void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = { h: 0, s: 0, l: 0 }); var t, n, r = this.r, i = this.g, a = this.b, o = Math.max(r, i, a), s = Math.min(r, i, a), l = (s + o) / 2; if (s === o) t = 0, n = 0; else { var c = o - s; switch (n = l <= .5 ? c / (o + s) : c / (2 - o - s), o) { case r: t = (i - a) / c + (i < a ? 6 : 0); break; case i: t = (a - r) / c + 2; break; case a: t = (r - i) / c + 4 }t /= 6 } return e.h = t, e.s = n, e.l = l, e } }, { key: "getStyle", value: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" } }, { key: "offsetHSL", value: function (e, t, n) { return this.getHSL(Ki), Ki.h += e, Ki.s += t, Ki.l += n, this.setHSL(Ki.h, Ki.s, Ki.l), this } }, { key: "add", value: function (e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } }, { key: "addColors", value: function (e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } }, { key: "addScalar", value: function (e) { return this.r += e, this.g += e, this.b += e, this } }, { key: "sub", value: function (e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } }, { key: "multiply", value: function (e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } }, { key: "multiplyScalar", value: function (e) { return this.r *= e, this.g *= e, this.b *= e, this } }, { key: "lerp", value: function (e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } }, { key: "lerpHSL", value: function (e, t) { this.getHSL(Ki), e.getHSL(Qi); var n = Tr.lerp(Ki.h, Qi.h, t), r = Tr.lerp(Ki.s, Qi.s, t), i = Tr.lerp(Ki.l, Qi.l, t); return this.setHSL(n, r, i), this } }, { key: "equals", value: function (e) { return e.r === this.r && e.g === this.g && e.b === this.b } }, { key: "fromArray", value: function (e, t) { return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } }, { key: "toArray", value: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } }, { key: "fromBufferAttribute", value: function (e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this } }, { key: "toJSON", value: function () { return this.getHex() } }]), e }(); na.NAMES = Zi, na.prototype.r = 1, na.prototype.g = 1, na.prototype.b = 1; var ra = function () { function e(t, n, r, i, a, o) { _classCallCheck(this, e), this.a = t, this.b = n, this.c = r, this.normal = i && i.isVector3 ? i : new Nr, this.vertexNormals = Array.isArray(i) ? i : [], this.color = a && a.isColor ? a : new na, this.vertexColors = Array.isArray(a) ? a : [], this.materialIndex = void 0 !== o ? o : 0 } return _createClass(e, [{ key: "clone", value: function () { return (new this.constructor).copy(this) } }, { key: "copy", value: function (e) { this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex; for (var t = 0, n = e.vertexNormals.length; t < n; t++)this.vertexNormals[t] = e.vertexNormals[t].clone(); for (var r = 0, i = e.vertexColors.length; r < i; r++)this.vertexColors[r] = e.vertexColors[r].clone(); return this } }]), e }(), ia = 0; function aa() { Object.defineProperty(this, "id", { value: ia++ }), this.uuid = Tr.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = He, this.side = Fe, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = tt, this.blendDst = nt, this.blendEquation = qe, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = ht, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = gr, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = vr, this.stencilZFail = vr, this.stencilZPass = vr, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } function oa(e) { aa.call(this), this.type = "MeshBasicMaterial", this.color = new na(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = vt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(e) } aa.prototype = Object.assign(Object.create(xr.prototype), { constructor: aa, isMaterial: !0, onBeforeCompile: function () { }, customProgramCacheKey: function () { return this.onBeforeCompile.toString() }, setValues: function (e) { if (void 0 !== e) for (var t in e) { var n = e[t]; if (void 0 !== n) if ("shading" !== t) { var r = this[t]; void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n; else console.warn("THREE.Material: '" + t + "' parameter is undefined.") } }, toJSON: function (e) { var t = void 0 === e || "string" == typeof e; t && (e = { textures: {}, images: {} }); var n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function r(e) { var t = []; for (var n in e) { var r = e[n]; delete r.metadata, t.push(r) } return t } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== He && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== Fe && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) { var i = r(e.textures), a = r(e.images); i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a) } return n }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; var t = e.clippingPlanes, n = null; if (null !== t) { var r = t.length; n = new Array(r); for (var i = 0; i !== r; ++i)n[i] = t[i].clone() } return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(aa.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }), oa.prototype = Object.create(aa.prototype), oa.prototype.constructor = oa, oa.prototype.isMeshBasicMaterial = !0, oa.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this }; var sa = new Nr, la = new Er; function ca(e, t, n) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = yr, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function ua(e, t, n) { ca.call(this, new Int8Array(e), t, n) } function ha(e, t, n) { ca.call(this, new Uint8Array(e), t, n) } function da(e, t, n) { ca.call(this, new Uint8ClampedArray(e), t, n) } function pa(e, t, n) { ca.call(this, new Int16Array(e), t, n) } function fa(e, t, n) { ca.call(this, new Uint16Array(e), t, n) } function ma(e, t, n) { ca.call(this, new Int32Array(e), t, n) } function va(e, t, n) { ca.call(this, new Uint32Array(e), t, n) } function ga(e, t, n) { ca.call(this, new Float32Array(e), t, n) } function ya(e, t, n) { ca.call(this, new Float64Array(e), t, n) } Object.defineProperty(ca.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }), Object.assign(ca.prototype, { isBufferAttribute: !0, onUploadCallback: function () { }, setUsage: function (e) { return this.usage = e, this }, copy: function (e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this }, copyAt: function (e, t, n) { e *= this.itemSize, n *= t.itemSize; for (var r = 0, i = this.itemSize; r < i; r++)this.array[e + r] = t.array[n + r]; return this }, copyArray: function (e) { return this.array.set(e), this }, copyColorsArray: function (e) { for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) { var a = e[r]; void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), a = new na), t[n++] = a.r, t[n++] = a.g, t[n++] = a.b } return this }, copyVector2sArray: function (e) { for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) { var a = e[r]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new Er), t[n++] = a.x, t[n++] = a.y } return this }, copyVector3sArray: function (e) { for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) { var a = e[r]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), a = new Nr), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z } return this }, copyVector4sArray: function (e) { for (var t = this.array, n = 0, r = 0, i = e.length; r < i; r++) { var a = e[r]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), a = new Cr), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z, t[n++] = a.w } return this }, applyMatrix3: function (e) { if (2 === this.itemSize) for (var t = 0, n = this.count; t < n; t++)la.fromBufferAttribute(this, t), la.applyMatrix3(e), this.setXY(t, la.x, la.y); else if (3 === this.itemSize) for (var r = 0, i = this.count; r < i; r++)sa.fromBufferAttribute(this, r), sa.applyMatrix3(e), this.setXYZ(r, sa.x, sa.y, sa.z); return this }, applyMatrix4: function (e) { for (var t = 0, n = this.count; t < n; t++)sa.x = this.getX(t), sa.y = this.getY(t), sa.z = this.getZ(t), sa.applyMatrix4(e), this.setXYZ(t, sa.x, sa.y, sa.z); return this }, applyNormalMatrix: function (e) { for (var t = 0, n = this.count; t < n; t++)sa.x = this.getX(t), sa.y = this.getY(t), sa.z = this.getZ(t), sa.applyNormalMatrix(e), this.setXYZ(t, sa.x, sa.y, sa.z); return this }, transformDirection: function (e) { for (var t = 0, n = this.count; t < n; t++)sa.x = this.getX(t), sa.y = this.getY(t), sa.z = this.getZ(t), sa.transformDirection(e), this.setXYZ(t, sa.x, sa.y, sa.z); return this }, set: function (e, t) { return void 0 === t && (t = 0), this.array.set(e, t), this }, getX: function (e) { return this.array[e * this.itemSize] }, setX: function (e, t) { return this.array[e * this.itemSize] = t, this }, getY: function (e) { return this.array[e * this.itemSize + 1] }, setY: function (e, t) { return this.array[e * this.itemSize + 1] = t, this }, getZ: function (e) { return this.array[e * this.itemSize + 2] }, setZ: function (e, t) { return this.array[e * this.itemSize + 2] = t, this }, getW: function (e) { return this.array[e * this.itemSize + 3] }, setW: function (e, t) { return this.array[e * this.itemSize + 3] = t, this }, setXY: function (e, t, n) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this }, setXYZ: function (e, t, n, r) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this }, setXYZW: function (e, t, n, r, i) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this }, onUpload: function (e) { return this.onUploadCallback = e, this }, clone: function () { return new this.constructor(this.array, this.itemSize).copy(this) }, toJSON: function () { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized } } }), ua.prototype = Object.create(ca.prototype), ua.prototype.constructor = ua, ha.prototype = Object.create(ca.prototype), ha.prototype.constructor = ha, da.prototype = Object.create(ca.prototype), da.prototype.constructor = da, pa.prototype = Object.create(ca.prototype), pa.prototype.constructor = pa, fa.prototype = Object.create(ca.prototype), fa.prototype.constructor = fa, ma.prototype = Object.create(ca.prototype), ma.prototype.constructor = ma, va.prototype = Object.create(ca.prototype), va.prototype.constructor = va, ga.prototype = Object.create(ca.prototype), ga.prototype.constructor = ga, ya.prototype = Object.create(ca.prototype), ya.prototype.constructor = ya; var ba = function () { function e() { _classCallCheck(this, e), this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 } return _createClass(e, [{ key: "computeGroups", value: function (e) { var t, n, r = [], i = void 0, a = e.faces; for (n = 0; n < a.length; n++) { var o = a[n]; o.materialIndex !== i && (i = o.materialIndex, void 0 !== t && (t.count = 3 * n - t.start, r.push(t)), t = { start: 3 * n, materialIndex: i }) } void 0 !== t && (t.count = 3 * n - t.start, r.push(t)), this.groups = r } }, { key: "fromGeometry", value: function (e) { var t, n = e.faces, r = e.vertices, i = e.faceVertexUvs, a = i[0] && i[0].length > 0, o = i[1] && i[1].length > 0, s = e.morphTargets, l = s.length; if (l > 0) { t = []; for (var c = 0; c < l; c++)t[c] = { name: s[c].name, data: [] }; this.morphTargets.position = t } var u, h = e.morphNormals, d = h.length; if (d > 0) { u = []; for (var p = 0; p < d; p++)u[p] = { name: h[p].name, data: [] }; this.morphTargets.normal = u } var f = e.skinIndices, m = e.skinWeights, v = f.length === r.length, g = m.length === r.length; r.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."); for (var y = 0; y < n.length; y++) { var b = n[y]; this.vertices.push(r[b.a], r[b.b], r[b.c]); var x = b.vertexNormals; if (3 === x.length) this.normals.push(x[0], x[1], x[2]); else { var _ = b.normal; this.normals.push(_, _, _) } var w = b.vertexColors; if (3 === w.length) this.colors.push(w[0], w[1], w[2]); else { var M = b.color; this.colors.push(M, M, M) } if (!0 === a) { var S = i[0][y]; void 0 !== S ? this.uvs.push(S[0], S[1], S[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", y), this.uvs.push(new Er, new Er, new Er)) } if (!0 === o) { var T = i[1][y]; void 0 !== T ? this.uvs2.push(T[0], T[1], T[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", y), this.uvs2.push(new Er, new Er, new Er)) } for (var E = 0; E < l; E++) { var A = s[E].vertices; t[E].data.push(A[b.a], A[b.b], A[b.c]) } for (var R = 0; R < d; R++) { var k = h[R].vertexNormals[y]; u[R].data.push(k.a, k.b, k.c) } v && this.skinIndices.push(f[b.a], f[b.b], f[b.c]), g && this.skinWeights.push(m[b.a], m[b.b], m[b.c]) } return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this } }]), e }(); function xa(e) { if (0 === e.length) return -1 / 0; for (var t = e[0], n = 1, r = e.length; n < r; ++n)e[n] > t && (t = e[n]); return t } var _a = 1, wa = new ci, Ma = new Ii, Sa = new Nr, Ta = new Ur, Ea = new Ur, Aa = new Nr; function Ra() { Object.defineProperty(this, "id", { value: _a += 2 }), this.uuid = Tr.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } Ra.prototype = Object.assign(Object.create(xr.prototype), { constructor: Ra, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (e) { return Array.isArray(e) ? this.index = new (xa(e) > 65535 ? va : fa)(e, 1) : this.index = e, this }, getAttribute: function (e) { return this.attributes[e] }, setAttribute: function (e, t) { return this.attributes[e] = t, this }, deleteAttribute: function (e) { return delete this.attributes[e], this }, addGroup: function (e, t, n) { this.groups.push({ start: e, count: t, materialIndex: void 0 !== n ? n : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (e, t) { this.drawRange.start = e, this.drawRange.count = t }, applyMatrix4: function (e) { var t = this.attributes.position; void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0); var n = this.attributes.normal; if (void 0 !== n) { var r = (new Ar).getNormalMatrix(e); n.applyNormalMatrix(r), n.needsUpdate = !0 } var i = this.attributes.tangent; return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: function (e) { return wa.makeRotationX(e), this.applyMatrix4(wa), this }, rotateY: function (e) { return wa.makeRotationY(e), this.applyMatrix4(wa), this }, rotateZ: function (e) { return wa.makeRotationZ(e), this.applyMatrix4(wa), this }, translate: function (e, t, n) { return wa.makeTranslation(e, t, n), this.applyMatrix4(wa), this }, scale: function (e, t, n) { return wa.makeScale(e, t, n), this.applyMatrix4(wa), this }, lookAt: function (e) { return Ma.lookAt(e), Ma.updateMatrix(), this.applyMatrix4(Ma.matrix), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(Sa).negate(), this.translate(Sa.x, Sa.y, Sa.z), this }, setFromObject: function (e) { var t = e.geometry; if (e.isPoints || e.isLine) { var n = new ga(3 * t.vertices.length, 3), r = new ga(3 * t.colors.length, 3); if (this.setAttribute("position", n.copyVector3sArray(t.vertices)), this.setAttribute("color", r.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) { var i = new ga(t.lineDistances.length, 1); this.setAttribute("lineDistance", i.copyArray(t.lineDistances)) } null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()) } else e.isMesh && t && t.isGeometry && this.fromGeometry(t); return this }, setFromPoints: function (e) { for (var t = [], n = 0, r = e.length; n < r; n++) { var i = e[n]; t.push(i.x, i.y, i.z || 0) } return this.setAttribute("position", new ga(t, 3)), this }, updateFromObject: function (e) { var t = e.geometry; if (e.isMesh) { var n = t.__directGeometry; if (!0 === t.elementsNeedUpdate && (n = void 0, t.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(t); n.verticesNeedUpdate = t.verticesNeedUpdate, n.normalsNeedUpdate = t.normalsNeedUpdate, n.colorsNeedUpdate = t.colorsNeedUpdate, n.uvsNeedUpdate = t.uvsNeedUpdate, n.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = n } if (!0 === t.verticesNeedUpdate) { var r = this.attributes.position; void 0 !== r && (r.copyVector3sArray(t.vertices), r.needsUpdate = !0), t.verticesNeedUpdate = !1 } if (!0 === t.normalsNeedUpdate) { var i = this.attributes.normal; void 0 !== i && (i.copyVector3sArray(t.normals), i.needsUpdate = !0), t.normalsNeedUpdate = !1 } if (!0 === t.colorsNeedUpdate) { var a = this.attributes.color; void 0 !== a && (a.copyColorsArray(t.colors), a.needsUpdate = !0), t.colorsNeedUpdate = !1 } if (t.uvsNeedUpdate) { var o = this.attributes.uv; void 0 !== o && (o.copyVector2sArray(t.uvs), o.needsUpdate = !0), t.uvsNeedUpdate = !1 } if (t.lineDistancesNeedUpdate) { var s = this.attributes.lineDistance; void 0 !== s && (s.copyArray(t.lineDistances), s.needsUpdate = !0), t.lineDistancesNeedUpdate = !1 } return t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this }, fromGeometry: function (e) { return e.__directGeometry = (new ba).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry) }, fromDirectGeometry: function (e) { var t = new Float32Array(3 * e.vertices.length); if (this.setAttribute("position", new ca(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) { var n = new Float32Array(3 * e.normals.length); this.setAttribute("normal", new ca(n, 3).copyVector3sArray(e.normals)) } if (e.colors.length > 0) { var r = new Float32Array(3 * e.colors.length); this.setAttribute("color", new ca(r, 3).copyColorsArray(e.colors)) } if (e.uvs.length > 0) { var i = new Float32Array(2 * e.uvs.length); this.setAttribute("uv", new ca(i, 2).copyVector2sArray(e.uvs)) } if (e.uvs2.length > 0) { var a = new Float32Array(2 * e.uvs2.length); this.setAttribute("uv2", new ca(a, 2).copyVector2sArray(e.uvs2)) } for (var o in this.groups = e.groups, e.morphTargets) { for (var s = [], l = e.morphTargets[o], c = 0, u = l.length; c < u; c++) { var h = l[c], d = new ga(3 * h.data.length, 3); d.name = h.name, s.push(d.copyVector3sArray(h.data)) } this.morphAttributes[o] = s } if (e.skinIndices.length > 0) { var p = new ga(4 * e.skinIndices.length, 4); this.setAttribute("skinIndex", p.copyVector4sArray(e.skinIndices)) } if (e.skinWeights.length > 0) { var f = new ga(4 * e.skinWeights.length, 4); this.setAttribute("skinWeight", f.copyVector4sArray(e.skinWeights)) } return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Ur); var e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Nr(-1 / 0, -1 / 0, -1 / 0), new Nr(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), t) for (var n = 0, r = t.length; n < r; n++) { var i = t[n]; Ta.setFromBufferAttribute(i), this.morphTargetsRelative ? (Aa.addVectors(this.boundingBox.min, Ta.min), this.boundingBox.expandByPoint(Aa), Aa.addVectors(this.boundingBox.max, Ta.max), this.boundingBox.expandByPoint(Aa)) : (this.boundingBox.expandByPoint(Ta.min), this.boundingBox.expandByPoint(Ta.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new ei); var e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Nr, 1 / 0); if (e) { var n = this.boundingSphere.center; if (Ta.setFromBufferAttribute(e), t) for (var r = 0, i = t.length; r < i; r++) { var a = t[r]; Ea.setFromBufferAttribute(a), this.morphTargetsRelative ? (Aa.addVectors(Ta.min, Ea.min), Ta.expandByPoint(Aa), Aa.addVectors(Ta.max, Ea.max), Ta.expandByPoint(Aa)) : (Ta.expandByPoint(Ea.min), Ta.expandByPoint(Ea.max)) } Ta.getCenter(n); for (var o = 0, s = 0, l = e.count; s < l; s++)Aa.fromBufferAttribute(e, s), o = Math.max(o, n.distanceToSquared(Aa)); if (t) for (var c = 0, u = t.length; c < u; c++)for (var h = t[c], d = this.morphTargetsRelative, p = 0, f = h.count; p < f; p++)Aa.fromBufferAttribute(h, p), d && (Sa.fromBufferAttribute(e, p), Aa.add(Sa)), o = Math.max(o, n.distanceToSquared(Aa)); this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } }, computeFaceNormals: function () { }, computeVertexNormals: function () { var e = this.index, t = this.getAttribute("position"); if (void 0 !== t) { var n = this.getAttribute("normal"); if (void 0 === n) n = new ca(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n); else for (var r = 0, i = n.count; r < i; r++)n.setXYZ(r, 0, 0, 0); var a = new Nr, o = new Nr, s = new Nr, l = new Nr, c = new Nr, u = new Nr, h = new Nr, d = new Nr; if (e) for (var p = 0, f = e.count; p < f; p += 3) { var m = e.getX(p + 0), v = e.getX(p + 1), g = e.getX(p + 2); a.fromBufferAttribute(t, m), o.fromBufferAttribute(t, v), s.fromBufferAttribute(t, g), h.subVectors(s, o), d.subVectors(a, o), h.cross(d), l.fromBufferAttribute(n, m), c.fromBufferAttribute(n, v), u.fromBufferAttribute(n, g), l.add(h), c.add(h), u.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(v, c.x, c.y, c.z), n.setXYZ(g, u.x, u.y, u.z) } else for (var y = 0, b = t.count; y < b; y += 3)a.fromBufferAttribute(t, y + 0), o.fromBufferAttribute(t, y + 1), s.fromBufferAttribute(t, y + 2), h.subVectors(s, o), d.subVectors(a, o), h.cross(d), n.setXYZ(y + 0, h.x, h.y, h.z), n.setXYZ(y + 1, h.x, h.y, h.z), n.setXYZ(y + 2, h.x, h.y, h.z); this.normalizeNormals(), n.needsUpdate = !0 } }, merge: function (e, t) { if (e && e.isBufferGeometry) { void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); var n = this.attributes; for (var r in n) if (void 0 !== e.attributes[r]) for (var i = n[r].array, a = e.attributes[r], o = a.array, s = a.itemSize * t, l = Math.min(o.length, i.length - s), c = 0, u = s; c < l; c++, u++)i[u] = o[c]; return this } console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e) }, normalizeNormals: function () { for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++)Aa.fromBufferAttribute(e, t), Aa.normalize(), e.setXYZ(t, Aa.x, Aa.y, Aa.z) }, toNonIndexed: function () { function e(e, t) { for (var n = e.array, r = e.itemSize, i = e.normalized, a = new n.constructor(t.length * r), o = 0, s = 0, l = 0, c = t.length; l < c; l++) { o = t[l] * r; for (var u = 0; u < r; u++)a[s++] = n[o++] } return new ca(a, r, i) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; var t = new Ra, n = this.index.array, r = this.attributes; for (var i in r) { var a = e(r[i], n); t.setAttribute(i, a) } var o = this.morphAttributes; for (var s in o) { for (var l = [], c = o[s], u = 0, h = c.length; u < h; u++) { var d = e(c[u], n); l.push(d) } t.morphAttributes[s] = l } t.morphTargetsRelative = this.morphTargetsRelative; for (var p = this.groups, f = 0, m = p.length; f < m; f++) { var v = p[f]; t.addGroup(v.start, v.count, v.materialIndex) } return t }, toJSON: function () { var e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) { var t = this.parameters; for (var n in t) void 0 !== t[n] && (e[n] = t[n]); return e } e.data = { attributes: {} }; var r = this.index; null !== r && (e.data.index = { type: r.array.constructor.name, array: Array.prototype.slice.call(r.array) }); var i = this.attributes; for (var a in i) { var o = i[a], s = o.toJSON(e.data); "" !== o.name && (s.name = o.name), e.data.attributes[a] = s } var l = {}, c = !1; for (var u in this.morphAttributes) { for (var h = this.morphAttributes[u], d = [], p = 0, f = h.length; p < f; p++) { var m = h[p], v = m.toJSON(e.data); "" !== m.name && (v.name = m.name), d.push(v) } d.length > 0 && (l[u] = d, c = !0) } c && (e.data.morphAttributes = l, e.data.morphTargetsRelative = this.morphTargetsRelative); var g = this.groups; g.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(g))); var y = this.boundingSphere; return null !== y && (e.data.boundingSphere = { center: y.center.toArray(), radius: y.radius }), e }, clone: function () { return (new Ra).copy(this) }, copy: function (e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; var t = {}; this.name = e.name; var n = e.index; null !== n && this.setIndex(n.clone(t)); var r = e.attributes; for (var i in r) { var a = r[i]; this.setAttribute(i, a.clone(t)) } var o = e.morphAttributes; for (var s in o) { for (var l = [], c = o[s], u = 0, h = c.length; u < h; u++)l.push(c[u].clone(t)); this.morphAttributes[s] = l } this.morphTargetsRelative = e.morphTargetsRelative; for (var d = e.groups, p = 0, f = d.length; p < f; p++) { var m = d[p]; this.addGroup(m.start, m.count, m.materialIndex) } var v = e.boundingBox; null !== v && (this.boundingBox = v.clone()); var g = e.boundingSphere; return null !== g && (this.boundingSphere = g.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); var ka = new ci, La = new li, Ca = new ei, Pa = new Nr, Oa = new Nr, Ia = new Nr, Na = new Nr, Da = new Nr, Fa = new Nr, Ua = new Nr, za = new Nr, Ba = new Nr, Ha = new Er, Ga = new Er, Va = new Er, ja = new Nr, Wa = new Nr; function qa(e, t) { Ii.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new Ra, this.material = void 0 !== t ? t : new oa, this.updateMorphTargets() } function Xa(e, t, n, r, i, a, o, s) { if (null === (t.side === Ue ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, t.side !== ze, s))) return null; Wa.copy(s), Wa.applyMatrix4(e.matrixWorld); var l = n.ray.origin.distanceTo(Wa); return l < n.near || l > n.far ? null : { distance: l, point: Wa.clone(), object: e } } function Ya(e, t, n, r, i, a, o, s, l, c, u, h) { Pa.fromBufferAttribute(i, c), Oa.fromBufferAttribute(i, u), Ia.fromBufferAttribute(i, h); var d = e.morphTargetInfluences; if (t.morphTargets && a && d) { Ua.set(0, 0, 0), za.set(0, 0, 0), Ba.set(0, 0, 0); for (var p = 0, f = a.length; p < f; p++) { var m = d[p], v = a[p]; 0 !== m && (Na.fromBufferAttribute(v, c), Da.fromBufferAttribute(v, u), Fa.fromBufferAttribute(v, h), o ? (Ua.addScaledVector(Na, m), za.addScaledVector(Da, m), Ba.addScaledVector(Fa, m)) : (Ua.addScaledVector(Na.sub(Pa), m), za.addScaledVector(Da.sub(Oa), m), Ba.addScaledVector(Fa.sub(Ia), m))) } Pa.add(Ua), Oa.add(za), Ia.add(Ba) } e.isSkinnedMesh && (e.boneTransform(c, Pa), e.boneTransform(u, Oa), e.boneTransform(h, Ia)); var g = Xa(e, t, n, r, Pa, Oa, Ia, ja); if (g) { s && (Ha.fromBufferAttribute(s, c), Ga.fromBufferAttribute(s, u), Va.fromBufferAttribute(s, h), g.uv = Ji.getUV(ja, Pa, Oa, Ia, Ha, Ga, Va, new Er)), l && (Ha.fromBufferAttribute(l, c), Ga.fromBufferAttribute(l, u), Va.fromBufferAttribute(l, h), g.uv2 = Ji.getUV(ja, Pa, Oa, Ia, Ha, Ga, Va, new Er)); var y = new ra(c, u, h); Ji.getNormal(Pa, Oa, Ia, y.normal), g.face = y } return g } qa.prototype = Object.assign(Object.create(Ii.prototype), { constructor: qa, isMesh: !0, copy: function (e) { return Ii.prototype.copy.call(this, e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this }, updateMorphTargets: function () { var e = this.geometry; if (e.isBufferGeometry) { var t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { var r = t[n[0]]; if (void 0 !== r) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (var i = 0, a = r.length; i < a; i++) { var o = r[i].name || String(i); this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i } } } } else { var s = e.morphTargets; void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }, raycast: function (e, t) { var n, r = this.geometry, i = this.material, a = this.matrixWorld; if (void 0 !== i && (null === r.boundingSphere && r.computeBoundingSphere(), Ca.copy(r.boundingSphere), Ca.applyMatrix4(a), !1 !== e.ray.intersectsSphere(Ca) && (ka.getInverse(a), La.copy(e.ray).applyMatrix4(ka), null === r.boundingBox || !1 !== La.intersectsBox(r.boundingBox)))) if (r.isBufferGeometry) { var o = r.index, s = r.attributes.position, l = r.morphAttributes.position, c = r.morphTargetsRelative, u = r.attributes.uv, h = r.attributes.uv2, d = r.groups, p = r.drawRange; if (null !== o) if (Array.isArray(i)) for (var f = 0, m = d.length; f < m; f++)for (var v = d[f], g = i[v.materialIndex], y = Math.max(v.start, p.start), b = Math.min(v.start + v.count, p.start + p.count); y < b; y += 3) { var x = o.getX(y), _ = o.getX(y + 1), w = o.getX(y + 2); (n = Ya(this, g, e, La, s, l, c, u, h, x, _, w)) && (n.faceIndex = Math.floor(y / 3), n.face.materialIndex = v.materialIndex, t.push(n)) } else for (var M = Math.max(0, p.start), S = Math.min(o.count, p.start + p.count); M < S; M += 3) { var T = o.getX(M), E = o.getX(M + 1), A = o.getX(M + 2); (n = Ya(this, i, e, La, s, l, c, u, h, T, E, A)) && (n.faceIndex = Math.floor(M / 3), t.push(n)) } else if (void 0 !== s) if (Array.isArray(i)) for (var R = 0, k = d.length; R < k; R++)for (var L = d[R], C = i[L.materialIndex], P = Math.max(L.start, p.start), O = Math.min(L.start + L.count, p.start + p.count); P < O; P += 3) { (n = Ya(this, C, e, La, s, l, c, u, h, P, P + 1, P + 2)) && (n.faceIndex = Math.floor(P / 3), n.face.materialIndex = L.materialIndex, t.push(n)) } else for (var I = Math.max(0, p.start), N = Math.min(s.count, p.start + p.count); I < N; I += 3) { (n = Ya(this, i, e, La, s, l, c, u, h, I, I + 1, I + 2)) && (n.faceIndex = Math.floor(I / 3), t.push(n)) } } else if (r.isGeometry) { var D, F = Array.isArray(i), U = r.vertices, z = r.faces, B = r.faceVertexUvs[0]; B.length > 0 && (D = B); for (var H = 0, G = z.length; H < G; H++) { var V = z[H], j = F ? i[V.materialIndex] : i; if (void 0 !== j) { var W = U[V.a], q = U[V.b], X = U[V.c]; if (n = Xa(this, j, e, La, W, q, X, ja)) { if (D && D[H]) { var Y = D[H]; Ha.copy(Y[0]), Ga.copy(Y[1]), Va.copy(Y[2]), n.uv = Ji.getUV(ja, W, q, X, Ha, Ga, Va, new Er) } n.face = V, n.faceIndex = H, t.push(n) } } } } } }); var Ja = function (e) { _inherits(n, Ra); var t = _createSuper(n); function n() { var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, l = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1; _classCallCheck(this, n), (e = t.call(this)).type = "BoxBufferGeometry", e.parameters = { width: r, height: i, depth: a, widthSegments: o, heightSegments: s, depthSegments: l }; var c = _assertThisInitialized(e); o = Math.floor(o), s = Math.floor(s), l = Math.floor(l); var u = [], h = [], d = [], p = [], f = 0, m = 0; function v(e, t, n, r, i, a, o, s, l, v, g) { for (var y = a / l, b = o / v, x = a / 2, _ = o / 2, w = s / 2, M = l + 1, S = v + 1, T = 0, E = 0, A = new Nr, R = 0; R < S; R++)for (var k = R * b - _, L = 0; L < M; L++) { var C = L * y - x; A[e] = C * r, A[t] = k * i, A[n] = w, h.push(A.x, A.y, A.z), A[e] = 0, A[t] = 0, A[n] = s > 0 ? 1 : -1, d.push(A.x, A.y, A.z), p.push(L / l), p.push(1 - R / v), T += 1 } for (var P = 0; P < v; P++)for (var O = 0; O < l; O++) { var I = f + O + M * P, N = f + O + M * (P + 1), D = f + (O + 1) + M * (P + 1), F = f + (O + 1) + M * P; u.push(I, N, F), u.push(N, D, F), E += 6 } c.addGroup(m, E, g), m += E, f += T } return v("z", "y", "x", -1, -1, a, i, r, l, s, 0), v("z", "y", "x", 1, -1, a, i, -r, l, s, 1), v("x", "z", "y", 1, 1, r, a, i, o, l, 2), v("x", "z", "y", 1, -1, r, a, -i, o, l, 3), v("x", "y", "z", 1, -1, r, i, a, o, s, 4), v("x", "y", "z", -1, -1, r, i, -a, o, s, 5), e.setIndex(u), e.setAttribute("position", new ga(h, 3)), e.setAttribute("normal", new ga(d, 3)), e.setAttribute("uv", new ga(p, 2)), e } return n }(); function Za(e) { var t = {}; for (var n in e) for (var r in t[n] = {}, e[n]) { var i = e[n][r]; i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i } return t } function Ka(e) { for (var t = {}, n = 0; n < e.length; n++) { var r = Za(e[n]); for (var i in r) t[i] = r[i] } return t } var Qa = { clone: Za, merge: Ka }, $a = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", eo = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"; function to(e) { aa.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = $a, this.fragmentShader = eo, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) } function no() { Ii.call(this), this.type = "Camera", this.matrixWorldInverse = new ci, this.projectionMatrix = new ci, this.projectionMatrixInverse = new ci } function ro(e, t, n, r) { no.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } to.prototype = Object.create(aa.prototype), to.prototype.constructor = to, to.prototype.isShaderMaterial = !0, to.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Za(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this }, to.prototype.toJSON = function (e) { var t = aa.prototype.toJSON.call(this, e); for (var n in t.glslVersion = this.glslVersion, t.uniforms = {}, this.uniforms) { var r = this.uniforms[n].value; r && r.isTexture ? t.uniforms[n] = { type: "t", value: r.toJSON(e).uuid } : r && r.isColor ? t.uniforms[n] = { type: "c", value: r.getHex() } : r && r.isVector2 ? t.uniforms[n] = { type: "v2", value: r.toArray() } : r && r.isVector3 ? t.uniforms[n] = { type: "v3", value: r.toArray() } : r && r.isVector4 ? t.uniforms[n] = { type: "v4", value: r.toArray() } : r && r.isMatrix3 ? t.uniforms[n] = { type: "m3", value: r.toArray() } : r && r.isMatrix4 ? t.uniforms[n] = { type: "m4", value: r.toArray() } : t.uniforms[n] = { value: r } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; var i = {}; for (var a in this.extensions) !0 === this.extensions[a] && (i[a] = !0); return Object.keys(i).length > 0 && (t.extensions = i), t }, no.prototype = Object.assign(Object.create(Ii.prototype), { constructor: no, isCamera: !0, copy: function (e, t) { return Ii.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this }, getWorldDirection: function (e) { void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new Nr), this.updateMatrixWorld(!0); var t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() }, updateMatrixWorld: function (e) { Ii.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld) }, updateWorldMatrix: function (e, t) { Ii.prototype.updateWorldMatrix.call(this, e, t), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function () { return (new this.constructor).copy(this) } }), ro.prototype = Object.assign(Object.create(no.prototype), { constructor: ro, isPerspectiveCamera: !0, copy: function (e, t) { return no.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this }, setFocalLength: function (e) { var t = .5 * this.getFilmHeight() / e; this.fov = 2 * Tr.RAD2DEG * Math.atan(t), this.updateProjectionMatrix() }, getFocalLength: function () { var e = Math.tan(.5 * Tr.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / e }, getEffectiveFOV: function () { return 2 * Tr.RAD2DEG * Math.atan(Math.tan(.5 * Tr.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (e, t, n, r, i, a) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var e = this.near, t = e * Math.tan(.5 * Tr.DEG2RAD * this.fov) / this.zoom, n = 2 * t, r = this.aspect * n, i = -.5 * r, a = this.view; if (null !== this.view && this.view.enabled) { var o = a.fullWidth, s = a.fullHeight; i += a.offsetX * r / o, t -= a.offsetY * n / s, r *= a.width / o, n *= a.height / s } var l = this.filmOffset; 0 !== l && (i += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (e) { var t = Ii.prototype.toJSON.call(this, e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } }); var io = 90, ao = 1; function oo(e, t, n) { if (Ii.call(this), this.type = "CubeCamera", !0 === n.isWebGLCubeRenderTarget) { this.renderTarget = n; var r = new ro(io, ao, e, t); r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Nr(1, 0, 0)), this.add(r); var i = new ro(io, ao, e, t); i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Nr(-1, 0, 0)), this.add(i); var a = new ro(io, ao, e, t); a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new Nr(0, 1, 0)), this.add(a); var o = new ro(io, ao, e, t); o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new Nr(0, -1, 0)), this.add(o); var s = new ro(io, ao, e, t); s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new Nr(0, 0, 1)), this.add(s); var l = new ro(io, ao, e, t); l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Nr(0, 0, -1)), this.add(l), this.update = function (e, t) { null === this.parent && this.updateMatrixWorld(); var c = e.xr.enabled, u = e.getRenderTarget(); e.xr.enabled = !1; var h = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, r), e.setRenderTarget(n, 1), e.render(t, i), e.setRenderTarget(n, 2), e.render(t, a), e.setRenderTarget(n, 3), e.render(t, o), e.setRenderTarget(n, 4), e.render(t, s), n.texture.generateMipmaps = h, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(u), e.xr.enabled = c }, this.clear = function (e, t, r, i) { for (var a = e.getRenderTarget(), o = 0; o < 6; o++)e.setRenderTarget(n, o), e.clear(t, r, i); e.setRenderTarget(a) } } else console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.") } function so(e, t, n, r, i, a, o, s, l, c) { e = void 0 !== e ? e : [], t = void 0 !== t ? t : Tt, o = void 0 !== o ? o : $t, Lr.call(this, e, t, n, r, i, a, o, s, l, c), this.flipY = !1, this._needsFlipEnvMap = !0 } function lo(e, t, n) { Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n), Pr.call(this, e, e, t), t = t || {}, this.texture = new so(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture._needsFlipEnvMap = !1 } function co(e, t, n, r, i, a, o, s, l, c, u, h) { Lr.call(this, null, a, o, s, l, c, r, i, u, h), this.image = { data: e || null, width: t || 1, height: n || 1 }, this.magFilter = void 0 !== l ? l : It, this.minFilter = void 0 !== c ? c : It, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } oo.prototype = Object.create(Ii.prototype), oo.prototype.constructor = oo, so.prototype = Object.create(Lr.prototype), so.prototype.constructor = so, so.prototype.isCubeTexture = !0, Object.defineProperty(so.prototype, "images", { get: function () { return this.image }, set: function (e) { this.image = e } }), lo.prototype = Object.create(Pr.prototype), lo.prototype.constructor = lo, lo.prototype.isWebGLCubeRenderTarget = !0, lo.prototype.fromEquirectangularTexture = function (e, t) { this.texture.type = t.type, this.texture.format = en, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; var n = { tEquirect: { value: null } }, r = "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t", i = "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t", a = new Ja(5, 5, 5), o = new to({ name: "CubemapFromEquirect", uniforms: Za(n), vertexShader: r, fragmentShader: i, side: Ue, blending: Be }); o.uniforms.tEquirect.value = t; var s = new qa(a, o), l = t.minFilter; return t.minFilter === zt && (t.minFilter = Ft), new oo(1, 10, this).update(e, s), t.minFilter = l, s.geometry.dispose(), s.material.dispose(), this }, co.prototype = Object.create(Lr.prototype), co.prototype.constructor = co, co.prototype.isDataTexture = !0; var uo = new ei, ho = new Nr, po = function () { function e(t, n, r, i, a, o) { _classCallCheck(this, e), this.planes = [void 0 !== t ? t : new Ui, void 0 !== n ? n : new Ui, void 0 !== r ? r : new Ui, void 0 !== i ? i : new Ui, void 0 !== a ? a : new Ui, void 0 !== o ? o : new Ui] } return _createClass(e, [{ key: "set", value: function (e, t, n, r, i, a) { var o = this.planes; return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(a), this } }, { key: "clone", value: function () { return (new this.constructor).copy(this) } }, { key: "copy", value: function (e) { for (var t = this.planes, n = 0; n < 6; n++)t[n].copy(e.planes[n]); return this } }, { key: "setFromProjectionMatrix", value: function (e) { var t = this.planes, n = e.elements, r = n[0], i = n[1], a = n[2], o = n[3], s = n[4], l = n[5], c = n[6], u = n[7], h = n[8], d = n[9], p = n[10], f = n[11], m = n[12], v = n[13], g = n[14], y = n[15]; return t[0].setComponents(o - r, u - s, f - h, y - m).normalize(), t[1].setComponents(o + r, u + s, f + h, y + m).normalize(), t[2].setComponents(o + i, u + l, f + d, y + v).normalize(), t[3].setComponents(o - i, u - l, f - d, y - v).normalize(), t[4].setComponents(o - a, u - c, f - p, y - g).normalize(), t[5].setComponents(o + a, u + c, f + p, y + g).normalize(), this } }, { key: "intersectsObject", value: function (e) { var t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), uo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(uo) } }, { key: "intersectsSprite", value: function (e) { return uo.center.set(0, 0, 0), uo.radius = .7071067811865476, uo.applyMatrix4(e.matrixWorld), this.intersectsSphere(uo) } }, { key: "intersectsSphere", value: function (e) { for (var t = this.planes, n = e.center, r = -e.radius, i = 0; i < 6; i++) { if (t[i].distanceToPoint(n) < r) return !1 } return !0 } }, { key: "intersectsBox", value: function (e) { for (var t = this.planes, n = 0; n < 6; n++) { var r = t[n]; if (ho.x = r.normal.x > 0 ? e.max.x : e.min.x, ho.y = r.normal.y > 0 ? e.max.y : e.min.y, ho.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(ho) < 0) return !1 } return !0 } }, { key: "containsPoint", value: function (e) { for (var t = this.planes, n = 0; n < 6; n++)if (t[n].distanceToPoint(e) < 0) return !1; return !0 } }]), e }(); function fo() { var e = null, t = !1, n = null, r = null; function i(t, a) { n(t, a), r = e.requestAnimationFrame(i) } return { start: function () { !0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !0) }, stop: function () { e.cancelAnimationFrame(r), t = !1 }, setAnimationLoop: function (e) { n = e }, setContext: function (t) { e = t } } } function mo(e, t) { var n = t.isWebGL2, r = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), r.get(e) }, remove: function (t) { t.isInterleavedBufferAttribute && (t = t.data); var n = r.get(t); n && (e.deleteBuffer(n.buffer), r.delete(t)) }, update: function (t, i) { if (t.isGLBufferAttribute) { var a = r.get(t); (!a || a.version < t.version) && r.set(t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version }) } else { t.isInterleavedBufferAttribute && (t = t.data); var o = r.get(t); void 0 === o ? r.set(t, function (t, n) { var r = t.array, i = t.usage, a = e.createBuffer(); e.bindBuffer(n, a), e.bufferData(n, r, i), t.onUploadCallback(); var o = 5126; return _instanceof(r, Float32Array) ? o = 5126 : _instanceof(r, Float64Array) ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : _instanceof(r, Uint16Array) ? o = 5123 : _instanceof(r, Int16Array) ? o = 5122 : _instanceof(r, Uint32Array) ? o = 5125 : _instanceof(r, Int32Array) ? o = 5124 : _instanceof(r, Int8Array) ? o = 5120 : _instanceof(r, Uint8Array) && (o = 5121), { buffer: a, type: o, bytesPerElement: r.BYTES_PER_ELEMENT, version: t.version } }(t, i)) : o.version < t.version && (function (t, r, i) { var a = r.array, o = r.updateRange; e.bindBuffer(i, t), -1 === o.count ? e.bufferSubData(i, 0, a) : (n ? e.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : e.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1) }(o.buffer, t, i), o.version = t.version) } } } } var vo = function (e) { _inherits(n, Ra); var t = _createSuper(n); function n(e, r, i, a) { var o; _classCallCheck(this, n), (o = t.call(this)).type = "PlaneBufferGeometry", o.parameters = { width: e, height: r, widthSegments: i, heightSegments: a }; for (var s = (e = e || 1) / 2, l = (r = r || 1) / 2, c = Math.floor(i) || 1, u = Math.floor(a) || 1, h = c + 1, d = u + 1, p = e / c, f = r / u, m = [], v = [], g = [], y = [], b = 0; b < d; b++)for (var x = b * f - l, _ = 0; _ < h; _++) { var w = _ * p - s; v.push(w, -x, 0), g.push(0, 0, 1), y.push(_ / c), y.push(1 - b / u) } for (var M = 0; M < u; M++)for (var S = 0; S < c; S++) { var T = S + h * M, E = S + h * (M + 1), A = S + 1 + h * (M + 1), R = S + 1 + h * M; m.push(T, E, R), m.push(E, A, R) } return o.setIndex(m), o.setAttribute("position", new ga(v, 3)), o.setAttribute("normal", new ga(g, 3)), o.setAttribute("uv", new ga(y, 2)), o } return n }(), go = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif", transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, yo = { common: { diffuse: { value: new na(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Ar }, uv2Transform: { value: new Ar }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Er(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new na(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new na(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Ar } }, sprite: { diffuse: { value: new na(15658734) }, opacity: { value: 1 }, center: { value: new Er(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Ar } } }, bo = { basic: { uniforms: Ka([yo.common, yo.specularmap, yo.envmap, yo.aomap, yo.lightmap, yo.fog]), vertexShader: go.meshbasic_vert, fragmentShader: go.meshbasic_frag }, lambert: { uniforms: Ka([yo.common, yo.specularmap, yo.envmap, yo.aomap, yo.lightmap, yo.emissivemap, yo.fog, yo.lights, { emissive: { value: new na(0) } }]), vertexShader: go.meshlambert_vert, fragmentShader: go.meshlambert_frag }, phong: { uniforms: Ka([yo.common, yo.specularmap, yo.envmap, yo.aomap, yo.lightmap, yo.emissivemap, yo.bumpmap, yo.normalmap, yo.displacementmap, yo.fog, yo.lights, { emissive: { value: new na(0) }, specular: { value: new na(1118481) }, shininess: { value: 30 } }]), vertexShader: go.meshphong_vert, fragmentShader: go.meshphong_frag }, standard: { uniforms: Ka([yo.common, yo.envmap, yo.aomap, yo.lightmap, yo.emissivemap, yo.bumpmap, yo.normalmap, yo.displacementmap, yo.roughnessmap, yo.metalnessmap, yo.fog, yo.lights, { emissive: { value: new na(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: go.meshphysical_vert, fragmentShader: go.meshphysical_frag }, toon: { uniforms: Ka([yo.common, yo.aomap, yo.lightmap, yo.emissivemap, yo.bumpmap, yo.normalmap, yo.displacementmap, yo.gradientmap, yo.fog, yo.lights, { emissive: { value: new na(0) } }]), vertexShader: go.meshtoon_vert, fragmentShader: go.meshtoon_frag }, matcap: { uniforms: Ka([yo.common, yo.bumpmap, yo.normalmap, yo.displacementmap, yo.fog, { matcap: { value: null } }]), vertexShader: go.meshmatcap_vert, fragmentShader: go.meshmatcap_frag }, points: { uniforms: Ka([yo.points, yo.fog]), vertexShader: go.points_vert, fragmentShader: go.points_frag }, dashed: { uniforms: Ka([yo.common, yo.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: go.linedashed_vert, fragmentShader: go.linedashed_frag }, depth: { uniforms: Ka([yo.common, yo.displacementmap]), vertexShader: go.depth_vert, fragmentShader: go.depth_frag }, normal: { uniforms: Ka([yo.common, yo.bumpmap, yo.normalmap, yo.displacementmap, { opacity: { value: 1 } }]), vertexShader: go.normal_vert, fragmentShader: go.normal_frag }, sprite: { uniforms: Ka([yo.sprite, yo.fog]), vertexShader: go.sprite_vert, fragmentShader: go.sprite_frag }, background: { uniforms: { uvTransform: { value: new Ar }, t2D: { value: null } }, vertexShader: go.background_vert, fragmentShader: go.background_frag }, cube: { uniforms: Ka([yo.envmap, { opacity: { value: 1 } }]), vertexShader: go.cube_vert, fragmentShader: go.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: go.equirect_vert, fragmentShader: go.equirect_frag }, distanceRGBA: { uniforms: Ka([yo.common, yo.displacementmap, { referencePosition: { value: new Nr }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: go.distanceRGBA_vert, fragmentShader: go.distanceRGBA_frag }, shadow: { uniforms: Ka([yo.lights, yo.fog, { color: { value: new na(0) }, opacity: { value: 1 } }]), vertexShader: go.shadow_vert, fragmentShader: go.shadow_frag } }; function xo(e, t, n, r, i) { var a, o, s = new na(0), l = 0, c = null, u = 0, h = null; function d(e, t) { n.buffers.color.setClear(e.r, e.g, e.b, t, i) } return { getClearColor: function () { return s }, setClearColor: function (e, t) { s.set(e), d(s, l = void 0 !== t ? t : 1) }, getClearAlpha: function () { return l }, setClearAlpha: function (e) { d(s, l = e) }, render: function (n, i, p, f) { var m = !0 === i.isScene ? i.background : null; m && m.isTexture && (m = t.get(m)); var v = e.xr, g = v.getSession && v.getSession(); g && "additive" === g.environmentBlendMode && (m = null), null === m ? d(s, l) : m && m.isColor && (d(m, 1), f = !0), (e.autoClear || f) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), m && (m.isCubeTexture || m.isWebGLCubeRenderTarget || m.mapping === kt) ? (void 0 === o && ((o = new qa(new Ja(1, 1, 1), new to({ name: "BackgroundCubeMaterial", uniforms: Za(bo.cube.uniforms), vertexShader: bo.cube.vertexShader, fragmentShader: bo.cube.fragmentShader, side: Ue, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function (e, t, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(o.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(o)), m.isWebGLCubeRenderTarget && (m = m.texture), o.material.uniforms.envMap.value = m, o.material.uniforms.flipEnvMap.value = m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1, c === m && u === m.version && h === e.toneMapping || (o.material.needsUpdate = !0, c = m, u = m.version, h = e.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) : m && m.isTexture && (void 0 === a && ((a = new qa(new vo(2, 2), new to({ name: "BackgroundMaterial", uniforms: Za(bo.background.uniforms), vertexShader: bo.background.vertexShader, fragmentShader: bo.background.fragmentShader, side: Fe, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(a)), a.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), a.material.uniforms.uvTransform.value.copy(m.matrix), c === m && u === m.version && h === e.toneMapping || (a.material.needsUpdate = !0, c = m, u = m.version, h = e.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) } } } function _o(e, t, n, r) { var i = e.getParameter(34921), a = r.isWebGL2 ? null : t.get("OES_vertex_array_object"), o = r.isWebGL2 || null !== a, s = {}, l = d(null), c = l; function u(t) { return r.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t) } function h(t) { return r.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t) } function d(e) { for (var t = [], n = [], r = [], a = 0; a < i; a++)t[a] = 0, n[a] = 0, r[a] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: n, attributeDivisors: r, object: e, attributes: {}, index: null } } function p() { for (var e = c.newAttributes, t = 0, n = e.length; t < n; t++)e[t] = 0 } function f(e) { m(e, 0) } function m(n, i) { var a = c.newAttributes, o = c.enabledAttributes, s = c.attributeDivisors; (a[n] = 1, 0 === o[n] && (e.enableVertexAttribArray(n), o[n] = 1), s[n] !== i) && ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), s[n] = i) } function v() { for (var t = c.newAttributes, n = c.enabledAttributes, r = 0, i = n.length; r < i; r++)n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0) } function g(t, n, i, a, o, s) { !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? e.vertexAttribPointer(t, n, i, a, o, s) : e.vertexAttribIPointer(t, n, i, o, s) } function y() { b(), c !== l && u((c = l).object) } function b() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: function (i, l, h, y, b) { var x = !1; if (o) { var _ = function (t, n, i) { var o = !0 === i.wireframe, l = s[t.id]; void 0 === l && (l = {}, s[t.id] = l); var c = l[n.id]; void 0 === c && (c = {}, l[n.id] = c); var u = c[o]; return void 0 === u && (u = d(r.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()), c[o] = u), u }(y, h, l); c !== _ && u((c = _).object), (x = function (e, t) { var n = c.attributes, r = e.attributes; if (Object.keys(n).length !== Object.keys(r).length) return !0; for (var i in r) { var a = n[i], o = r[i]; if (void 0 === a) return !0; if (a.attribute !== o) return !0; if (a.data !== o.data) return !0 } return c.index !== t }(y, b)) && function (e, t) { var n = {}, r = e.attributes; for (var i in r) { var a = r[i], o = {}; o.attribute = a, a.data && (o.data = a.data), n[i] = o } c.attributes = n, c.index = t }(y, b) } else { var w = !0 === l.wireframe; c.geometry === y.id && c.program === h.id && c.wireframe === w || (c.geometry = y.id, c.program = h.id, c.wireframe = w, x = !0) } !0 === i.isInstancedMesh && (x = !0), null !== b && n.update(b, 34963), x && (function (i, a, o, s) { if (!1 !== r.isWebGL2 || !i.isInstancedMesh && !s.isInstancedBufferGeometry || null !== t.get("ANGLE_instanced_arrays")) { p(); var l = s.attributes, c = o.getAttributes(), u = a.defaultAttributeValues; for (var h in c) { var d = c[h]; if (d >= 0) { var y = l[h]; if (void 0 !== y) { var b = y.normalized, x = y.itemSize, _ = n.get(y); if (void 0 === _) continue; var w = _.buffer, M = _.type, S = _.bytesPerElement; if (y.isInterleavedBufferAttribute) { var T = y.data, E = T.stride, A = y.offset; T && T.isInstancedInterleavedBuffer ? (m(d, T.meshPerAttribute), void 0 === s._maxInstanceCount && (s._maxInstanceCount = T.meshPerAttribute * T.count)) : f(d), e.bindBuffer(34962, w), g(d, x, M, b, E * S, A * S) } else y.isInstancedBufferAttribute ? (m(d, y.meshPerAttribute), void 0 === s._maxInstanceCount && (s._maxInstanceCount = y.meshPerAttribute * y.count)) : f(d), e.bindBuffer(34962, w), g(d, x, M, b, 0, 0) } else if ("instanceMatrix" === h) { var R = n.get(i.instanceMatrix); if (void 0 === R) continue; var k = R.buffer, L = R.type; m(d + 0, 1), m(d + 1, 1), m(d + 2, 1), m(d + 3, 1), e.bindBuffer(34962, k), e.vertexAttribPointer(d + 0, 4, L, !1, 64, 0), e.vertexAttribPointer(d + 1, 4, L, !1, 64, 16), e.vertexAttribPointer(d + 2, 4, L, !1, 64, 32), e.vertexAttribPointer(d + 3, 4, L, !1, 64, 48) } else if ("instanceColor" === h) { var C = n.get(i.instanceColor); if (void 0 === C) continue; var P = C.buffer, O = C.type; m(d, 1), e.bindBuffer(34962, P), e.vertexAttribPointer(d, 3, O, !1, 12, 0) } else if (void 0 !== u) { var I = u[h]; if (void 0 !== I) switch (I.length) { case 2: e.vertexAttrib2fv(d, I); break; case 3: e.vertexAttrib3fv(d, I); break; case 4: e.vertexAttrib4fv(d, I); break; default: e.vertexAttrib1fv(d, I) } } } } v() } }(i, l, h, y), null !== b && e.bindBuffer(34963, n.get(b).buffer)) }, reset: y, resetDefaultState: b, dispose: function () { for (var e in y(), s) { var t = s[e]; for (var n in t) { var r = t[n]; for (var i in r) h(r[i].object), delete r[i]; delete t[n] } delete s[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 !== s[e.id]) { var t = s[e.id]; for (var n in t) { var r = t[n]; for (var i in r) h(r[i].object), delete r[i]; delete t[n] } delete s[e.id] } }, releaseStatesOfProgram: function (e) { for (var t in s) { var n = s[t]; if (void 0 !== n[e.id]) { var r = n[e.id]; for (var i in r) h(r[i].object), delete r[i]; delete n[e.id] } } }, initAttributes: p, enableAttribute: f, disableUnusedAttributes: v } } function wo(e, t, n, r) { var i, a = r.isWebGL2; this.setMode = function (e) { i = e }, this.render = function (t, r) { e.drawArrays(i, t, r), n.update(r, i, 1) }, this.renderInstances = function (r, o, s) { if (0 !== s) { var l, c; if (a) l = e, c = "drawArraysInstanced"; else if (c = "drawArraysInstancedANGLE", null === (l = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[c](i, r, o, s), n.update(o, i, s) } } } function Mo(e, t, n) { var r; function i(t) { if ("highp" === t) { if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; t = "mediump" } return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } var a = "undefined" != typeof WebGL2RenderingContext && _instanceof(e, WebGL2RenderingContext) || "undefined" != typeof WebGL2ComputeRenderingContext && _instanceof(e, WebGL2ComputeRenderingContext), o = void 0 !== n.precision ? n.precision : "highp", s = i(o); s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s); var l = !0 === n.logarithmicDepthBuffer, c = e.getParameter(34930), u = e.getParameter(35660), h = e.getParameter(3379), d = e.getParameter(34076), p = e.getParameter(34921), f = e.getParameter(36347), m = e.getParameter(36348), v = e.getParameter(36349), g = u > 0, y = a || !!t.get("OES_texture_float"); return { isWebGL2: a, getMaxAnisotropy: function () { if (void 0 !== r) return r; var n = t.get("EXT_texture_filter_anisotropic"); return r = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: i, precision: o, logarithmicDepthBuffer: l, maxTextures: c, maxVertexTextures: u, maxTextureSize: h, maxCubemapSize: d, maxAttributes: p, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: v, vertexTextures: g, floatFragmentTextures: y, floatVertexTextures: g && y, maxSamples: a ? e.getParameter(36183) : 0 } } function So(e) { var t = this, n = null, r = 0, i = !1, a = !1, o = new Ui, s = new Ar, l = { value: null, needsUpdate: !1 }; function c() { l.value !== n && (l.value = n, l.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0 } function u(e, n, r, i) { var a = null !== e ? e.length : 0, c = null; if (0 !== a) { if (c = l.value, !0 !== i || null === c) { var u = r + 4 * a, h = n.matrixWorldInverse; s.getNormalMatrix(h), (null === c || c.length < u) && (c = new Float32Array(u)); for (var d = 0, p = r; d !== a; ++d, p += 4)o.copy(e[d]).applyMatrix4(h, s), o.normal.toArray(c, p), c[p + 3] = o.constant } l.value = c, l.needsUpdate = !0 } return t.numPlanes = a, t.numIntersection = 0, c } this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, a) { var o = 0 !== e.length || t || 0 !== r || i; return i = t, n = u(e, a, 0), r = e.length, o }, this.beginShadows = function () { a = !0, u(null) }, this.endShadows = function () { a = !1, c() }, this.setState = function (t, o, s) { var h = t.clippingPlanes, d = t.clipIntersection, p = t.clipShadows, f = e.get(t); if (!i || null === h || 0 === h.length || a && !p) a ? u(null) : c(); else { var m = a ? 0 : r, v = 4 * m, g = f.clippingState || null; l.value = g, g = u(h, o, v, s); for (var y = 0; y !== v; ++y)g[y] = n[y]; f.clippingState = g, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += m } } } function To(e) { var t = new WeakMap; function n(e, t) { return t === At ? e.mapping = Tt : t === Rt && (e.mapping = Et), e } return { get: function (r) { if (r && r.isTexture) { var i = r.mapping; if (i === At || i === Rt) { if (t.has(r)) return n(t.get(r).texture, r.mapping); var a = r.image; if (a && a.height > 0) { var o = e.getRenderList(), s = e.getRenderTarget(), l = e.getRenderState(), c = new lo(a.height / 2); return c.fromEquirectangularTexture(e, r), t.set(r, c), e.setRenderTarget(s), e.setRenderList(o), e.setRenderState(l), n(c.texture, r.mapping) } return null } } return r }, dispose: function () { t = new WeakMap } } } function Eo(e) { var t = {}; return { has: function (n) { if (void 0 !== t[n]) return null !== t[n]; var r; switch (n) { case "WEBGL_depth_texture": r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = e.getExtension(n) }return t[n] = r, null !== r }, get: function (e) { return this.has(e) || console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t[e] } } } function Ao(e, t, n, r) { var i = new WeakMap, a = new WeakMap; function o(e) { var s = e.target, l = i.get(s); for (var c in null !== l.index && t.remove(l.index), l.attributes) t.remove(l.attributes[c]); s.removeEventListener("dispose", o), i.delete(s); var u = a.get(l); u && (t.remove(u), a.delete(l)), r.releaseStatesOfGeometry(s), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory.geometries-- } function s(e) { var n = [], r = e.index, i = e.attributes.position, o = 0; if (null !== r) { var s = r.array; o = r.version; for (var l = 0, c = s.length; l < c; l += 3) { var u = s[l + 0], h = s[l + 1], d = s[l + 2]; n.push(u, h, h, d, d, u) } } else { var p = i.array; o = i.version; for (var f = 0, m = p.length / 3 - 1; f < m; f += 3) { var v = f + 0, g = f + 1, y = f + 2; n.push(v, g, g, y, y, v) } } var b = new (xa(n) > 65535 ? va : fa)(n, 1); b.version = o; var x = a.get(e); x && t.remove(x), a.set(e, b) } return { get: function (e, t) { var r = i.get(t); return r || (t.addEventListener("dispose", o), t.isBufferGeometry ? r = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new Ra).setFromObject(e)), r = t._bufferGeometry), i.set(t, r), n.memory.geometries++, r) }, update: function (e) { var n = e.attributes; for (var r in n) t.update(n[r], 34962); var i = e.morphAttributes; for (var a in i) for (var o = i[a], s = 0, l = o.length; s < l; s++)t.update(o[s], 34962) }, getWireframeAttribute: function (e) { var t = a.get(e); if (t) { var n = e.index; null !== n && t.version < n.version && s(e) } else s(e); return a.get(e) } } } function Ro(e, t, n, r) { var i, a, o, s = r.isWebGL2; this.setMode = function (e) { i = e }, this.setIndex = function (e) { a = e.type, o = e.bytesPerElement }, this.render = function (t, r) { e.drawElements(i, r, a, t * o), n.update(r, i, 1) }, this.renderInstances = function (r, l, c) { if (0 !== c) { var u, h; if (s) u = e, h = "drawElementsInstanced"; else if (h = "drawElementsInstancedANGLE", null === (u = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); u[h](i, l, a, r * o, c), n.update(l, i, c) } } } function ko(e) { var t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function () { t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 }, update: function (e, n, r) { switch (t.calls++, n) { case 4: t.triangles += r * (e / 3); break; case 1: t.lines += r * (e / 2); break; case 3: t.lines += r * (e - 1); break; case 2: t.lines += r * e; break; case 0: t.points += r * e; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", n) } } } } function Lo(e, t) { return e[0] - t[0] } function Co(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) } function Po(e) { for (var t = {}, n = new Float32Array(8), r = [], i = 0; i < 8; i++)r[i] = [i, 0]; return { update: function (i, a, o, s) { var l = i.morphTargetInfluences, c = void 0 === l ? 0 : l.length, u = t[a.id]; if (void 0 === u) { u = []; for (var h = 0; h < c; h++)u[h] = [h, 0]; t[a.id] = u } for (var d = 0; d < c; d++) { var p = u[d]; p[0] = d, p[1] = l[d] } u.sort(Co); for (var f = 0; f < 8; f++)f < c && u[f][1] ? (r[f][0] = u[f][0], r[f][1] = u[f][1]) : (r[f][0] = Number.MAX_SAFE_INTEGER, r[f][1] = 0); r.sort(Lo); for (var m = o.morphTargets && a.morphAttributes.position, v = o.morphNormals && a.morphAttributes.normal, g = 0, y = 0; y < 8; y++) { var b = r[y], x = b[0], _ = b[1]; x !== Number.MAX_SAFE_INTEGER && _ ? (m && a.getAttribute("morphTarget" + y) !== m[x] && a.setAttribute("morphTarget" + y, m[x]), v && a.getAttribute("morphNormal" + y) !== v[x] && a.setAttribute("morphNormal" + y, v[x]), n[y] = _, g += _) : (m && void 0 !== a.getAttribute("morphTarget" + y) && a.deleteAttribute("morphTarget" + y), v && void 0 !== a.getAttribute("morphNormal" + y) && a.deleteAttribute("morphNormal" + y), n[y] = 0) } var w = a.morphTargetsRelative ? 1 : 1 - g; s.getUniforms().setValue(e, "morphTargetBaseInfluence", w), s.getUniforms().setValue(e, "morphTargetInfluences", n) } } } function Oo(e, t, n, r) { var i = new WeakMap; return { update: function (e) { var a = r.render.frame, o = e.geometry, s = t.get(e, o); return i.get(s) !== a && (o.isGeometry && s.updateFromObject(e), t.update(s), i.set(s, a)), e.isInstancedMesh && (n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), s }, dispose: function () { i = new WeakMap } } } function Io(e, t, n, r) { Lr.call(this, null), this.image = { data: e || null, width: t || 1, height: n || 1, depth: r || 1 }, this.magFilter = It, this.minFilter = It, this.wrapR = Pt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } function No(e, t, n, r) { Lr.call(this, null), this.image = { data: e || null, width: t || 1, height: n || 1, depth: r || 1 }, this.magFilter = It, this.minFilter = It, this.wrapR = Pt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } bo.physical = { uniforms: Ka([bo.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Er(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new na(0) }, transmission: { value: 0 }, transmissionMap: { value: null } }]), vertexShader: go.meshphysical_vert, fragmentShader: go.meshphysical_frag }, Io.prototype = Object.create(Lr.prototype), Io.prototype.constructor = Io, Io.prototype.isDataTexture2DArray = !0, No.prototype = Object.create(Lr.prototype), No.prototype.constructor = No, No.prototype.isDataTexture3D = !0; var Do = new Lr, Fo = new Io, Uo = new No, zo = new so, Bo = [], Ho = [], Go = new Float32Array(16), Vo = new Float32Array(9), jo = new Float32Array(4); function Wo(e, t, n) { var r = e[0]; if (r <= 0 || r > 0) return e; var i = t * n, a = Bo[i]; if (void 0 === a && (a = new Float32Array(i), Bo[i] = a), 0 !== t) { r.toArray(a, 0); for (var o = 1, s = 0; o !== t; ++o)s += n, e[o].toArray(a, s) } return a } function qo(e, t) { if (e.length !== t.length) return !1; for (var n = 0, r = e.length; n < r; n++)if (e[n] !== t[n]) return !1; return !0 } function Xo(e, t) { for (var n = 0, r = t.length; n < r; n++)e[n] = t[n] } function Yo(e, t) { var n = Ho[t]; void 0 === n && (n = new Int32Array(t), Ho[t] = n); for (var r = 0; r !== t; ++r)n[r] = e.allocateTextureUnit(); return n } function Jo(e, t) { var n = this.cache; n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t) } function Zo(e, t) { var n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else { if (qo(n, t)) return; e.uniform2fv(this.addr, t), Xo(n, t) } } function Ko(e, t) { var n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b); else { if (qo(n, t)) return; e.uniform3fv(this.addr, t), Xo(n, t) } } function Qo(e, t) { var n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else { if (qo(n, t)) return; e.uniform4fv(this.addr, t), Xo(n, t) } } function $o(e, t) { var n = this.cache, r = t.elements; if (void 0 === r) { if (qo(n, t)) return; e.uniformMatrix2fv(this.addr, !1, t), Xo(n, t) } else { if (qo(n, r)) return; jo.set(r), e.uniformMatrix2fv(this.addr, !1, jo), Xo(n, r) } } function es(e, t) { var n = this.cache, r = t.elements; if (void 0 === r) { if (qo(n, t)) return; e.uniformMatrix3fv(this.addr, !1, t), Xo(n, t) } else { if (qo(n, r)) return; Vo.set(r), e.uniformMatrix3fv(this.addr, !1, Vo), Xo(n, r) } } function ts(e, t) { var n = this.cache, r = t.elements; if (void 0 === r) { if (qo(n, t)) return; e.uniformMatrix4fv(this.addr, !1, t), Xo(n, t) } else { if (qo(n, r)) return; Go.set(r), e.uniformMatrix4fv(this.addr, !1, Go), Xo(n, r) } } function ns(e, t, n) { var r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(t || Do, i) } function rs(e, t, n) { var r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || Fo, i) } function is(e, t, n) { var r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || Uo, i) } function as(e, t, n) { var r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(t || zo, i) } function os(e, t) { var n = this.cache; n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t) } function ss(e, t) { var n = this.cache; qo(n, t) || (e.uniform2iv(this.addr, t), Xo(n, t)) } function ls(e, t) { var n = this.cache; qo(n, t) || (e.uniform3iv(this.addr, t), Xo(n, t)) } function cs(e, t) { var n = this.cache; qo(n, t) || (e.uniform4iv(this.addr, t), Xo(n, t)) } function us(e, t) { var n = this.cache; n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t) } function hs(e, t) { e.uniform1fv(this.addr, t) } function ds(e, t) { e.uniform1iv(this.addr, t) } function ps(e, t) { e.uniform2iv(this.addr, t) } function fs(e, t) { e.uniform3iv(this.addr, t) } function ms(e, t) { e.uniform4iv(this.addr, t) } function vs(e, t) { var n = Wo(t, this.size, 2); e.uniform2fv(this.addr, n) } function gs(e, t) { var n = Wo(t, this.size, 3); e.uniform3fv(this.addr, n) } function ys(e, t) { var n = Wo(t, this.size, 4); e.uniform4fv(this.addr, n) } function bs(e, t) { var n = Wo(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, n) } function xs(e, t) { var n = Wo(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, n) } function _s(e, t) { var n = Wo(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, n) } function ws(e, t, n) { var r = t.length, i = Yo(n, r); e.uniform1iv(this.addr, i); for (var a = 0; a !== r; ++a)n.safeSetTexture2D(t[a] || Do, i[a]) } function Ms(e, t, n) { var r = t.length, i = Yo(n, r); e.uniform1iv(this.addr, i); for (var a = 0; a !== r; ++a)n.safeSetTextureCube(t[a] || zo, i[a]) } function Ss(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.setValue = function (e) { switch (e) { case 5126: return Jo; case 35664: return Zo; case 35665: return Ko; case 35666: return Qo; case 35674: return $o; case 35675: return es; case 35676: return ts; case 5124: case 35670: return os; case 35667: case 35671: return ss; case 35668: case 35672: return ls; case 35669: case 35673: return cs; case 5125: return us; case 35678: case 36198: case 36298: case 36306: case 35682: return ns; case 35679: case 36299: case 36307: return is; case 35680: case 36300: case 36308: case 36293: return as; case 36289: case 36303: case 36311: case 36292: return rs } }(t.type) } function Ts(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function (e) { switch (e) { case 5126: return hs; case 35664: return vs; case 35665: return gs; case 35666: return ys; case 35674: return bs; case 35675: return xs; case 35676: return _s; case 5124: case 35670: return ds; case 35667: case 35671: return ps; case 35668: case 35672: return fs; case 35669: case 35673: return ms; case 35678: case 36198: case 36298: case 36306: case 35682: return ws; case 35680: case 36300: case 36308: case 36293: return Ms } }(t.type) } function Es(e) { this.id = e, this.seq = [], this.map = {} } Ts.prototype.updateCache = function (e) { var t = this.cache; _instanceof(e, Float32Array) && t.length !== e.length && (this.cache = new Float32Array(e.length)), Xo(t, e) }, Es.prototype.setValue = function (e, t, n) { for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) { var o = r[i]; o.setValue(e, t[o.id], n) } }; var As = /([\w\d_]+)(\])?(\[|\.)?/g; function Rs(e, t) { e.seq.push(t), e.map[t.id] = t } function ks(e, t, n) { var r = e.name, i = r.length; for (As.lastIndex = 0; ;) { var a = As.exec(r), o = As.lastIndex, s = a[1], l = "]" === a[2], c = a[3]; if (l && (s |= 0), void 0 === c || "[" === c && o + 2 === i) { Rs(n, void 0 === c ? new Ss(s, e, t) : new Ts(s, e, t)); break } var u = n.map[s]; void 0 === u && Rs(n, u = new Es(s)), n = u } } function Ls(e, t) { this.seq = [], this.map = {}; for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) { var i = e.getActiveUniform(t, r); ks(i, e.getUniformLocation(t, i.name), this) } } function Cs(e, t, n) { var r = e.createShader(t); return e.shaderSource(r, n), e.compileShader(r), r } Ls.prototype.setValue = function (e, t, n, r) { var i = this.map[t]; void 0 !== i && i.setValue(e, n, r) }, Ls.prototype.setOptional = function (e, t, n) { var r = t[n]; void 0 !== r && this.setValue(e, n, r) }, Ls.upload = function (e, t, n, r) { for (var i = 0, a = t.length; i !== a; ++i) { var o = t[i], s = n[o.id]; !1 !== s.needsUpdate && o.setValue(e, s.value, r) } }, Ls.seqWithValue = function (e, t) { for (var n = [], r = 0, i = e.length; r !== i; ++r) { var a = e[r]; a.id in t && n.push(a) } return n }; var Ps = 0; function Os(e) { switch (e) { case ir: return ["Linear", "( value )"]; case ar: return ["sRGB", "( value )"]; case sr: return ["RGBE", "( value )"]; case cr: return ["RGBM", "( value, 7.0 )"]; case ur: return ["RGBM", "( value, 16.0 )"]; case hr: return ["RGBD", "( value, 256.0 )"]; case or: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case lr: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"] } } function Is(e, t, n) { var r = e.getShaderParameter(t, 35713), i = e.getShaderInfoLog(t).trim(); return r && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function (e) { for (var t = e.split("\n"), n = 0; n < t.length; n++)t[n] = n + 1 + ": " + t[n]; return t.join("\n") }(e.getShaderSource(t)) } function Ns(e, t) { var n = Os(t); return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" } function Ds(e, t) { var n; switch (t) { case xt: n = "Linear"; break; case _t: n = "Reinhard"; break; case wt: n = "OptimizedCineon"; break; case Mt: n = "ACESFilmic"; break; case St: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear" }return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } function Fs(e) { return "" !== e } function Us(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function zs(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } var Bs = /^[ \t]*#include +<([\w\d.\/]+)>/gm; function Hs(e) { return e.replace(Bs, Gs) } function Gs(e, t) { var n = go[t]; if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">"); return Hs(n) } var Vs = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, js = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function Ws(e) { return e.replace(js, Xs).replace(Vs, qs) } function qs(e, t, n, r) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Xs(e, t, n, r) } function Xs(e, t, n, r) { for (var i = "", a = parseInt(t); a < parseInt(n); a++)i += r.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a); return i } function Ys(e) { var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;"; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t } function Js(e, t, n, r) { var i, a, o, s, l, c = e.getContext(), u = n.defines, h = n.vertexShader, d = n.fragmentShader, p = function (e) { var t = "SHADOWMAP_TYPE_BASIC"; return e.shadowMapType === Ie ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === Ne ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === De && (t = "SHADOWMAP_TYPE_VSM"), t }(n), f = function (e) { var t = "ENVMAP_TYPE_CUBE"; if (e.envMap) switch (e.envMapMode) { case Tt: case Et: t = "ENVMAP_TYPE_CUBE"; break; case kt: case Lt: t = "ENVMAP_TYPE_CUBE_UV" }return t }(n), m = function (e) { var t = "ENVMAP_MODE_REFLECTION"; if (e.envMap) switch (e.envMapMode) { case Et: case Lt: t = "ENVMAP_MODE_REFRACTION" }return t }(n), v = function (e) { var t = "ENVMAP_BLENDING_NONE"; if (e.envMap) switch (e.combine) { case vt: t = "ENVMAP_BLENDING_MULTIPLY"; break; case gt: t = "ENVMAP_BLENDING_MIX"; break; case yt: t = "ENVMAP_BLENDING_ADD" }return t }(n), g = e.gammaFactor > 0 ? e.gammaFactor : 1, y = n.isWebGL2 ? "" : function (e) { return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Fs).join("\n") }(n), b = function (e) { var t = []; for (var n in e) { var r = e[n]; !1 !== r && t.push("#define " + n + " " + r) } return t.join("\n") }(u), x = c.createProgram(), _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : ""; n.isRawShaderMaterial ? ((i = [b].filter(Fs).join("\n")).length > 0 && (i += "\n"), (a = [y, b].filter(Fs).join("\n")).length > 0 && (a += "\n")) : (i = [Ys(n), "#define SHADER_NAME " + n.shaderName, b, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Fs).join("\n"), a = [y, Ys(n), "#define SHADER_NAME " + n.shaderName, b, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + m : "", n.envMap ? "#define " + v : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + p : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== bt ? "#define TONE_MAPPING" : "", n.toneMapping !== bt ? go.tonemapping_pars_fragment : "", n.toneMapping !== bt ? Ds("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", go.encodings_pars_fragment, n.map ? Ns("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Ns("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Ns("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Ns("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? Ns("lightMapTexelToLinear", n.lightMapEncoding) : "", (o = "linearToOutputTexel", s = n.outputEncoding, l = Os(s), "vec4 " + o + "( vec4 value ) { return LinearTo" + l[0] + l[1] + "; }"), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Fs).join("\n")), h = zs(h = Us(h = Hs(h), n), n), d = zs(d = Us(d = Hs(d), n), n), h = Ws(h), d = Ws(d), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", i = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + i, a = ["#define varying in", n.glslVersion === br ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === br ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + a); var w, M, S = _ + a + d, T = Cs(c, 35633, _ + i + h), E = Cs(c, 35632, S); if (c.attachShader(x, T), c.attachShader(x, E), void 0 !== n.index0AttributeName ? c.bindAttribLocation(x, 0, n.index0AttributeName) : !0 === n.morphTargets && c.bindAttribLocation(x, 0, "position"), c.linkProgram(x), e.debug.checkShaderErrors) { var A = c.getProgramInfoLog(x).trim(), R = c.getShaderInfoLog(T).trim(), k = c.getShaderInfoLog(E).trim(), L = !0, C = !0; if (!1 === c.getProgramParameter(x, 35714)) { L = !1; var P = Is(c, T, "vertex"), O = Is(c, E, "fragment"); console.error("THREE.WebGLProgram: shader error: ", c.getError(), "35715", c.getProgramParameter(x, 35715), "gl.getProgramInfoLog", A, P, O) } else "" !== A ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", A) : "" !== R && "" !== k || (C = !1); C && (this.diagnostics = { runnable: L, programLog: A, vertexShader: { log: R, prefix: i }, fragmentShader: { log: k, prefix: a } }) } return c.deleteShader(T), c.deleteShader(E), this.getUniforms = function () { return void 0 === w && (w = new Ls(c, x)), w }, this.getAttributes = function () { return void 0 === M && (M = function (e, t) { for (var n = {}, r = e.getProgramParameter(t, 35721), i = 0; i < r; i++) { var a = e.getActiveAttrib(t, i).name; n[a] = e.getAttribLocation(t, a) } return n }(c, x)), M }, this.destroy = function () { r.releaseStatesOfProgram(this), c.deleteProgram(x), this.program = void 0 }, this.name = n.shaderName, this.id = Ps++, this.cacheKey = t, this.usedTimes = 1, this.program = x, this.vertexShader = T, this.fragmentShader = E, this } function Zs(e, t, n, r, i, a) { var o = [], s = r.isWebGL2, l = r.logarithmicDepthBuffer, c = r.floatVertexTextures, u = r.maxVertexUniforms, h = r.vertexTextures, d = r.precision, p = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"]; function m(e) { var t; return e ? e.isTexture ? t = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = ir, t } return { getParameters: function (i, o, f, v, g) { var y, b, x = v.fog, _ = i.isMeshStandardMaterial ? v.environment : null, w = t.get(i.envMap || _), M = p[i.type], S = g.isSkinnedMesh ? function (e) { var t = e.skeleton.bones; if (c) return 1024; var n = u, r = Math.floor((n - 20) / 4), i = Math.min(r, t.length); return i < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + i + "."), 0) : i }(g) : 0; if (null !== i.precision && (d = r.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", d, "instead."), M) { var T = bo[M]; y = T.vertexShader, b = T.fragmentShader } else y = i.vertexShader, b = i.fragmentShader; var E = e.getRenderTarget(); return { isWebGL2: s, shaderID: M, shaderName: i.type, vertexShader: y, fragmentShader: b, defines: i.defines, isRawShaderMaterial: !0 === i.isRawShaderMaterial, glslVersion: i.glslVersion, precision: d, instancing: !0 === g.isInstancedMesh, instancingColor: !0 === g.isInstancedMesh && null !== g.instanceColor, supportsVertexTextures: h, outputEncoding: null !== E ? m(E.texture) : e.outputEncoding, map: !!i.map, mapEncoding: m(i.map), matcap: !!i.matcap, matcapEncoding: m(i.matcap), envMap: !!w, envMapMode: w && w.mapping, envMapEncoding: m(w), envMapCubeUV: !!w && (w.mapping === kt || w.mapping === Lt), lightMap: !!i.lightMap, lightMapEncoding: m(i.lightMap), aoMap: !!i.aoMap, emissiveMap: !!i.emissiveMap, emissiveMapEncoding: m(i.emissiveMap), bumpMap: !!i.bumpMap, normalMap: !!i.normalMap, objectSpaceNormalMap: i.normalMapType === mr, tangentSpaceNormalMap: i.normalMapType === fr, clearcoatMap: !!i.clearcoatMap, clearcoatRoughnessMap: !!i.clearcoatRoughnessMap, clearcoatNormalMap: !!i.clearcoatNormalMap, displacementMap: !!i.displacementMap, roughnessMap: !!i.roughnessMap, metalnessMap: !!i.metalnessMap, specularMap: !!i.specularMap, alphaMap: !!i.alphaMap, gradientMap: !!i.gradientMap, sheen: !!i.sheen, transmissionMap: !!i.transmissionMap, combine: i.combine, vertexTangents: i.normalMap && i.vertexTangents, vertexColors: i.vertexColors, vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap || i.transmissionMap), uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmissionMap || !i.displacementMap), fog: !!x, useFog: i.fog, fogExp2: x && x.isFogExp2, flatShading: i.flatShading, sizeAttenuation: i.sizeAttenuation, logarithmicDepthBuffer: l, skinning: i.skinning && S > 0, maxBones: S, useVertexTexture: c, morphTargets: i.morphTargets, morphNormals: i.morphNormals, maxMorphTargets: e.maxMorphTargets, maxMorphNormals: e.maxMorphNormals, numDirLights: o.directional.length, numPointLights: o.point.length, numSpotLights: o.spot.length, numRectAreaLights: o.rectArea.length, numHemiLights: o.hemi.length, numDirLightShadows: o.directionalShadowMap.length, numPointLightShadows: o.pointShadowMap.length, numSpotLightShadows: o.spotShadowMap.length, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, dithering: i.dithering, shadowMapEnabled: e.shadowMap.enabled && f.length > 0, shadowMapType: e.shadowMap.type, toneMapping: i.toneMapped ? e.toneMapping : bt, physicallyCorrectLights: e.physicallyCorrectLights, premultipliedAlpha: i.premultipliedAlpha, alphaTest: i.alphaTest, doubleSided: i.side === ze, flipSided: i.side === Ue, depthPacking: void 0 !== i.depthPacking && i.depthPacking, index0AttributeName: i.index0AttributeName, extensionDerivatives: i.extensions && i.extensions.derivatives, extensionFragDepth: i.extensions && i.extensions.fragDepth, extensionDrawBuffers: i.extensions && i.extensions.drawBuffers, extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD, rendererExtensionFragDepth: s || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: s || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: s || n.has("EXT_shader_texture_lod"), customProgramCacheKey: i.customProgramCacheKey() } }, getProgramCacheKey: function (t) { var n = []; if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines) for (var r in t.defines) n.push(r), n.push(t.defines[r]); if (!1 === t.isRawShaderMaterial) { for (var i = 0; i < f.length; i++)n.push(t[f[i]]); n.push(e.outputEncoding), n.push(e.gammaFactor) } return n.push(t.customProgramCacheKey), n.join() }, getUniforms: function (e) { var t, n = p[e.type]; if (n) { var r = bo[n]; t = Qa.clone(r.uniforms) } else t = e.uniforms; return t }, acquireProgram: function (t, n) { for (var r, a = 0, s = o.length; a < s; a++) { var l = o[a]; if (l.cacheKey === n) { ++(r = l).usedTimes; break } } return void 0 === r && (r = new Js(e, n, t, i), o.push(r)), r }, releaseProgram: function (e) { if (0 == --e.usedTimes) { var t = o.indexOf(e); o[t] = o[o.length - 1], o.pop(), e.destroy() } }, programs: o } } function Ks() { var e = new WeakMap; return { get: function (t) { var n = e.get(t); return void 0 === n && (n = {}, e.set(t, n)), n }, remove: function (t) { e.delete(t) }, update: function (t, n, r) { e.get(t)[n] = r }, dispose: function () { e = new WeakMap } } } function Qs(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function $s(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function el(e) { var t = [], n = 0, r = [], i = [], a = { id: -1 }; function o(r, i, o, s, l, c) { var u = t[n], h = e.get(o); return void 0 === u ? (u = { id: r.id, object: r, geometry: i, material: o, program: h.program || a, groupOrder: s, renderOrder: r.renderOrder, z: l, group: c }, t[n] = u) : (u.id = r.id, u.object = r, u.geometry = i, u.material = o, u.program = h.program || a, u.groupOrder = s, u.renderOrder = r.renderOrder, u.z = l, u.group = c), n++, u } return { opaque: r, transparent: i, init: function () { n = 0, r.length = 0, i.length = 0 }, push: function (e, t, n, a, s, l) { var c = o(e, t, n, a, s, l); (!0 === n.transparent ? i : r).push(c) }, unshift: function (e, t, n, a, s, l) { var c = o(e, t, n, a, s, l); (!0 === n.transparent ? i : r).unshift(c) }, finish: function () { for (var e = n, r = t.length; e < r; e++) { var i = t[e]; if (null === i.id) break; i.id = null, i.object = null, i.geometry = null, i.material = null, i.program = null, i.group = null } }, sort: function (e, t) { r.length > 1 && r.sort(e || Qs), i.length > 1 && i.sort(t || $s) } } } function tl(e) { var t = new WeakMap; return { get: function (n, r) { var i, a = t.get(n); return void 0 === a ? (i = new el(e), t.set(n, new WeakMap), t.get(n).set(r, i)) : void 0 === (i = a.get(r)) && (i = new el(e), a.set(r, i)), i }, dispose: function () { t = new WeakMap } } } function nl() { var e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; var n; switch (t.type) { case "DirectionalLight": n = { direction: new Nr, color: new na }; break; case "SpotLight": n = { position: new Nr, direction: new Nr, color: new na, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new Nr, color: new na, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new Nr, skyColor: new na, groundColor: new na }; break; case "RectAreaLight": n = { color: new na, position: new Nr, halfWidth: new Nr, halfHeight: new Nr } }return e[t.id] = n, n } } } var rl = 0; function il(e, t) { return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0) } function al() { for (var e, t = new nl, n = (e = {}, { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; var n; switch (t.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Er }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Er, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return e[t.id] = n, n } }), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }, i = 0; i < 9; i++)r.probe.push(new Nr); var a = new Nr, o = new ci, s = new ci; return { setup: function (e, i, l) { for (var c = 0, u = 0, h = 0, d = 0; d < 9; d++)r.probe[d].set(0, 0, 0); var p = 0, f = 0, m = 0, v = 0, g = 0, y = 0, b = 0, x = 0, _ = l.matrixWorldInverse; e.sort(il); for (var w = 0, M = e.length; w < M; w++) { var S = e[w], T = S.color, E = S.intensity, A = S.distance, R = S.shadow && S.shadow.map ? S.shadow.map.texture : null; if (S.isAmbientLight) c += T.r * E, u += T.g * E, h += T.b * E; else if (S.isLightProbe) for (var k = 0; k < 9; k++)r.probe[k].addScaledVector(S.sh.coefficients[k], E); else if (S.isDirectionalLight) { var L = t.get(S); if (L.color.copy(S.color).multiplyScalar(S.intensity), L.direction.setFromMatrixPosition(S.matrixWorld), a.setFromMatrixPosition(S.target.matrixWorld), L.direction.sub(a), L.direction.transformDirection(_), S.castShadow) { var C = S.shadow, P = n.get(S); P.shadowBias = C.bias, P.shadowNormalBias = C.normalBias, P.shadowRadius = C.radius, P.shadowMapSize = C.mapSize, r.directionalShadow[p] = P, r.directionalShadowMap[p] = R, r.directionalShadowMatrix[p] = S.shadow.matrix, y++ } r.directional[p] = L, p++ } else if (S.isSpotLight) { var O = t.get(S); if (O.position.setFromMatrixPosition(S.matrixWorld), O.position.applyMatrix4(_), O.color.copy(T).multiplyScalar(E), O.distance = A, O.direction.setFromMatrixPosition(S.matrixWorld), a.setFromMatrixPosition(S.target.matrixWorld), O.direction.sub(a), O.direction.transformDirection(_), O.coneCos = Math.cos(S.angle), O.penumbraCos = Math.cos(S.angle * (1 - S.penumbra)), O.decay = S.decay, S.castShadow) { var I = S.shadow, N = n.get(S); N.shadowBias = I.bias, N.shadowNormalBias = I.normalBias, N.shadowRadius = I.radius, N.shadowMapSize = I.mapSize, r.spotShadow[m] = N, r.spotShadowMap[m] = R, r.spotShadowMatrix[m] = S.shadow.matrix, x++ } r.spot[m] = O, m++ } else if (S.isRectAreaLight) { var D = t.get(S); D.color.copy(T).multiplyScalar(E), D.position.setFromMatrixPosition(S.matrixWorld), D.position.applyMatrix4(_), s.identity(), o.copy(S.matrixWorld), o.premultiply(_), s.extractRotation(o), D.halfWidth.set(.5 * S.width, 0, 0), D.halfHeight.set(0, .5 * S.height, 0), D.halfWidth.applyMatrix4(s), D.halfHeight.applyMatrix4(s), r.rectArea[v] = D, v++ } else if (S.isPointLight) { var F = t.get(S); if (F.position.setFromMatrixPosition(S.matrixWorld), F.position.applyMatrix4(_), F.color.copy(S.color).multiplyScalar(S.intensity), F.distance = S.distance, F.decay = S.decay, S.castShadow) { var U = S.shadow, z = n.get(S); z.shadowBias = U.bias, z.shadowNormalBias = U.normalBias, z.shadowRadius = U.radius, z.shadowMapSize = U.mapSize, z.shadowCameraNear = U.camera.near, z.shadowCameraFar = U.camera.far, r.pointShadow[f] = z, r.pointShadowMap[f] = R, r.pointShadowMatrix[f] = S.shadow.matrix, b++ } r.point[f] = F, f++ } else if (S.isHemisphereLight) { var B = t.get(S); B.direction.setFromMatrixPosition(S.matrixWorld), B.direction.transformDirection(_), B.direction.normalize(), B.skyColor.copy(S.color).multiplyScalar(E), B.groundColor.copy(S.groundColor).multiplyScalar(E), r.hemi[g] = B, g++ } } v > 0 && (r.rectAreaLTC1 = yo.LTC_1, r.rectAreaLTC2 = yo.LTC_2), r.ambient[0] = c, r.ambient[1] = u, r.ambient[2] = h; var H = r.hash; H.directionalLength === p && H.pointLength === f && H.spotLength === m && H.rectAreaLength === v && H.hemiLength === g && H.numDirectionalShadows === y && H.numPointShadows === b && H.numSpotShadows === x || (r.directional.length = p, r.spot.length = m, r.rectArea.length = v, r.point.length = f, r.hemi.length = g, r.directionalShadow.length = y, r.directionalShadowMap.length = y, r.pointShadow.length = b, r.pointShadowMap.length = b, r.spotShadow.length = x, r.spotShadowMap.length = x, r.directionalShadowMatrix.length = y, r.pointShadowMatrix.length = b, r.spotShadowMatrix.length = x, H.directionalLength = p, H.pointLength = f, H.spotLength = m, H.rectAreaLength = v, H.hemiLength = g, H.numDirectionalShadows = y, H.numPointShadows = b, H.numSpotShadows = x, r.version = rl++) }, state: r } } function ol() { var e = new al, t = [], n = []; return { init: function () { t.length = 0, n.length = 0 }, state: { lightsArray: t, shadowsArray: n, lights: e }, setupLights: function (r) { e.setup(t, n, r) }, pushLight: function (e) { t.push(e) }, pushShadow: function (e) { n.push(e) } } } function sl() { var e = new WeakMap; return { get: function (t, n) { var r; return !1 === e.has(t) ? (r = new ol, e.set(t, new WeakMap), e.get(t).set(n, r)) : !1 === e.get(t).has(n) ? (r = new ol, e.get(t).set(n, r)) : r = e.get(t).get(n), r }, dispose: function () { e = new WeakMap } } } function ll(e) { aa.call(this), this.type = "MeshDepthMaterial", this.depthPacking = dr, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e) } function cl(e) { aa.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Nr, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e) } ll.prototype = Object.create(aa.prototype), ll.prototype.constructor = ll, ll.prototype.isMeshDepthMaterial = !0, ll.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this }, cl.prototype = Object.create(aa.prototype), cl.prototype.constructor = cl, cl.prototype.isMeshDistanceMaterial = !0, cl.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this }; var ul = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}", hl = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"; function dl(e, t, n) { var r = new po, i = new Er, a = new Er, o = new Cr, s = [], l = [], c = {}, u = { 0: Ue, 1: Fe, 2: ze }, h = new to({ defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Er }, radius: { value: 4 } }, vertexShader: hl, fragmentShader: ul }), d = h.clone(); d.defines.HORIZONAL_PASS = 1; var p = new Ra; p.setAttribute("position", new ca(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); var f = new qa(p, h), m = this; function v(n, r) { var i = t.update(f); h.uniforms.shadow_pass.value = n.map.texture, h.uniforms.resolution.value = n.mapSize, h.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, i, h, f, null), d.uniforms.shadow_pass.value = n.mapPass.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, i, d, f, null) } function g(e, t, n) { var r = e << 0 | t << 1 | n << 2, i = s[r]; return void 0 === i && (i = new ll({ depthPacking: pr, morphTargets: e, skinning: t }), s[r] = i), i } function y(e, t, n) { var r = e << 0 | t << 1 | n << 2, i = l[r]; return void 0 === i && (i = new cl({ morphTargets: e, skinning: t }), l[r] = i), i } function b(t, n, r, i, a, o, s) { var l = null, h = g, d = t.customDepthMaterial; if (!0 === i.isPointLight && (h = y, d = t.customDistanceMaterial), void 0 === d) { var p = !1; !0 === r.morphTargets && (p = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0); var f = !1; !0 === t.isSkinnedMesh && (!0 === r.skinning ? f = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t)), l = h(p, f, !0 === t.isInstancedMesh) } else l = d; if (e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) { var m = l.uuid, v = r.uuid, b = c[m]; void 0 === b && (b = {}, c[m] = b); var x = b[v]; void 0 === x && (x = l.clone(), b[v] = x), l = x } return l.visible = r.visible, l.wireframe = r.wireframe, l.side = s === De ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : u[r.side], l.clipShadows = r.clipShadows, l.clippingPlanes = r.clippingPlanes, l.clipIntersection = r.clipIntersection, l.wireframeLinewidth = r.wireframeLinewidth, l.linewidth = r.linewidth, !0 === i.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(i.matrixWorld), l.nearDistance = a, l.farDistance = o), l } function x(n, i, a, o, s) { if (!1 !== n.visible) { if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && s === De) && (!n.frustumCulled || r.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld); var l = t.update(n), c = n.material; if (Array.isArray(c)) for (var u = l.groups, h = 0, d = u.length; h < d; h++) { var p = u[h], f = c[p.materialIndex]; if (f && f.visible) { var m = b(n, l, f, o, a.near, a.far, s); e.renderBufferDirect(a, null, l, m, n, p) } } else if (c.visible) { var v = b(n, l, c, o, a.near, a.far, s); e.renderBufferDirect(a, null, l, v, n, null) } } for (var g = n.children, y = 0, _ = g.length; y < _; y++)x(g[y], i, a, o, s) } } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Ie, this.render = function (t, s, l) { if (!1 !== m.enabled && (!1 !== m.autoUpdate || !1 !== m.needsUpdate) && 0 !== t.length) { var c = e.getRenderTarget(), u = e.getActiveCubeFace(), h = e.getActiveMipmapLevel(), d = e.state; d.setBlending(Be), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1); for (var p = 0, f = t.length; p < f; p++) { var g = t[p], y = g.shadow; if (void 0 !== y) { if (!1 !== y.autoUpdate || !1 !== y.needsUpdate) { i.copy(y.mapSize); var b = y.getFrameExtents(); if (i.multiply(b), a.copy(y.mapSize), (i.x > n || i.y > n) && (i.x > n && (a.x = Math.floor(n / b.x), i.x = a.x * b.x, y.mapSize.x = a.x), i.y > n && (a.y = Math.floor(n / b.y), i.y = a.y * b.y, y.mapSize.y = a.y)), null === y.map && !y.isPointLightShadow && this.type === De) { var _ = { minFilter: Ft, magFilter: Ft, format: en }; y.map = new Pr(i.x, i.y, _), y.map.texture.name = g.name + ".shadowMap", y.mapPass = new Pr(i.x, i.y, _), y.camera.updateProjectionMatrix() } if (null === y.map) { var w = { minFilter: It, magFilter: It, format: en }; y.map = new Pr(i.x, i.y, w), y.map.texture.name = g.name + ".shadowMap", y.camera.updateProjectionMatrix() } e.setRenderTarget(y.map), e.clear(); for (var M = y.getViewportCount(), S = 0; S < M; S++) { var T = y.getViewport(S); o.set(a.x * T.x, a.y * T.y, a.x * T.z, a.y * T.w), d.viewport(o), y.updateMatrices(g, S), r = y.getFrustum(), x(s, l, y.camera, g, this.type) } y.isPointLightShadow || this.type !== De || v(y, l), y.needsUpdate = !1 } } else console.warn("THREE.WebGLShadowMap:", g, "has no shadow.") } m.needsUpdate = !1, e.setRenderTarget(c, u, h) } } } function pl(e, t, n) { var r, i, a = n.isWebGL2; var o = new function () { var t = !1, n = new Cr, r = null, i = new Cr(0, 0, 0, 0); return { setMask: function (n) { r === n || t || (e.colorMask(n, n, n, n), r = n) }, setLocked: function (e) { t = e }, setClear: function (t, r, a, o, s) { !0 === s && (t *= o, r *= o, a *= o), n.set(t, r, a, o), !1 === i.equals(n) && (e.clearColor(t, r, a, o), i.copy(n)) }, reset: function () { t = !1, r = null, i.set(-1, 0, 0, 0) } } }, s = new function () { var t = !1, n = null, r = null, i = null; return { setTest: function (e) { e ? N(2929) : D(2929) }, setMask: function (r) { n === r || t || (e.depthMask(r), n = r) }, setFunc: function (t) { if (r !== t) { if (t) switch (t) { case lt: e.depthFunc(512); break; case ct: e.depthFunc(519); break; case ut: e.depthFunc(513); break; case ht: e.depthFunc(515); break; case dt: e.depthFunc(514); break; case pt: e.depthFunc(518); break; case ft: e.depthFunc(516); break; case mt: e.depthFunc(517); break; default: e.depthFunc(515) } else e.depthFunc(515); r = t } }, setLocked: function (e) { t = e }, setClear: function (t) { i !== t && (e.clearDepth(t), i = t) }, reset: function () { t = !1, n = null, r = null, i = null } } }, l = new function () { var t = !1, n = null, r = null, i = null, a = null, o = null, s = null, l = null, c = null; return { setTest: function (e) { t || (e ? N(2960) : D(2960)) }, setMask: function (r) { n === r || t || (e.stencilMask(r), n = r) }, setFunc: function (t, n, o) { r === t && i === n && a === o || (e.stencilFunc(t, n, o), r = t, i = n, a = o) }, setOp: function (t, n, r) { o === t && s === n && l === r || (e.stencilOp(t, n, r), o = t, s = n, l = r) }, setLocked: function (e) { t = e }, setClear: function (t) { c !== t && (e.clearStencil(t), c = t) }, reset: function () { t = !1, n = null, r = null, i = null, a = null, o = null, s = null, l = null, c = null } } }, c = {}, u = null, h = null, d = null, p = null, f = null, m = null, v = null, g = null, y = null, b = !1, x = null, _ = null, w = null, M = null, S = null, T = e.getParameter(35661), E = !1, A = 0, R = e.getParameter(7938); -1 !== R.indexOf("WebGL") ? (A = parseFloat(/^WebGL\ ([0-9])/.exec(R)[1]), E = A >= 1) : -1 !== R.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(R)[1]), E = A >= 2); var k = null, L = {}, C = new Cr, P = new Cr; function O(t, n, r) { var i = new Uint8Array(4), a = e.createTexture(); e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728); for (var o = 0; o < r; o++)e.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, i); return a } var I = {}; function N(t) { !0 !== c[t] && (e.enable(t), c[t] = !0) } function D(t) { !1 !== c[t] && (e.disable(t), c[t] = !1) } I[3553] = O(3553, 3553, 1), I[34067] = O(34067, 34069, 6), o.setClear(0, 0, 0, 1), s.setClear(1), l.setClear(0), N(2929), s.setFunc(ht), H(!1), G(Pe), N(2884), B(Be); var F = (_defineProperty(r = {}, qe, 32774), _defineProperty(r, Xe, 32778), _defineProperty(r, Ye, 32779), r); if (a) F[Je] = 32775, F[Ze] = 32776; else { var U = t.get("EXT_blend_minmax"); null !== U && (F[Je] = U.MIN_EXT, F[Ze] = U.MAX_EXT) } var z = (_defineProperty(i = {}, Ke, 0), _defineProperty(i, Qe, 1), _defineProperty(i, $e, 768), _defineProperty(i, tt, 770), _defineProperty(i, st, 776), _defineProperty(i, at, 774), _defineProperty(i, rt, 772), _defineProperty(i, et, 769), _defineProperty(i, nt, 771), _defineProperty(i, ot, 775), _defineProperty(i, it, 773), i); function B(t, n, r, i, a, o, s, l) { if (t !== Be) { if (h || (N(3042), h = !0), t === We) a = a || n, o = o || r, s = s || i, n === p && a === v || (e.blendEquationSeparate(F[n], F[a]), p = n, v = a), r === f && i === m && o === g && s === y || (e.blendFuncSeparate(z[r], z[i], z[o], z[s]), f = r, m = i, g = o, y = s), d = t, b = null; else if (t !== d || l !== b) { if (p === qe && v === qe || (e.blendEquation(32774), p = qe, v = qe), l) switch (t) { case He: e.blendFuncSeparate(1, 771, 1, 771); break; case Ge: e.blendFunc(1, 1); break; case Ve: e.blendFuncSeparate(0, 0, 769, 771); break; case je: e.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) { case He: e.blendFuncSeparate(770, 771, 1, 771); break; case Ge: e.blendFunc(770, 1); break; case Ve: e.blendFunc(0, 769); break; case je: e.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) }f = null, m = null, g = null, y = null, d = t, b = l } } else h && (D(3042), h = !1) } function H(t) { x !== t && (t ? e.frontFace(2304) : e.frontFace(2305), x = t) } function G(t) { t !== Ce ? (N(2884), t !== _ && (t === Pe ? e.cullFace(1029) : t === Oe ? e.cullFace(1028) : e.cullFace(1032))) : D(2884), _ = t } function V(t, n, r) { t ? (N(32823), M === n && S === r || (e.polygonOffset(n, r), M = n, S = r)) : D(32823) } function j(t) { void 0 === t && (t = 33984 + T - 1), k !== t && (e.activeTexture(t), k = t) } return { buffers: { color: o, depth: s, stencil: l }, enable: N, disable: D, useProgram: function (t) { return u !== t && (e.useProgram(t), u = t, !0) }, setBlending: B, setMaterial: function (e, t) { e.side === ze ? D(2884) : N(2884); var n = e.side === Ue; t && (n = !n), H(n), e.blending === He && !1 === e.transparent ? B(Be) : B(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), o.setMask(e.colorWrite); var r = e.stencilWrite; l.setTest(r), r && (l.setMask(e.stencilWriteMask), l.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), l.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), V(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits) }, setFlipSided: H, setCullFace: G, setLineWidth: function (t) { t !== w && (E && e.lineWidth(t), w = t) }, setPolygonOffset: V, setScissorTest: function (e) { e ? N(3089) : D(3089) }, activeTexture: j, bindTexture: function (t, n) { null === k && j(); var r = L[k]; void 0 === r && (r = { type: void 0, texture: void 0 }, L[k] = r), r.type === t && r.texture === n || (e.bindTexture(t, n || I[t]), r.type = t, r.texture = n) }, unbindTexture: function () { var t = L[k]; void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0) }, compressedTexImage2D: function () { try { e.compressedTexImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { e.texImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { e.texImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (t) { !1 === C.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), C.copy(t)) }, viewport: function (t) { !1 === P.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), P.copy(t)) }, reset: function () { c = {}, k = null, L = {}, u = null, d = null, x = null, _ = null, o.reset(), s.reset(), l.reset() } } } function fl(e, t, n, r, i, a, o) { var s, l, c, u = i.isWebGL2, h = i.maxTextures, d = i.maxCubemapSize, p = i.maxTextureSize, f = i.maxSamples, m = new WeakMap, v = !1; try { v = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (e) { } function g(e, t) { return v ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function y(e, t, n, r) { var i = 1; if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) { if ("undefined" != typeof HTMLImageElement && _instanceof(e, HTMLImageElement) || "undefined" != typeof HTMLCanvasElement && _instanceof(e, HTMLCanvasElement) || "undefined" != typeof ImageBitmap && _instanceof(e, ImageBitmap)) { var a = t ? Tr.floorPowerOfTwo : Math.floor, o = a(i * e.width), s = a(i * e.height); void 0 === c && (c = g(o, s)); var l = n ? g(o, s) : c; return l.width = o, l.height = s, l.getContext("2d").drawImage(e, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o + "x" + s + ")."), l } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e } return e } function b(e) { return Tr.isPowerOfTwo(e.width) && Tr.isPowerOfTwo(e.height) } function x(e, t) { return e.generateMipmaps && t && e.minFilter !== It && e.minFilter !== Ft } function _(t, n, i, a) { e.generateMipmap(t), r.get(n).__maxMipLevel = Math.log(Math.max(i, a)) * Math.LOG2E } function w(n, r, i) { if (!1 === u) return r; if (null !== n) { if (void 0 !== e[n]) return e[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } var a = r; return 6403 === r && (5126 === i && (a = 33326), 5131 === i && (a = 33325), 5121 === i && (a = 33321)), 6407 === r && (5126 === i && (a = 34837), 5131 === i && (a = 34843), 5121 === i && (a = 32849)), 6408 === r && (5126 === i && (a = 34836), 5131 === i && (a = 34842), 5121 === i && (a = 32856)), 33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a || t.get("EXT_color_buffer_float"), a } function M(e) { return e === It || e === Nt || e === Dt ? 9728 : 9729 } function S(t) { var n = t.target; n.removeEventListener("dispose", S), function (t) { var n = r.get(t); if (void 0 === n.__webglInit) return; e.deleteTexture(n.__webglTexture), r.remove(t) }(n), n.isVideoTexture && m.delete(n), o.memory.textures-- } function T(t) { var n = t.target; n.removeEventListener("dispose", T), function (t) { var n = r.get(t), i = r.get(t.texture); if (!t) return; void 0 !== i.__webglTexture && e.deleteTexture(i.__webglTexture); t.depthTexture && t.depthTexture.dispose(); if (t.isWebGLCubeRenderTarget) for (var a = 0; a < 6; a++)e.deleteFramebuffer(n.__webglFramebuffer[a]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[a]); else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && e.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer); r.remove(t.texture), r.remove(t) }(n), o.memory.textures-- } var E = 0; function A(e, t) { var i = r.get(e); if (e.isVideoTexture && function (e) { var t = o.render.frame; m.get(e) !== t && (m.set(e, t), e.update()) }(e), e.version > 0 && i.__version !== e.version) { var a = e.image; if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== a.complete) return void O(i, e, t); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.activeTexture(33984 + t), n.bindTexture(3553, i.__webglTexture) } function R(t, i) { var o = r.get(t); t.version > 0 && o.__version !== t.version ? function (t, r, i) { if (6 !== r.image.length) return; P(t, r), n.activeTexture(33984 + i), n.bindTexture(34067, t.__webglTexture), e.pixelStorei(37440, r.flipY); for (var o = r && (r.isCompressedTexture || r.image[0].isCompressedTexture), s = r.image[0] && r.image[0].isDataTexture, l = [], c = 0; c < 6; c++)l[c] = o || s ? s ? r.image[c].image : r.image[c] : y(r.image[c], !1, !0, d); var h, p = l[0], f = b(p) || u, m = a.convert(r.format), v = a.convert(r.type), g = w(r.internalFormat, m, v); if (C(34067, r, f), o) { for (var M = 0; M < 6; M++) { h = l[M].mipmaps; for (var S = 0; S < h.length; S++) { var T = h[S]; r.format !== en && r.format !== $t ? null !== m ? n.compressedTexImage2D(34069 + M, S, g, T.width, T.height, 0, T.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + M, S, g, T.width, T.height, 0, m, v, T.data) } } t.__maxMipLevel = h.length - 1 } else { h = r.mipmaps; for (var E = 0; E < 6; E++)if (s) { n.texImage2D(34069 + E, 0, g, l[E].width, l[E].height, 0, m, v, l[E].data); for (var A = 0; A < h.length; A++) { var R = h[A], k = R.image[E].image; n.texImage2D(34069 + E, A + 1, g, k.width, k.height, 0, m, v, k.data) } } else { n.texImage2D(34069 + E, 0, g, m, v, l[E]); for (var L = 0; L < h.length; L++) { var O = h[L]; n.texImage2D(34069 + E, L + 1, g, m, v, O.image[E]) } } t.__maxMipLevel = h.length } x(r, f) && _(34067, r, p.width, p.height); t.__version = r.version, r.onUpdate && r.onUpdate(r) }(o, t, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture)) } var k = (_defineProperty(s = {}, Ct, 10497), _defineProperty(s, Pt, 33071), _defineProperty(s, Ot, 33648), s), L = (_defineProperty(l = {}, It, 9728), _defineProperty(l, Nt, 9984), _defineProperty(l, Dt, 9986), _defineProperty(l, Ft, 9729), _defineProperty(l, Ut, 9985), _defineProperty(l, zt, 9987), l); function C(n, a, o) { o ? (e.texParameteri(n, 10242, k[a.wrapS]), e.texParameteri(n, 10243, k[a.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, k[a.wrapR]), e.texParameteri(n, 10240, L[a.magFilter]), e.texParameteri(n, 10241, L[a.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), a.wrapS === Pt && a.wrapT === Pt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, M(a.magFilter)), e.texParameteri(n, 10241, M(a.minFilter)), a.minFilter !== It && a.minFilter !== Ft && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")); var s = t.get("EXT_texture_filter_anisotropic"); if (s) { if (a.type === qt && null === t.get("OES_texture_float_linear")) return; if (a.type === Xt && null === (u || t.get("OES_texture_half_float_linear"))) return; (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy) } } function P(t, n) { void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", S), t.__webglTexture = e.createTexture(), o.memory.textures++) } function O(t, r, i) { var o = 3553; r.isDataTexture2DArray && (o = 35866), r.isDataTexture3D && (o = 32879), P(t, r), n.activeTexture(33984 + i), n.bindTexture(o, t.__webglTexture), e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment); var s, l = function (e) { return !u && (e.wrapS !== Pt || e.wrapT !== Pt || e.minFilter !== It && e.minFilter !== Ft) }(r) && !1 === b(r.image), c = y(r.image, l, !1, p), h = b(c) || u, d = a.convert(r.format), f = a.convert(r.type), m = w(r.internalFormat, d, f); C(o, r, h); var v = r.mipmaps; if (r.isDepthTexture) m = 6402, u ? m = r.type === qt ? 36012 : r.type === Wt ? 33190 : r.type === Kt ? 35056 : 33189 : r.type === qt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === an && 6402 === m && r.type !== Vt && r.type !== Wt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Vt, f = a.convert(r.type)), r.format === on && 6402 === m && (m = 34041, r.type !== Kt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Kt, f = a.convert(r.type))), n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null); else if (r.isDataTexture) if (v.length > 0 && h) { for (var g = 0, M = v.length; g < M; g++)s = v[g], n.texImage2D(3553, g, m, s.width, s.height, 0, d, f, s.data); r.generateMipmaps = !1, t.__maxMipLevel = v.length - 1 } else n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data), t.__maxMipLevel = 0; else if (r.isCompressedTexture) { for (var S = 0, T = v.length; S < T; S++)s = v[S], r.format !== en && r.format !== $t ? null !== d ? n.compressedTexImage2D(3553, S, m, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, S, m, s.width, s.height, 0, d, f, s.data); t.__maxMipLevel = v.length - 1 } else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), t.__maxMipLevel = 0; else if (r.isDataTexture3D) n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), t.__maxMipLevel = 0; else if (v.length > 0 && h) { for (var E = 0, A = v.length; E < A; E++)s = v[E], n.texImage2D(3553, E, m, d, f, s); r.generateMipmaps = !1, t.__maxMipLevel = v.length - 1 } else n.texImage2D(3553, 0, m, d, f, c), t.__maxMipLevel = 0; x(r, h) && _(o, r, c.width, c.height), t.__version = r.version, r.onUpdate && r.onUpdate(r) } function I(t, i, o, s) { var l = a.convert(i.texture.format), c = a.convert(i.texture.type), u = w(i.texture.internalFormat, l, c); n.texImage2D(s, 0, u, i.width, i.height, 0, l, c, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, o, s, r.get(i.texture).__webglTexture, 0), e.bindFramebuffer(36160, null) } function N(t, n, r) { if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) { var i = 33189; if (r) { var o = n.depthTexture; o && o.isDepthTexture && (o.type === qt ? i = 36012 : o.type === Wt && (i = 33190)); var s = F(n); e.renderbufferStorageMultisample(36161, s, i, n.width, n.height) } else e.renderbufferStorage(36161, i, n.width, n.height); e.framebufferRenderbuffer(36160, 36096, 36161, t) } else if (n.depthBuffer && n.stencilBuffer) { if (r) { var l = F(n); e.renderbufferStorageMultisample(36161, l, 35056, n.width, n.height) } else e.renderbufferStorage(36161, 34041, n.width, n.height); e.framebufferRenderbuffer(36160, 33306, 36161, t) } else { var c = a.convert(n.texture.format), u = a.convert(n.texture.type), h = w(n.texture.internalFormat, c, u); if (r) { var d = F(n); e.renderbufferStorageMultisample(36161, d, h, n.width, n.height) } else e.renderbufferStorage(36161, h, n.width, n.height) } e.bindRenderbuffer(36161, null) } function D(t) { var n = r.get(t), i = !0 === t.isWebGLCubeRenderTarget; if (t.depthTexture) { if (i) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, n) { if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (e.bindFramebuffer(36160, t), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); r.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), A(n.depthTexture, 0); var i = r.get(n.depthTexture).__webglTexture; if (n.depthTexture.format === an) e.framebufferTexture2D(36160, 36096, 3553, i, 0); else { if (n.depthTexture.format !== on) throw new Error("Unknown depthTexture format"); e.framebufferTexture2D(36160, 33306, 3553, i, 0) } }(n.__webglFramebuffer, t) } else if (i) { n.__webglDepthbuffer = []; for (var a = 0; a < 6; a++)e.bindFramebuffer(36160, n.__webglFramebuffer[a]), n.__webglDepthbuffer[a] = e.createRenderbuffer(), N(n.__webglDepthbuffer[a], t, !1) } else e.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = e.createRenderbuffer(), N(n.__webglDepthbuffer, t, !1); e.bindFramebuffer(36160, null) } function F(e) { return u && e.isWebGLMultisampleRenderTarget ? Math.min(f, e.samples) : 0 } var U = !1, z = !1; this.allocateTextureUnit = function () { var e = E; return e >= h && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + h), E += 1, e }, this.resetTextureUnits = function () { E = 0 }, this.setTexture2D = A, this.setTexture2DArray = function (e, t) { var i = r.get(e); e.version > 0 && i.__version !== e.version ? O(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, i.__webglTexture)) }, this.setTexture3D = function (e, t) { var i = r.get(e); e.version > 0 && i.__version !== e.version ? O(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, i.__webglTexture)) }, this.setTextureCube = R, this.setupRenderTarget = function (t) { var i = r.get(t), s = r.get(t.texture); t.addEventListener("dispose", T), s.__webglTexture = e.createTexture(), o.memory.textures++; var l = !0 === t.isWebGLCubeRenderTarget, c = !0 === t.isWebGLMultisampleRenderTarget, h = b(t) || u; if (!u || t.texture.format !== $t || t.texture.type !== qt && t.texture.type !== Xt || (t.texture.format = en, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), l) { i.__webglFramebuffer = []; for (var d = 0; d < 6; d++)i.__webglFramebuffer[d] = e.createFramebuffer() } else if (i.__webglFramebuffer = e.createFramebuffer(), c) if (u) { i.__webglMultisampledFramebuffer = e.createFramebuffer(), i.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, i.__webglColorRenderbuffer); var p = a.convert(t.texture.format), f = a.convert(t.texture.type), m = w(t.texture.internalFormat, p, f), v = F(t); e.renderbufferStorageMultisample(36161, v, m, t.width, t.height), e.bindFramebuffer(36160, i.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, i.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (i.__webglDepthRenderbuffer = e.createRenderbuffer(), N(i.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (l) { n.bindTexture(34067, s.__webglTexture), C(34067, t.texture, h); for (var g = 0; g < 6; g++)I(i.__webglFramebuffer[g], t, 36064, 34069 + g); x(t.texture, h) && _(34067, t.texture, t.width, t.height), n.bindTexture(34067, null) } else n.bindTexture(3553, s.__webglTexture), C(3553, t.texture, h), I(i.__webglFramebuffer, t, 36064, 3553), x(t.texture, h) && _(3553, t.texture, t.width, t.height), n.bindTexture(3553, null); t.depthBuffer && D(t) }, this.updateRenderTargetMipmap = function (e) { var t = e.texture; if (x(t, b(e) || u)) { var i = e.isWebGLCubeRenderTarget ? 34067 : 3553, a = r.get(t).__webglTexture; n.bindTexture(i, a), _(i, t, e.width, e.height), n.bindTexture(i, null) } }, this.updateMultisampleRenderTarget = function (t) { if (t.isWebGLMultisampleRenderTarget) if (u) { var n = r.get(t); e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, n.__webglFramebuffer); var i = t.width, a = t.height, o = 16384; t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024), e.blitFramebuffer(0, 0, i, a, 0, 0, i, a, o, 9728), e.bindFramebuffer(36160, n.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (e, t) { e && e.isWebGLRenderTarget && (!1 === U && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), U = !0), e = e.texture), A(e, t) }, this.safeSetTextureCube = function (e, t) { e && e.isWebGLCubeRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), z = !0), e = e.texture), R(e, t) } } function ml(e, t, n) { var r = n.isWebGL2; return { convert: function (e) { var n; if (e === Bt) return 5121; if (e === Yt) return 32819; if (e === Jt) return 32820; if (e === Zt) return 33635; if (e === Ht) return 5120; if (e === Gt) return 5122; if (e === Vt) return 5123; if (e === jt) return 5124; if (e === Wt) return 5125; if (e === qt) return 5126; if (e === Xt) return r ? 5131 : null !== (n = t.get("OES_texture_half_float")) ? n.HALF_FLOAT_OES : null; if (e === Qt) return 6406; if (e === $t) return 6407; if (e === en) return 6408; if (e === tn) return 6409; if (e === nn) return 6410; if (e === an) return 6402; if (e === on) return 34041; if (e === sn) return 6403; if (e === ln) return 36244; if (e === cn) return 33319; if (e === un) return 33320; if (e === hn) return 36248; if (e === dn) return 36249; if (e === pn || e === fn || e === mn || e === vn) { if (null === (n = t.get("WEBGL_compressed_texture_s3tc"))) return null; if (e === pn) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (e === fn) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (e === mn) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (e === vn) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (e === gn || e === yn || e === bn || e === xn) { if (null === (n = t.get("WEBGL_compressed_texture_pvrtc"))) return null; if (e === gn) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (e === yn) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (e === bn) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (e === xn) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (e === _n) return null !== (n = t.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null; if ((e === wn || e === Mn) && null !== (n = t.get("WEBGL_compressed_texture_etc"))) { if (e === wn) return n.COMPRESSED_RGB8_ETC2; if (e === Mn) return n.COMPRESSED_RGBA8_ETC2_EAC } return e === Sn || e === Tn || e === En || e === An || e === Rn || e === kn || e === Ln || e === Cn || e === Pn || e === On || e === In || e === Nn || e === Dn || e === Fn || e === zn || e === Bn || e === Hn || e === Gn || e === Vn || e === jn || e === Wn || e === qn || e === Xn || e === Yn || e === Jn || e === Zn || e === Kn || e === Qn ? null !== (n = t.get("WEBGL_compressed_texture_astc")) ? e : null : e === Un ? null !== (n = t.get("EXT_texture_compression_bptc")) ? e : null : e === Kt ? r ? 34042 : null !== (n = t.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0 } } } function vl(e) { ro.call(this), this.cameras = e || [] } function gl() { Ii.call(this), this.type = "Group" } function yl() { this._targetRay = null, this._grip = null, this._hand = null } function bl(e, t) { var n = this, r = null, i = 1, a = null, o = "local-floor", s = null, l = [], c = new Map, u = new ro; u.layers.enable(1), u.viewport = new Cr; var h = new ro; h.layers.enable(2), h.viewport = new Cr; var d = [u, h], p = new vl; p.layers.enable(1), p.layers.enable(2); var f = null, m = null; function v(e) { var t = c.get(e.inputSource); t && t.dispatchEvent({ type: e.type, data: e.inputSource }) } function g() { c.forEach(function (e, t) { e.disconnect(t) }), c.clear(), e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), S.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } function y(e) { a = e, S.setContext(r), S.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } function b(e) { for (var t = r.inputSources, n = 0; n < l.length; n++)c.set(t[n], l[n]); for (var i = 0; i < e.removed.length; i++) { var a = e.removed[i], o = c.get(a); o && (o.dispatchEvent({ type: "disconnected", data: a }), c.delete(a)) } for (var s = 0; s < e.added.length; s++) { var u = e.added[s], h = c.get(u); h && h.dispatchEvent({ type: "connected", data: u }) } } this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { var t = l[e]; return void 0 === t && (t = new yl, l[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { var t = l[e]; return void 0 === t && (t = new yl, l[e] = t), t.getGripSpace() }, this.getHand = function (e) { var t = l[e]; return void 0 === t && (t = new yl, l[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { i = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (e) { o = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return a }, this.getSession = function () { return r }, this.setSession = function (e) { if (null !== (r = e)) { r.addEventListener("select", v), r.addEventListener("selectstart", v), r.addEventListener("selectend", v), r.addEventListener("squeeze", v), r.addEventListener("squeezestart", v), r.addEventListener("squeezeend", v), r.addEventListener("end", g); var n = t.getContextAttributes(); !0 !== n.xrCompatible && t.makeXRCompatible(); var a = { antialias: n.antialias, alpha: n.alpha, depth: n.depth, stencil: n.stencil, framebufferScaleFactor: i }, s = new XRWebGLLayer(r, t, a); r.updateRenderState({ baseLayer: s }), r.requestReferenceSpace(o).then(y), r.addEventListener("inputsourceschange", b) } }; var x = new Nr, _ = new Nr; function w(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld) } this.getCamera = function (e) { p.near = h.near = u.near = e.near, p.far = h.far = u.far = e.far, f === p.near && m === p.far || (r.updateRenderState({ depthNear: p.near, depthFar: p.far }), f = p.near, m = p.far); var t = e.parent, n = p.cameras; w(p, t); for (var i = 0; i < n.length; i++)w(n[i], t); e.matrixWorld.copy(p.matrixWorld); for (var a = e.children, o = 0, s = a.length; o < s; o++)a[o].updateMatrixWorld(!0); return 2 === n.length ? function (e, t, n) { x.setFromMatrixPosition(t.matrixWorld), _.setFromMatrixPosition(n.matrixWorld); var r = x.distanceTo(_), i = t.projectionMatrix.elements, a = n.projectionMatrix.elements, o = i[14] / (i[10] - 1), s = i[14] / (i[10] + 1), l = (i[9] + 1) / i[5], c = (i[9] - 1) / i[5], u = (i[8] - 1) / i[0], h = (a[8] + 1) / a[0], d = o * u, p = o * h, f = r / (-u + h), m = f * -u; t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld); var v = o + f, g = s + f, y = d - m, b = p + (r - m), w = l * s / g * v, M = c * s / g * v; e.projectionMatrix.makePerspective(y, b, w, M, v, g) }(p, u, h) : p.projectionMatrix.copy(u.projectionMatrix), p }; var M = null; var S = new fo; S.setAnimationLoop(function (t, n) { if (null !== (s = n.getViewerPose(a))) { var i = s.views, o = r.renderState.baseLayer; e.setFramebuffer(o.framebuffer); var c = !1; i.length !== p.cameras.length && (p.cameras.length = 0, c = !0); for (var u = 0; u < i.length; u++) { var h = i[u], f = o.getViewport(h), m = d[u]; m.matrix.fromArray(h.transform.matrix), m.projectionMatrix.fromArray(h.projectionMatrix), m.viewport.set(f.x, f.y, f.width, f.height), 0 === u && p.matrix.copy(m.matrix), !0 === c && p.cameras.push(m) } } for (var v = r.inputSources, g = 0; g < l.length; g++) { var y = l[g], b = v[g]; y.update(b, n, a) } M && M(t, n) }), this.setAnimationLoop = function (e) { M = e }, this.dispose = function () { } } function xl(e) { function t(t, n) { t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap); var r, i, a = e.get(n).envMap; if (a) { t.envMap.value = a, t.flipEnvMap.value = a.isCubeTexture && a._needsFlipEnvMap ? -1 : 1, t.reflectivity.value = n.reflectivity, t.refractionRatio.value = n.refractionRatio; var o = e.get(a).__maxMipLevel; void 0 !== o && (t.maxMipLevel.value = o) } n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)), n.aoMap ? i = n.aoMap : n.lightMap && (i = n.lightMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uv2Transform.value.copy(i.matrix)) } function n(t, n) { t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, n.side === Ue && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), n.side === Ue && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias), e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity) } return { refreshFogUniforms: function (e, t) { e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density) }, refreshMaterialUniforms: function (e, r, i, a) { r.isMeshBasicMaterial ? t(e, r) : r.isMeshLambertMaterial ? (t(e, r), function (e, t) { t.emissiveMap && (e.emissiveMap.value = t.emissiveMap) }(e, r)) : r.isMeshToonMaterial ? (t(e, r), function (e, t) { t.gradientMap && (e.gradientMap.value = t.gradientMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Ue && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Ue && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshPhongMaterial ? (t(e, r), function (e, t) { e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Ue && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Ue && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshStandardMaterial ? (t(e, r), r.isMeshPhysicalMaterial ? function (e, t) { n(e, t), e.reflectivity.value = t.reflectivity, e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && e.sheen.value.copy(t.sheen), t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === Ue && e.clearcoatNormalScale.value.negate()), e.transmission.value = t.transmission, t.transmissionMap && (e.transmissionMap.value = t.transmissionMap) }(e, r) : n(e, r)) : r.isMeshMatcapMaterial ? (t(e, r), function (e, t) { t.matcap && (e.matcap.value = t.matcap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Ue && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Ue && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshDepthMaterial ? (t(e, r), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshDistanceMaterial ? (t(e, r), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance }(e, r)) : r.isMeshNormalMaterial ? (t(e, r), function (e, t) { t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Ue && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Ue && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isLineBasicMaterial ? (function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity }(e, r), r.isLineDashedMaterial && function (e, t) { e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale }(e, r)) : r.isPointsMaterial ? function (e, t, n, r) { var i; e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * r, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.map ? i = t.map : t.alphaMap && (i = t.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)) }(e, r, i, a) : r.isSpriteMaterial ? function (e, t) { var n; e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.map ? n = t.map : t.alphaMap && (n = t.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix)) }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1) } } } function _l(e) { var t = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), n = void 0 !== e.context ? e.context : null, r = void 0 !== e.alpha && e.alpha, i = void 0 === e.depth || e.depth, a = void 0 === e.stencil || e.stencil, o = void 0 !== e.antialias && e.antialias, s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, c = void 0 !== e.powerPreference ? e.powerPreference : "default", u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat, h = null, d = null; this.domElement = t, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = ir, this.physicallyCorrectLights = !1, this.toneMapping = bt, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; var p = this, f = !1, m = null, v = 0, g = 0, y = null, b = null, x = -1, _ = null, w = null, M = new Cr, S = new Cr, T = null, E = t.width, A = t.height, R = 1, k = null, L = null, C = new Cr(0, 0, E, A), P = new Cr(0, 0, E, A), O = !1, I = new po, N = !1, D = !1, F = new ci, U = new Nr, z = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function B() { return null === y ? R : 1 } var H, G, V, j, W, q, X, Y, J, Z, K, Q, $, ee, te, ne, re, ie, ae, oe, se, le = n; function ce(e, n) { for (var r = 0; r < e.length; r++) { var i = e[r], a = t.getContext(i, n); if (null !== a) return a } return null } try { var ue = { alpha: r, depth: i, stencil: a, antialias: o, premultipliedAlpha: s, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: u }; if (t.addEventListener("webglcontextlost", me, !1), t.addEventListener("webglcontextrestored", ve, !1), null === le) { var he = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === p.isWebGL1Renderer && he.shift(), null === (le = ce(he, ue))) throw ce(he) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === le.getShaderPrecisionFormat && (le.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } function de() { H = new Eo(le), !1 === (G = new Mo(le, H, e)).isWebGL2 && (H.get("WEBGL_depth_texture"), H.get("OES_texture_float"), H.get("OES_texture_half_float"), H.get("OES_texture_half_float_linear"), H.get("OES_standard_derivatives"), H.get("OES_element_index_uint"), H.get("OES_vertex_array_object"), H.get("ANGLE_instanced_arrays")), H.get("OES_texture_float_linear"), oe = new ml(le, H, G), (V = new pl(le, H, G)).scissor(S.copy(P).multiplyScalar(R).floor()), V.viewport(M.copy(C).multiplyScalar(R).floor()), j = new ko(le), W = new Ks, q = new fl(le, H, V, W, G, oe, j), X = new To(p), Y = new mo(le, G), se = new _o(le, H, Y, G), J = new Ao(le, Y, j, se), Z = new Oo(le, J, Y, j), re = new Po(le), te = new So(W), K = new Zs(p, X, H, G, se, te), Q = new xl(W), $ = new tl(W), ee = new sl, ne = new xo(p, X, V, Z, s), ie = new wo(le, H, j, G), ae = new Ro(le, H, j, G), j.programs = K.programs, p.capabilities = G, p.extensions = H, p.properties = W, p.renderLists = $, p.state = V, p.info = j } de(); var pe = new bl(p, le); this.xr = pe; var fe = new dl(p, Z, G.maxTextureSize); function me(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), f = !0 } function ve() { console.log("THREE.WebGLRenderer: Context Restored."), f = !1, de() } function ge(e) { var t = e.target; t.removeEventListener("dispose", ge), function (e) { ye(e), W.remove(e) }(t) } function ye(e) { var t = W.get(e).program; void 0 !== t && K.releaseProgram(t) } this.shadowMap = fe, this.getContext = function () { return le }, this.getContextAttributes = function () { return le.getContextAttributes() }, this.forceContextLoss = function () { var e = H.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { var e = H.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return R }, this.setPixelRatio = function (e) { void 0 !== e && (R = e, this.setSize(E, A, !1)) }, this.getSize = function (e) { return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new Er), e.set(E, A) }, this.setSize = function (e, n, r) { pe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = e, A = n, t.width = Math.floor(e * R), t.height = Math.floor(n * R), !1 !== r && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n)) }, this.getDrawingBufferSize = function (e) { return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new Er), e.set(E * R, A * R).floor() }, this.setDrawingBufferSize = function (e, n, r) { E = e, A = n, R = r, t.width = Math.floor(e * r), t.height = Math.floor(n * r), this.setViewport(0, 0, e, n) }, this.getCurrentViewport = function (e) { return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new Cr), e.copy(M) }, this.getViewport = function (e) { return e.copy(C) }, this.setViewport = function (e, t, n, r) { e.isVector4 ? C.set(e.x, e.y, e.z, e.w) : C.set(e, t, n, r), V.viewport(M.copy(C).multiplyScalar(R).floor()) }, this.getScissor = function (e) { return e.copy(P) }, this.setScissor = function (e, t, n, r) { e.isVector4 ? P.set(e.x, e.y, e.z, e.w) : P.set(e, t, n, r), V.scissor(S.copy(P).multiplyScalar(R).floor()) }, this.getScissorTest = function () { return O }, this.setScissorTest = function (e) { V.setScissorTest(O = e) }, this.setOpaqueSort = function (e) { k = e }, this.setTransparentSort = function (e) { L = e }, this.getClearColor = function () { return ne.getClearColor() }, this.setClearColor = function () { ne.setClearColor.apply(ne, arguments) }, this.getClearAlpha = function () { return ne.getClearAlpha() }, this.setClearAlpha = function () { ne.setClearAlpha.apply(ne, arguments) }, this.clear = function (e, t, n) { var r = 0; (void 0 === e || e) && (r |= 16384), (void 0 === t || t) && (r |= 256), (void 0 === n || n) && (r |= 1024), le.clear(r) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", me, !1), t.removeEventListener("webglcontextrestored", ve, !1), $.dispose(), ee.dispose(), W.dispose(), X.dispose(), Z.dispose(), se.dispose(), pe.dispose(), xe.stop() }, this.renderBufferImmediate = function (e, t) { se.initAttributes(); var n = W.get(e); e.hasPositions && !n.position && (n.position = le.createBuffer()), e.hasNormals && !n.normal && (n.normal = le.createBuffer()), e.hasUvs && !n.uv && (n.uv = le.createBuffer()), e.hasColors && !n.color && (n.color = le.createBuffer()); var r = t.getAttributes(); e.hasPositions && (le.bindBuffer(34962, n.position), le.bufferData(34962, e.positionArray, 35048), se.enableAttribute(r.position), le.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), e.hasNormals && (le.bindBuffer(34962, n.normal), le.bufferData(34962, e.normalArray, 35048), se.enableAttribute(r.normal), le.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (le.bindBuffer(34962, n.uv), le.bufferData(34962, e.uvArray, 35048), se.enableAttribute(r.uv), le.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), e.hasColors && (le.bindBuffer(34962, n.color), le.bufferData(34962, e.colorArray, 35048), se.enableAttribute(r.color), le.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), se.disableUnusedAttributes(), le.drawArrays(4, 0, e.count), e.count = 0 }, this.renderBufferDirect = function (e, t, n, r, i, a) { null === t && (t = z); var o = i.isMesh && i.matrixWorld.determinant() < 0, s = Se(e, t, r, i); V.setMaterial(r, o); var l = n.index, c = n.attributes.position; if (null === l) { if (void 0 === c || 0 === c.count) return } else if (0 === l.count) return; var u, h = 1; !0 === r.wireframe && (l = J.getWireframeAttribute(n), h = 2), (r.morphTargets || r.morphNormals) && re.update(i, n, r, s), se.setup(i, r, s, n, l); var d = ie; null !== l && (u = Y.get(l), (d = ae).setIndex(u)); var p = null !== l ? l.count : c.count, f = n.drawRange.start * h, m = n.drawRange.count * h, v = null !== a ? a.start * h : 0, g = null !== a ? a.count * h : 1 / 0, y = Math.max(f, v), b = Math.min(p, f + m, v + g) - 1, x = Math.max(0, b - y + 1); if (0 !== x) { if (i.isMesh) !0 === r.wireframe ? (V.setLineWidth(r.wireframeLinewidth * B()), d.setMode(1)) : d.setMode(4); else if (i.isLine) { var _ = r.linewidth; void 0 === _ && (_ = 1), V.setLineWidth(_ * B()), i.isLineSegments ? d.setMode(1) : i.isLineLoop ? d.setMode(2) : d.setMode(3) } else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4); if (i.isInstancedMesh) d.renderInstances(y, x, i.count); else if (n.isInstancedBufferGeometry) { var w = Math.min(n.instanceCount, n._maxInstanceCount); d.renderInstances(y, x, w) } else d.render(y, x) } }, this.compile = function (e, t) { (d = ee.get(e, t)).init(), e.traverse(function (e) { e.isLight && (d.pushLight(e), e.castShadow && d.pushShadow(e)) }), d.setupLights(t); var n = new WeakMap; e.traverse(function (t) { var r = t.material; if (r) if (Array.isArray(r)) for (var i = 0; i < r.length; i++) { var a = r[i]; !1 === n.has(a) && (Me(a, e, t), n.set(a)) } else !1 === n.has(r) && (Me(r, e, t), n.set(r)) }) }; var be = null; var xe = new fo; function _e(e, t, n) { for (var r = !0 === t.isScene ? t.overrideMaterial : null, i = 0, a = e.length; i < a; i++) { var o = e[i], s = o.object, l = o.geometry, c = null === r ? o.material : r, u = o.group; if (n.isArrayCamera) { w = n; for (var h = n.cameras, p = 0, f = h.length; p < f; p++) { var m = h[p]; s.layers.test(m.layers) && (V.viewport(M.copy(m.viewport)), d.setupLights(m), we(s, t, m, l, c, u)) } } else w = null, we(s, t, n, l, c, u) } } function we(e, t, n, r, i, a) { if (e.onBeforeRender(p, t, n, r, i, a), d = ee.get(t, w || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) { var o = Se(n, t, i, e); V.setMaterial(i), se.reset(), function (e, t) { e.render(function (e) { p.renderBufferImmediate(e, t) }) }(e, o) } else p.renderBufferDirect(n, t, r, i, e, a); e.onAfterRender(p, t, n, r, i, a), d = ee.get(t, w || n) } function Me(e, t, n) { !0 !== t.isScene && (t = z); var r = W.get(e), i = d.state.lights, a = d.state.shadowsArray, o = i.state.version, s = K.getParameters(e, i.state, a, t, n), l = K.getProgramCacheKey(s), c = r.program, u = !0; if (void 0 === c) e.addEventListener("dispose", ge); else if (c.cacheKey !== l) ye(e); else if (r.lightsStateVersion !== o) u = !1; else { if (void 0 !== s.shaderID) { var h = e.isMeshStandardMaterial ? t.environment : null; return void (r.envMap = X.get(e.envMap || h)) } u = !1 } u && (s.uniforms = K.getUniforms(e), e.onBeforeCompile(s, p), c = K.acquireProgram(s, l), r.program = c, r.uniforms = s.uniforms, r.outputEncoding = s.outputEncoding); var f = r.uniforms; (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (r.numClippingPlanes = te.numPlanes, r.numIntersection = te.numIntersection, f.clippingPlanes = te.uniform), r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = X.get(e.envMap || r.environment), r.needsLights = function (e) { return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights }(e), r.lightsStateVersion = o, r.needsLights && (f.ambientLightColor.value = i.state.ambient, f.lightProbe.value = i.state.probe, f.directionalLights.value = i.state.directional, f.directionalLightShadows.value = i.state.directionalShadow, f.spotLights.value = i.state.spot, f.spotLightShadows.value = i.state.spotShadow, f.rectAreaLights.value = i.state.rectArea, f.ltc_1.value = i.state.rectAreaLTC1, f.ltc_2.value = i.state.rectAreaLTC2, f.pointLights.value = i.state.point, f.pointLightShadows.value = i.state.pointShadow, f.hemisphereLights.value = i.state.hemi, f.directionalShadowMap.value = i.state.directionalShadowMap, f.directionalShadowMatrix.value = i.state.directionalShadowMatrix, f.spotShadowMap.value = i.state.spotShadowMap, f.spotShadowMatrix.value = i.state.spotShadowMatrix, f.pointShadowMap.value = i.state.pointShadowMap, f.pointShadowMatrix.value = i.state.pointShadowMatrix); var m = r.program.getUniforms(), v = Ls.seqWithValue(m.seq, f); r.uniformsList = v } function Se(e, t, n, r) { !0 !== t.isScene && (t = z), q.resetTextureUnits(); var i = t.fog, a = n.isMeshStandardMaterial ? t.environment : null, o = null === y ? p.outputEncoding : y.texture.encoding, s = X.get(n.envMap || a), l = W.get(n), c = d.state.lights; if (!0 === N && (!0 === D || e !== _)) { var u = e === _ && n.id === x; te.setState(n, e, u) } n.version === l.__version ? n.fog && l.fog !== i ? Me(n, t, r) : l.environment !== a ? Me(n, t, r) : l.needsLights && l.lightsStateVersion !== c.state.version ? Me(n, t, r) : void 0 === l.numClippingPlanes || l.numClippingPlanes === te.numPlanes && l.numIntersection === te.numIntersection ? l.outputEncoding !== o ? Me(n, t, r) : l.envMap !== s && Me(n, t, r) : Me(n, t, r) : (Me(n, t, r), l.__version = n.version); var h, f, m = !1, v = !1, g = !1, b = l.program, w = b.getUniforms(), M = l.uniforms; if (V.useProgram(b.program) && (m = !0, v = !0, g = !0), n.id !== x && (x = n.id, v = !0), m || _ !== e) { if (w.setValue(le, "projectionMatrix", e.projectionMatrix), G.logarithmicDepthBuffer && w.setValue(le, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), _ !== e && (_ = e, v = !0, g = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) { var S = w.map.cameraPosition; void 0 !== S && S.setValue(le, U.setFromMatrixPosition(e.matrixWorld)) } (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && w.setValue(le, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && w.setValue(le, "viewMatrix", e.matrixWorldInverse) } if (n.skinning) { w.setOptional(le, r, "bindMatrix"), w.setOptional(le, r, "bindMatrixInverse"); var T = r.skeleton; if (T) { var E = T.bones; if (G.floatVertexTextures) { if (void 0 === T.boneTexture) { var k = Math.sqrt(4 * E.length); k = Tr.ceilPowerOfTwo(k), k = Math.max(k, 4); var L = new Float32Array(k * k * 4); L.set(T.boneMatrices); var C = new co(L, k, k, en, qt); T.boneMatrices = L, T.boneTexture = C, T.boneTextureSize = k } w.setValue(le, "boneTexture", T.boneTexture, q), w.setValue(le, "boneTextureSize", T.boneTextureSize) } else w.setOptional(le, T, "boneMatrices") } } return (v || l.receiveShadow !== r.receiveShadow) && (l.receiveShadow = r.receiveShadow, w.setValue(le, "receiveShadow", r.receiveShadow)), v && (w.setValue(le, "toneMappingExposure", p.toneMappingExposure), l.needsLights && (f = g, (h = M).ambientLightColor.needsUpdate = f, h.lightProbe.needsUpdate = f, h.directionalLights.needsUpdate = f, h.directionalLightShadows.needsUpdate = f, h.pointLights.needsUpdate = f, h.pointLightShadows.needsUpdate = f, h.spotLights.needsUpdate = f, h.spotLightShadows.needsUpdate = f, h.rectAreaLights.needsUpdate = f, h.hemisphereLights.needsUpdate = f), i && n.fog && Q.refreshFogUniforms(M, i), Q.refreshMaterialUniforms(M, n, R, A), Ls.upload(le, l.uniformsList, M, q)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Ls.upload(le, l.uniformsList, M, q), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && w.setValue(le, "center", r.center), w.setValue(le, "modelViewMatrix", r.modelViewMatrix), w.setValue(le, "normalMatrix", r.normalMatrix), w.setValue(le, "modelMatrix", r.matrixWorld), b } xe.setAnimationLoop(function (e) { pe.isPresenting || be && be(e) }), "undefined" != typeof window && xe.setContext(window), this.setAnimationLoop = function (e) { be = e, pe.setAnimationLoop(e), null === e ? xe.stop() : xe.start() }, this.render = function (e, t) { var n, r; if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), void 0 === t || !0 === t.isCamera) { if (!0 !== f) { se.resetDefaultState(), x = -1, _ = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === pe.enabled && !0 === pe.isPresenting && (t = pe.getCamera(t)), !0 === e.isScene && e.onBeforeRender(p, e, t, n || y), (d = ee.get(e, t)).init(), F.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), I.setFromProjectionMatrix(F), D = this.localClippingEnabled, N = te.init(this.clippingPlanes, D, t), (h = $.get(e, t)).init(), function e(t, n, r, i) { if (!1 === t.visible) return; var a = t.layers.test(n.layers); if (a) if (t.isGroup) r = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(n); else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t); else if (t.isSprite) { if (!t.frustumCulled || I.intersectsSprite(t)) { i && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F); var o = Z.update(t), s = t.material; s.visible && h.push(t, o, s, r, U.z, null) } } else if (t.isImmediateRenderObject) i && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F), h.push(t, null, t.material, r, U.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== j.render.frame && (t.skeleton.update(), t.skeleton.frame = j.render.frame), !t.frustumCulled || I.intersectsObject(t))) { i && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F); var l = Z.update(t), c = t.material; if (Array.isArray(c)) for (var u = l.groups, p = 0, f = u.length; p < f; p++) { var m = u[p], v = c[m.materialIndex]; v && v.visible && h.push(t, l, v, r, U.z, m) } else c.visible && h.push(t, l, c, r, U.z, null) } var g = t.children; for (var y = 0, b = g.length; y < b; y++)e(g[y], n, r, i) }(e, t, 0, p.sortObjects), h.finish(), !0 === p.sortObjects && h.sort(k, L), !0 === N && te.beginShadows(); var i = d.state.shadowsArray; fe.render(i, e, t), d.setupLights(t), !0 === N && te.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), ne.render(h, e, t, r); var a = h.opaque, o = h.transparent; a.length > 0 && _e(a, e, t), o.length > 0 && _e(o, e, t), !0 === e.isScene && e.onAfterRender(p, e, t), null !== y && (q.updateRenderTargetMipmap(y), q.updateMultisampleRenderTarget(y)), V.buffers.depth.setTest(!0), V.buffers.depth.setMask(!0), V.buffers.color.setMask(!0), V.setPolygonOffset(!1), h = null, d = null } } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.") }, this.setFramebuffer = function (e) { m !== e && null === y && le.bindFramebuffer(36160, e), m = e }, this.getActiveCubeFace = function () { return v }, this.getActiveMipmapLevel = function () { return g }, this.getRenderList = function () { return h }, this.setRenderList = function (e) { h = e }, this.getRenderState = function () { return d }, this.setRenderState = function (e) { d = e }, this.getRenderTarget = function () { return y }, this.setRenderTarget = function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; y = e, v = t, g = n, e && void 0 === W.get(e).__webglFramebuffer && q.setupRenderTarget(e); var r = m, i = !1; if (e) { var a = W.get(e).__webglFramebuffer; e.isWebGLCubeRenderTarget ? (r = a[t], i = !0) : r = e.isWebGLMultisampleRenderTarget ? W.get(e).__webglMultisampledFramebuffer : a, M.copy(e.viewport), S.copy(e.scissor), T = e.scissorTest } else M.copy(C).multiplyScalar(R).floor(), S.copy(P).multiplyScalar(R).floor(), T = O; if (b !== r && (le.bindFramebuffer(36160, r), b = r), V.viewport(M), V.scissor(S), V.setScissorTest(T), i) { var o = W.get(e.texture); le.framebufferTexture2D(36160, 36064, 34069 + t, o.__webglTexture, n) } }, this.readRenderTargetPixels = function (e, t, n, r, i, a, o) { if (e && e.isWebGLRenderTarget) { var s = W.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) { var l = !1; s !== b && (le.bindFramebuffer(36160, s), l = !0); try { var c = e.texture, u = c.format, h = c.type; if (u !== en && oe.convert(u) !== le.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); if (!(h === Bt || oe.convert(h) === le.getParameter(35738) || h === qt && (G.isWebGL2 || H.get("OES_texture_float") || H.get("WEBGL_color_buffer_float")) || h === Xt && (G.isWebGL2 ? H.get("EXT_color_buffer_float") : H.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === le.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && le.readPixels(t, n, r, i, oe.convert(u), oe.convert(h), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { l && le.bindFramebuffer(36160, b) } } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") }, this.copyFramebufferToTexture = function (e, t, n) { void 0 === n && (n = 0); var r = Math.pow(2, -n), i = Math.floor(t.image.width * r), a = Math.floor(t.image.height * r), o = oe.convert(t.format); q.setTexture2D(t, 0), le.copyTexImage2D(3553, n, o, e.x, e.y, i, a, 0), V.unbindTexture() }, this.copyTextureToTexture = function (e, t, n, r) { void 0 === r && (r = 0); var i = t.image.width, a = t.image.height, o = oe.convert(n.format), s = oe.convert(n.type); q.setTexture2D(n, 0), le.pixelStorei(37440, n.flipY), le.pixelStorei(37441, n.premultiplyAlpha), le.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? le.texSubImage2D(3553, r, e.x, e.y, i, a, o, s, t.image.data) : t.isCompressedTexture ? le.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : le.texSubImage2D(3553, r, e.x, e.y, o, s, t.image), 0 === r && n.generateMipmaps && le.generateMipmap(3553), V.unbindTexture() }, this.initTexture = function (e) { q.setTexture2D(e, 0), V.unbindTexture() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } function wl(e) { _l.call(this, e) } vl.prototype = Object.assign(Object.create(ro.prototype), { constructor: vl, isArrayCamera: !0 }), gl.prototype = Object.assign(Object.create(Ii.prototype), { constructor: gl, isGroup: !0 }), Object.assign(yl.prototype, { constructor: yl, getHandSpace: function () { if (null === this._hand && (this._hand = new gl, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = { pinching: !1 }, window.XRHand)) for (var e = 0; e <= window.XRHand.LITTLE_PHALANX_TIP; e++) { var t = new gl; t.matrixAutoUpdate = !1, t.visible = !1, this._hand.joints.push(t), this._hand.add(t) } return this._hand }, getTargetRaySpace: function () { return null === this._targetRay && (this._targetRay = new gl, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay }, getGripSpace: function () { return null === this._grip && (this._grip = new gl, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip }, dispatchEvent: function (e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this }, disconnect: function (e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this }, update: function (e, t, n) { var r = null, i = null, a = null, o = this._targetRay, s = this._grip, l = this._hand; if (e) if (l && e.hand) { a = !0; for (var c = 0; c <= window.XRHand.LITTLE_PHALANX_TIP; c++)if (e.hand[c]) { var u = t.getJointPose(e.hand[c], n), h = l.joints[c]; null !== u && (h.matrix.fromArray(u.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), h.jointRadius = u.radius), h.visible = null !== u; var d = l.joints[window.XRHand.INDEX_PHALANX_TIP], p = l.joints[window.XRHand.THUMB_PHALANX_TIP], f = d.position.distanceTo(p.position); l.inputState.pinching && f > .025 ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && f <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } } else null !== o && null !== (r = t.getPose(e.targetRaySpace, n)) && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale)), null !== s && e.gripSpace && null !== (i = t.getPose(e.gripSpace, n)) && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale)); return null !== o && (o.visible = null !== r), null !== s && (s.visible = null !== i), null !== l && (l.visible = null !== a), this } }), Object.assign(bl.prototype, xr.prototype), wl.prototype = Object.assign(Object.create(_l.prototype), { constructor: wl, isWebGL1Renderer: !0 }); var Ml = function (e) { _inherits(n, Ii); var t = _createSuper(n); function n() { var e; return _classCallCheck(this, n), e = t.call(this), Object.defineProperty(_assertThisInitialized(e), "isScene", { value: !0 }), e.type = "Scene", e.background = null, e.environment = null, e.fog = null, e.overrideMaterial = null, e.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: _assertThisInitialized(e) })), e } return _createClass(n, [{ key: "copy", value: function (e, t) { return _get(_getPrototypeOf(n.prototype), "copy", this).call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this } }, { key: "toJSON", value: function (e) { var t = _get(_getPrototypeOf(n.prototype), "toJSON", this).call(this, e); return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.environment && (t.object.environment = this.environment.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t } }]), n }(); function Sl(e, t) { this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = yr, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Tr.generateUUID() } Object.defineProperty(Sl.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }), Object.assign(Sl.prototype, { isInterleavedBuffer: !0, onUploadCallback: function () { }, setUsage: function (e) { return this.usage = e, this }, copy: function (e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this }, copyAt: function (e, t, n) { e *= this.stride, n *= t.stride; for (var r = 0, i = this.stride; r < i; r++)this.array[e + r] = t.array[n + r]; return this }, set: function (e, t) { return void 0 === t && (t = 0), this.array.set(e, t), this }, clone: function (e) { void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Tr.generateUUID()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); var t = new Sl(new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), this.stride); return t.setUsage(this.usage), t }, onUpload: function (e) { return this.onUploadCallback = e, this }, toJSON: function (e) { return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Tr.generateUUID()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } }); var Tl, El = new Nr; function Al(e, t, n, r) { this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r } function Rl(e) { aa.call(this), this.type = "SpriteMaterial", this.color = new na(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e) } Object.defineProperties(Al.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } }, needsUpdate: { set: function (e) { this.data.needsUpdate = e } } }), Object.assign(Al.prototype, { isInterleavedBufferAttribute: !0, applyMatrix4: function (e) { for (var t = 0, n = this.data.count; t < n; t++)El.x = this.getX(t), El.y = this.getY(t), El.z = this.getZ(t), El.applyMatrix4(e), this.setXYZ(t, El.x, El.y, El.z); return this }, setX: function (e, t) { return this.data.array[e * this.data.stride + this.offset] = t, this }, setY: function (e, t) { return this.data.array[e * this.data.stride + this.offset + 1] = t, this }, setZ: function (e, t) { return this.data.array[e * this.data.stride + this.offset + 2] = t, this }, setW: function (e, t) { return this.data.array[e * this.data.stride + this.offset + 3] = t, this }, getX: function (e) { return this.data.array[e * this.data.stride + this.offset] }, getY: function (e) { return this.data.array[e * this.data.stride + this.offset + 1] }, getZ: function (e) { return this.data.array[e * this.data.stride + this.offset + 2] }, getW: function (e) { return this.data.array[e * this.data.stride + this.offset + 3] }, setXY: function (e, t, n) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this }, setXYZ: function (e, t, n, r) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this }, setXYZW: function (e, t, n, r, i) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this }, clone: function (e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); for (var t = [], n = 0; n < this.count; n++)for (var r = n * this.data.stride + this.offset, i = 0; i < this.itemSize; i++)t.push(this.data.array[r + i]); return new ca(new this.array.constructor(t), this.itemSize, this.normalized) } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Al(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) }, toJSON: function (e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); for (var t = [], n = 0; n < this.count; n++)for (var r = n * this.data.stride + this.offset, i = 0; i < this.itemSize; i++)t.push(this.data.array[r + i]); return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } }), Rl.prototype = Object.create(aa.prototype), Rl.prototype.constructor = Rl, Rl.prototype.isSpriteMaterial = !0, Rl.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this }; var kl = new Nr, Ll = new Nr, Cl = new Nr, Pl = new Er, Ol = new Er, Il = new ci, Nl = new Nr, Dl = new Nr, Fl = new Nr, Ul = new Er, zl = new Er, Bl = new Er; function Hl(e) { if (Ii.call(this), this.type = "Sprite", void 0 === Tl) { Tl = new Ra; var t = new Sl(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5); Tl.setIndex([0, 1, 2, 0, 2, 3]), Tl.setAttribute("position", new Al(t, 3, 0, !1)), Tl.setAttribute("uv", new Al(t, 2, 3, !1)) } this.geometry = Tl, this.material = void 0 !== e ? e : new Rl, this.center = new Er(.5, .5) } function Gl(e, t, n, r, i, a) { Pl.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (Ol.x = a * Pl.x - i * Pl.y, Ol.y = i * Pl.x + a * Pl.y) : Ol.copy(Pl), e.copy(t), e.x += Ol.x, e.y += Ol.y, e.applyMatrix4(Il) } Hl.prototype = Object.assign(Object.create(Ii.prototype), { constructor: Hl, isSprite: !0, raycast: function (e, t) { null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Ll.setFromMatrixScale(this.matrixWorld), Il.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Cl.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Ll.multiplyScalar(-Cl.z); var n, r, i = this.material.rotation; 0 !== i && (r = Math.cos(i), n = Math.sin(i)); var a = this.center; Gl(Nl.set(-.5, -.5, 0), Cl, a, Ll, n, r), Gl(Dl.set(.5, -.5, 0), Cl, a, Ll, n, r), Gl(Fl.set(.5, .5, 0), Cl, a, Ll, n, r), Ul.set(0, 0), zl.set(1, 0), Bl.set(1, 1); var o = e.ray.intersectTriangle(Nl, Dl, Fl, !1, kl); if (null !== o || (Gl(Dl.set(-.5, .5, 0), Cl, a, Ll, n, r), zl.set(0, 1), null !== (o = e.ray.intersectTriangle(Nl, Fl, Dl, !1, kl)))) { var s = e.ray.origin.distanceTo(kl); s < e.near || s > e.far || t.push({ distance: s, point: kl.clone(), uv: Ji.getUV(kl, Nl, Dl, Fl, Ul, zl, Bl, new Er), face: null, object: this }) } }, copy: function (e) { return Ii.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this } }); var Vl, jl, Wl, ql, Xl, Yl = new Nr, Jl = new Nr; function Zl() { Ii.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), this.autoUpdate = !0 } function Kl(e, t) { e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), qa.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new ci, this.bindMatrixInverse = new ci } Zl.prototype = Object.assign(Object.create(Ii.prototype), { constructor: Zl, isLOD: !0, copy: function (e) { Ii.prototype.copy.call(this, e, !1); for (var t = e.levels, n = 0, r = t.length; n < r; n++) { var i = t[n]; this.addLevel(i.object.clone(), i.distance) } return this.autoUpdate = e.autoUpdate, this }, addLevel: function (e, t) { void 0 === t && (t = 0), t = Math.abs(t); var n, r = this.levels; for (n = 0; n < r.length && !(t < r[n].distance); n++); return r.splice(n, 0, { distance: t, object: e }), this.add(e), this }, getCurrentLevel: function () { return this._currentLevel }, getObjectForDistance: function (e) { var t = this.levels; if (t.length > 0) { var n, r; for (n = 1, r = t.length; n < r && !(e < t[n].distance); n++); return t[n - 1].object } return null }, raycast: function (e, t) { if (this.levels.length > 0) { Yl.setFromMatrixPosition(this.matrixWorld); var n = e.ray.origin.distanceTo(Yl); this.getObjectForDistance(n).raycast(e, t) } }, update: function (e) { var t = this.levels; if (t.length > 1) { Yl.setFromMatrixPosition(e.matrixWorld), Jl.setFromMatrixPosition(this.matrixWorld); var n, r, i = Yl.distanceTo(Jl) / e.zoom; for (t[0].object.visible = !0, n = 1, r = t.length; n < r && i >= t[n].distance; n++)t[n - 1].object.visible = !1, t[n].object.visible = !0; for (this._currentLevel = n - 1; n < r; n++)t[n].object.visible = !1 } }, toJSON: function (e) { var t = Ii.prototype.toJSON.call(this, e); !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = []; for (var n = this.levels, r = 0, i = n.length; r < i; r++) { var a = n[r]; t.object.levels.push({ object: a.object.uuid, distance: a.distance }) } return t } }), Kl.prototype = Object.assign(Object.create(qa.prototype), { constructor: Kl, isSkinnedMesh: !0, copy: function (e) { return qa.prototype.copy.call(this, e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this }, bind: function (e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { for (var e = new Cr, t = this.geometry.attributes.skinWeight, n = 0, r = t.count; n < r; n++) { e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n); var i = 1 / e.manhattanLength(); i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w) } }, updateMatrixWorld: function (e) { qa.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, boneTransform: (Vl = new Nr, jl = new Cr, Wl = new Cr, ql = new Nr, Xl = new ci, function (e, t) { var n = this.skeleton, r = this.geometry; jl.fromBufferAttribute(r.attributes.skinIndex, e), Wl.fromBufferAttribute(r.attributes.skinWeight, e), Vl.fromBufferAttribute(r.attributes.position, e).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (var i = 0; i < 4; i++) { var a = Wl.getComponent(i); if (0 !== a) { var o = jl.getComponent(i); Xl.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(ql.copy(Vl).applyMatrix4(Xl), a) } } return t.applyMatrix4(this.bindMatrixInverse) }) }); var Ql = new ci, $l = new ci; function ec(e, t) { if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === t) this.calculateInverses(); else if (this.bones.length === t.length) this.boneInverses = t.slice(0); else { console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = []; for (var n = 0, r = this.bones.length; n < r; n++)this.boneInverses.push(new ci) } } function tc() { Ii.call(this), this.type = "Bone" } Object.assign(ec.prototype, { calculateInverses: function () { this.boneInverses = []; for (var e = 0, t = this.bones.length; e < t; e++) { var n = new ci; this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n) } }, pose: function () { for (var e = 0, t = this.bones.length; e < t; e++) { var n = this.bones[e]; n && n.matrixWorld.getInverse(this.boneInverses[e]) } for (var r = 0, i = this.bones.length; r < i; r++) { var a = this.bones[r]; a && (a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale)) } }, update: function () { for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, a = e.length; i < a; i++) { var o = e[i] ? e[i].matrixWorld : $l; Ql.multiplyMatrices(o, t[i]), Ql.toArray(n, 16 * i) } void 0 !== r && (r.needsUpdate = !0) }, clone: function () { return new ec(this.bones, this.boneInverses) }, getBoneByName: function (e) { for (var t = 0, n = this.bones.length; t < n; t++) { var r = this.bones[t]; if (r.name === e) return r } }, dispose: function () { this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0) } }), tc.prototype = Object.assign(Object.create(Ii.prototype), { constructor: tc, isBone: !0 }); var nc = new ci, rc = new ci, ic = [], ac = new qa; function oc(e, t, n) { qa.call(this, e, t), this.instanceMatrix = new ca(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1 } function sc(e) { aa.call(this), this.type = "LineBasicMaterial", this.color = new na(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(e) } oc.prototype = Object.assign(Object.create(qa.prototype), { constructor: oc, isInstancedMesh: !0, copy: function (e) { return qa.prototype.copy.call(this, e), this.instanceMatrix.copy(e.instanceMatrix), this.count = e.count, this }, setColorAt: function (e, t) { null === this.instanceColor && (this.instanceColor = new ca(new Float32Array(3 * this.count), 3)), t.toArray(this.instanceColor.array, 3 * e) }, getMatrixAt: function (e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) }, raycast: function (e, t) { var n = this.matrixWorld, r = this.count; if (ac.geometry = this.geometry, ac.material = this.material, void 0 !== ac.material) for (var i = 0; i < r; i++) { this.getMatrixAt(i, nc), rc.multiplyMatrices(n, nc), ac.matrixWorld = rc, ac.raycast(e, ic); for (var a = 0, o = ic.length; a < o; a++) { var s = ic[a]; s.instanceId = i, s.object = this, t.push(s) } ic.length = 0 } }, setMatrixAt: function (e, t) { t.toArray(this.instanceMatrix.array, 16 * e) }, updateMorphTargets: function () { } }), sc.prototype = Object.create(aa.prototype), sc.prototype.constructor = sc, sc.prototype.isLineBasicMaterial = !0, sc.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, this }; var lc = new Nr, cc = new Nr, uc = new ci, hc = new li, dc = new ei; function pc(e, t, n) { 1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Ii.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new Ra, this.material = void 0 !== t ? t : new sc, this.updateMorphTargets() } pc.prototype = Object.assign(Object.create(Ii.prototype), { constructor: pc, isLine: !0, copy: function (e) { return Ii.prototype.copy.call(this, e), this.material = e.material, this.geometry = e.geometry, this }, computeLineDistances: function () { var e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { for (var t = e.attributes.position, n = [0], r = 1, i = t.count; r < i; r++)lc.fromBufferAttribute(t, r - 1), cc.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += lc.distanceTo(cc); e.setAttribute("lineDistance", new ga(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (e.isGeometry) { var a = e.vertices, o = e.lineDistances; o[0] = 0; for (var s = 1, l = a.length; s < l; s++)o[s] = o[s - 1], o[s] += a[s - 1].distanceTo(a[s]) } return this }, raycast: function (e, t) { var n = this.geometry, r = this.matrixWorld, i = e.params.Line.threshold; if (null === n.boundingSphere && n.computeBoundingSphere(), dc.copy(n.boundingSphere), dc.applyMatrix4(r), dc.radius += i, !1 !== e.ray.intersectsSphere(dc)) { uc.getInverse(r), hc.copy(e.ray).applyMatrix4(uc); var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a, s = new Nr, l = new Nr, c = new Nr, u = new Nr, h = this.isLineSegments ? 2 : 1; if (n.isBufferGeometry) { var d = n.index, p = n.attributes.position; if (null !== d) for (var f = d.array, m = 0, v = f.length - 1; m < v; m += h) { var g = f[m], y = f[m + 1]; if (s.fromBufferAttribute(p, g), l.fromBufferAttribute(p, y), !(hc.distanceSqToSegment(s, l, u, c) > o)) { u.applyMatrix4(this.matrixWorld); var b = e.ray.origin.distanceTo(u); b < e.near || b > e.far || t.push({ distance: b, point: c.clone().applyMatrix4(this.matrixWorld), index: m, face: null, faceIndex: null, object: this }) } } else for (var x = 0, _ = p.count - 1; x < _; x += h) { if (s.fromBufferAttribute(p, x), l.fromBufferAttribute(p, x + 1), !(hc.distanceSqToSegment(s, l, u, c) > o)) { u.applyMatrix4(this.matrixWorld); var w = e.ray.origin.distanceTo(u); w < e.near || w > e.far || t.push({ distance: w, point: c.clone().applyMatrix4(this.matrixWorld), index: x, face: null, faceIndex: null, object: this }) } } } else if (n.isGeometry) for (var M = n.vertices, S = M.length, T = 0; T < S - 1; T += h) { if (!(hc.distanceSqToSegment(M[T], M[T + 1], u, c) > o)) { u.applyMatrix4(this.matrixWorld); var E = e.ray.origin.distanceTo(u); E < e.near || E > e.far || t.push({ distance: E, point: c.clone().applyMatrix4(this.matrixWorld), index: T, face: null, faceIndex: null, object: this }) } } } }, updateMorphTargets: function () { var e = this.geometry; if (e.isBufferGeometry) { var t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { var r = t[n[0]]; if (void 0 !== r) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (var i = 0, a = r.length; i < a; i++) { var o = r[i].name || String(i); this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i } } } } else { var s = e.morphTargets; void 0 !== s && s.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }); var fc = new Nr, mc = new Nr; function vc(e, t) { pc.call(this, e, t), this.type = "LineSegments" } function gc(e, t) { pc.call(this, e, t), this.type = "LineLoop" } function yc(e) { aa.call(this), this.type = "PointsMaterial", this.color = new na(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e) } vc.prototype = Object.assign(Object.create(pc.prototype), { constructor: vc, isLineSegments: !0, computeLineDistances: function () { var e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { for (var t = e.attributes.position, n = [], r = 0, i = t.count; r < i; r += 2)fc.fromBufferAttribute(t, r), mc.fromBufferAttribute(t, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + fc.distanceTo(mc); e.setAttribute("lineDistance", new ga(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (e.isGeometry) for (var a = e.vertices, o = e.lineDistances, s = 0, l = a.length; s < l; s += 2)fc.copy(a[s]), mc.copy(a[s + 1]), o[s] = 0 === s ? 0 : o[s - 1], o[s + 1] = o[s] + fc.distanceTo(mc); return this } }), gc.prototype = Object.assign(Object.create(pc.prototype), { constructor: gc, isLineLoop: !0 }), yc.prototype = Object.create(aa.prototype), yc.prototype.constructor = yc, yc.prototype.isPointsMaterial = !0, yc.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this }; var bc = new ci, xc = new li, _c = new ei, wc = new Nr; function Mc(e, t) { Ii.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new Ra, this.material = void 0 !== t ? t : new yc, this.updateMorphTargets() } function Sc(e, t, n, r, i, a, o) { var s = xc.distanceSqToPoint(e); if (s < n) { var l = new Nr; xc.closestPointToPoint(e, l), l.applyMatrix4(r); var c = i.ray.origin.distanceTo(l); if (c < i.near || c > i.far) return; a.push({ distance: c, distanceToRay: Math.sqrt(s), point: l, index: t, face: null, object: o }) } } function Tc(e, t, n, r, i, a, o, s, l) { Lr.call(this, e, t, n, r, i, a, o, s, l), this.format = void 0 !== o ? o : $t, this.minFilter = void 0 !== a ? a : Ft, this.magFilter = void 0 !== i ? i : Ft, this.generateMipmaps = !1; var c = this; "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(function t() { c.needsUpdate = !0, e.requestVideoFrameCallback(t) }) } function Ec(e, t, n, r, i, a, o, s, l, c, u, h) { Lr.call(this, null, a, o, s, l, c, r, i, u, h), this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } function Ac(e, t, n, r, i, a, o, s, l) { Lr.call(this, e, t, n, r, i, a, o, s, l), this.needsUpdate = !0 } function Rc(e, t, n, r, i, a, o, s, l, c) { if ((c = void 0 !== c ? c : an) !== an && c !== on) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && c === an && (n = Vt), void 0 === n && c === on && (n = Kt), Lr.call(this, null, r, i, a, o, s, c, n, l), this.image = { width: e, height: t }, this.magFilter = void 0 !== o ? o : It, this.minFilter = void 0 !== s ? s : It, this.flipY = !1, this.generateMipmaps = !1 } Mc.prototype = Object.assign(Object.create(Ii.prototype), { constructor: Mc, isPoints: !0, copy: function (e) { return Ii.prototype.copy.call(this, e), this.material = e.material, this.geometry = e.geometry, this }, raycast: function (e, t) { var n = this.geometry, r = this.matrixWorld, i = e.params.Points.threshold; if (null === n.boundingSphere && n.computeBoundingSphere(), _c.copy(n.boundingSphere), _c.applyMatrix4(r), _c.radius += i, !1 !== e.ray.intersectsSphere(_c)) { bc.getInverse(r), xc.copy(e.ray).applyMatrix4(bc); var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a; if (n.isBufferGeometry) { var s = n.index, l = n.attributes.position; if (null !== s) for (var c = s.array, u = 0, h = c.length; u < h; u++) { var d = c[u]; wc.fromBufferAttribute(l, d), Sc(wc, d, o, r, e, t, this) } else for (var p = 0, f = l.count; p < f; p++)wc.fromBufferAttribute(l, p), Sc(wc, p, o, r, e, t, this) } else for (var m = n.vertices, v = 0, g = m.length; v < g; v++)Sc(m[v], v, o, r, e, t, this) } }, updateMorphTargets: function () { var e = this.geometry; if (e.isBufferGeometry) { var t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { var r = t[n[0]]; if (void 0 !== r) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (var i = 0, a = r.length; i < a; i++) { var o = r[i].name || String(i); this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = i } } } } else { var s = e.morphTargets; void 0 !== s && s.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }), Tc.prototype = Object.assign(Object.create(Lr.prototype), { constructor: Tc, isVideoTexture: !0, update: function () { var e = this.image; !1 === "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }), Ec.prototype = Object.create(Lr.prototype), Ec.prototype.constructor = Ec, Ec.prototype.isCompressedTexture = !0, Ac.prototype = Object.create(Lr.prototype), Ac.prototype.constructor = Ac, Ac.prototype.isCanvasTexture = !0, Rc.prototype = Object.create(Lr.prototype), Rc.prototype.constructor = Rc, Rc.prototype.isDepthTexture = !0; var kc = 0, Lc = new ci, Cc = new Ii, Pc = new Nr; function Oc() { Object.defineProperty(this, "id", { value: kc += 2 }), this.uuid = Tr.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1 } Oc.prototype = Object.assign(Object.create(xr.prototype), { constructor: Oc, isGeometry: !0, applyMatrix4: function (e) { for (var t = (new Ar).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) { this.vertices[n].applyMatrix4(e) } for (var i = 0, a = this.faces.length; i < a; i++) { var o = this.faces[i]; o.normal.applyMatrix3(t).normalize(); for (var s = 0, l = o.vertexNormals.length; s < l; s++)o.vertexNormals[s].applyMatrix3(t).normalize() } return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this }, rotateX: function (e) { return Lc.makeRotationX(e), this.applyMatrix4(Lc), this }, rotateY: function (e) { return Lc.makeRotationY(e), this.applyMatrix4(Lc), this }, rotateZ: function (e) { return Lc.makeRotationZ(e), this.applyMatrix4(Lc), this }, translate: function (e, t, n) { return Lc.makeTranslation(e, t, n), this.applyMatrix4(Lc), this }, scale: function (e, t, n) { return Lc.makeScale(e, t, n), this.applyMatrix4(Lc), this }, lookAt: function (e) { return Cc.lookAt(e), Cc.updateMatrix(), this.applyMatrix4(Cc.matrix), this }, fromBufferGeometry: function (e) { var t = this, n = null !== e.index ? e.index : void 0, r = e.attributes; if (void 0 === r.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this; var i = r.position, a = r.normal, o = r.color, s = r.uv, l = r.uv2; void 0 !== l && (this.faceVertexUvs[1] = []); for (var c = 0; c < i.count; c++)t.vertices.push((new Nr).fromBufferAttribute(i, c)), void 0 !== o && t.colors.push((new na).fromBufferAttribute(o, c)); function u(e, n, r, i) { var c = void 0 === o ? [] : [t.colors[e].clone(), t.colors[n].clone(), t.colors[r].clone()], u = void 0 === a ? [] : [(new Nr).fromBufferAttribute(a, e), (new Nr).fromBufferAttribute(a, n), (new Nr).fromBufferAttribute(a, r)], h = new ra(e, n, r, u, c, i); t.faces.push(h), void 0 !== s && t.faceVertexUvs[0].push([(new Er).fromBufferAttribute(s, e), (new Er).fromBufferAttribute(s, n), (new Er).fromBufferAttribute(s, r)]), void 0 !== l && t.faceVertexUvs[1].push([(new Er).fromBufferAttribute(l, e), (new Er).fromBufferAttribute(l, n), (new Er).fromBufferAttribute(l, r)]) } var h = e.groups; if (h.length > 0) for (var d = 0; d < h.length; d++)for (var p = h[d], f = p.start, m = f, v = f + p.count; m < v; m += 3)void 0 !== n ? u(n.getX(m), n.getX(m + 1), n.getX(m + 2), p.materialIndex) : u(m, m + 1, m + 2, p.materialIndex); else if (void 0 !== n) for (var g = 0; g < n.count; g += 3)u(n.getX(g), n.getX(g + 1), n.getX(g + 2)); else for (var y = 0; y < i.count; y += 3)u(y, y + 1, y + 2); return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(Pc).negate(), this.translate(Pc.x, Pc.y, Pc.z), this }, normalize: function () { this.computeBoundingSphere(); var e = this.boundingSphere.center, t = this.boundingSphere.radius, n = 0 === t ? 1 : 1 / t, r = new ci; return r.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix4(r), this }, computeFaceNormals: function () { for (var e = new Nr, t = new Nr, n = 0, r = this.faces.length; n < r; n++) { var i = this.faces[n], a = this.vertices[i.a], o = this.vertices[i.b], s = this.vertices[i.c]; e.subVectors(s, o), t.subVectors(a, o), e.cross(t), e.normalize(), i.normal.copy(e) } }, computeVertexNormals: function (e) { void 0 === e && (e = !0); for (var t = new Array(this.vertices.length), n = 0, r = this.vertices.length; n < r; n++)t[n] = new Nr; if (e) for (var i = new Nr, a = new Nr, o = 0, s = this.faces.length; o < s; o++) { var l = this.faces[o], c = this.vertices[l.a], u = this.vertices[l.b], h = this.vertices[l.c]; i.subVectors(h, u), a.subVectors(c, u), i.cross(a), t[l.a].add(i), t[l.b].add(i), t[l.c].add(i) } else { this.computeFaceNormals(); for (var d = 0, p = this.faces.length; d < p; d++) { var f = this.faces[d]; t[f.a].add(f.normal), t[f.b].add(f.normal), t[f.c].add(f.normal) } } for (var m = 0, v = this.vertices.length; m < v; m++)t[m].normalize(); for (var g = 0, y = this.faces.length; g < y; g++) { var b = this.faces[g], x = b.vertexNormals; 3 === x.length ? (x[0].copy(t[b.a]), x[1].copy(t[b.b]), x[2].copy(t[b.c])) : (x[0] = t[b.a].clone(), x[1] = t[b.b].clone(), x[2] = t[b.c].clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeFlatVertexNormals: function () { this.computeFaceNormals(); for (var e = 0, t = this.faces.length; e < t; e++) { var n = this.faces[e], r = n.vertexNormals; 3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function () { for (var e = 0, t = this.faces.length; e < t; e++) { var n = this.faces[e]; n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []); for (var r = 0, i = n.vertexNormals.length; r < i; r++)n.__originalVertexNormals[r] ? n.__originalVertexNormals[r].copy(n.vertexNormals[r]) : n.__originalVertexNormals[r] = n.vertexNormals[r].clone() } var a = new Oc; a.faces = this.faces; for (var o = 0, s = this.morphTargets.length; o < s; o++) { if (!this.morphNormals[o]) { this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = []; for (var l = this.morphNormals[o].faceNormals, c = this.morphNormals[o].vertexNormals, u = 0, h = this.faces.length; u < h; u++) { var d = new Nr, p = { a: new Nr, b: new Nr, c: new Nr }; l.push(d), c.push(p) } } var f = this.morphNormals[o]; a.vertices = this.morphTargets[o].vertices, a.computeFaceNormals(), a.computeVertexNormals(); for (var m = 0, v = this.faces.length; m < v; m++) { var g = this.faces[m], y = f.faceNormals[m], b = f.vertexNormals[m]; y.copy(g.normal), b.a.copy(g.vertexNormals[0]), b.b.copy(g.vertexNormals[1]), b.c.copy(g.vertexNormals[2]) } } for (var x = 0, _ = this.faces.length; x < _; x++) { var w = this.faces[x]; w.normal = w.__originalFaceNormal, w.vertexNormals = w.__originalVertexNormals } }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Ur), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new ei), this.boundingSphere.setFromPoints(this.vertices) }, merge: function (e, t, n) { if (e && e.isGeometry) { var r, i = this.vertices.length, a = this.vertices, o = e.vertices, s = this.faces, l = e.faces, c = this.colors, u = e.colors; void 0 === n && (n = 0), void 0 !== t && (r = (new Ar).getNormalMatrix(t)); for (var h = 0, d = o.length; h < d; h++) { var p = o[h].clone(); void 0 !== t && p.applyMatrix4(t), a.push(p) } for (var f = 0, m = u.length; f < m; f++)c.push(u[f].clone()); for (var v = 0, g = l.length; v < g; v++) { var y = l[v], b = void 0, x = void 0, _ = y.vertexNormals, w = y.vertexColors, M = new ra(y.a + i, y.b + i, y.c + i); M.normal.copy(y.normal), void 0 !== r && M.normal.applyMatrix3(r).normalize(); for (var S = 0, T = _.length; S < T; S++)b = _[S].clone(), void 0 !== r && b.applyMatrix3(r).normalize(), M.vertexNormals.push(b); M.color.copy(y.color); for (var E = 0, A = w.length; E < A; E++)x = w[E], M.vertexColors.push(x.clone()); M.materialIndex = y.materialIndex + n, s.push(M) } for (var R = 0, k = e.faceVertexUvs.length; R < k; R++) { var L = e.faceVertexUvs[R]; void 0 === this.faceVertexUvs[R] && (this.faceVertexUvs[R] = []); for (var C = 0, P = L.length; C < P; C++) { for (var O = L[C], I = [], N = 0, D = O.length; N < D; N++)I.push(O[N].clone()); this.faceVertexUvs[R].push(I) } } } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e) }, mergeMesh: function (e) { e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e) }, mergeVertices: function () { for (var e = {}, t = [], n = [], r = Math.pow(10, 4), i = 0, a = this.vertices.length; i < a; i++) { var o = this.vertices[i], s = Math.round(o.x * r) + "_" + Math.round(o.y * r) + "_" + Math.round(o.z * r); void 0 === e[s] ? (e[s] = i, t.push(this.vertices[i]), n[i] = t.length - 1) : n[i] = n[e[s]] } for (var l = [], c = 0, u = this.faces.length; c < u; c++) { var h = this.faces[c]; h.a = n[h.a], h.b = n[h.b], h.c = n[h.c]; for (var d = [h.a, h.b, h.c], p = 0; p < 3; p++)if (d[p] === d[(p + 1) % 3]) { l.push(c); break } } for (var f = l.length - 1; f >= 0; f--) { var m = l[f]; this.faces.splice(m, 1); for (var v = 0, g = this.faceVertexUvs.length; v < g; v++)this.faceVertexUvs[v].splice(m, 1) } var y = this.vertices.length - t.length; return this.vertices = t, y }, setFromPoints: function (e) { this.vertices = []; for (var t = 0, n = e.length; t < n; t++) { var r = e[t]; this.vertices.push(new Nr(r.x, r.y, r.z || 0)) } return this }, sortFacesByMaterialIndex: function () { for (var e = this.faces, t = e.length, n = 0; n < t; n++)e[n]._id = n; e.sort(function (e, t) { return e.materialIndex - t.materialIndex }); var r, i, a = this.faceVertexUvs[0], o = this.faceVertexUvs[1]; a && a.length === t && (r = []), o && o.length === t && (i = []); for (var s = 0; s < t; s++) { var l = e[s]._id; r && r.push(a[l]), i && i.push(o[l]) } r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i) }, toJSON: function () { var e = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) { var t = this.parameters; for (var n in t) void 0 !== t[n] && (e[n] = t[n]); return e } for (var r = [], i = 0; i < this.vertices.length; i++) { var a = this.vertices[i]; r.push(a.x, a.y, a.z) } for (var o = [], s = [], l = {}, c = [], u = {}, h = [], d = {}, p = 0; p < this.faces.length; p++) { var f = this.faces[p], m = void 0 !== this.faceVertexUvs[0][p], v = f.normal.length() > 0, g = f.vertexNormals.length > 0, y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b, b = f.vertexColors.length > 0, x = 0; if (x = S(x, 0, 0), x = S(x, 1, !0), x = S(x, 2, !1), x = S(x, 3, m), x = S(x, 4, v), x = S(x, 5, g), x = S(x, 6, y), x = S(x, 7, b), o.push(x), o.push(f.a, f.b, f.c), o.push(f.materialIndex), m) { var _ = this.faceVertexUvs[0][p]; o.push(A(_[0]), A(_[1]), A(_[2])) } if (v && o.push(T(f.normal)), g) { var w = f.vertexNormals; o.push(T(w[0]), T(w[1]), T(w[2])) } if (y && o.push(E(f.color)), b) { var M = f.vertexColors; o.push(E(M[0]), E(M[1]), E(M[2])) } } function S(e, t, n) { return n ? e | 1 << t : e & ~(1 << t) } function T(e) { var t = e.x.toString() + e.y.toString() + e.z.toString(); return void 0 !== l[t] ? l[t] : (l[t] = s.length / 3, s.push(e.x, e.y, e.z), l[t]) } function E(e) { var t = e.r.toString() + e.g.toString() + e.b.toString(); return void 0 !== u[t] ? u[t] : (u[t] = c.length, c.push(e.getHex()), u[t]) } function A(e) { var t = e.x.toString() + e.y.toString(); return void 0 !== d[t] ? d[t] : (d[t] = h.length / 2, h.push(e.x, e.y), d[t]) } return e.data = {}, e.data.vertices = r, e.data.normals = s, c.length > 0 && (e.data.colors = c), h.length > 0 && (e.data.uvs = [h]), e.data.faces = o, e }, clone: function () { return (new Oc).copy(this) }, copy: function (e) { this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name; for (var t = e.vertices, n = 0, r = t.length; n < r; n++)this.vertices.push(t[n].clone()); for (var i = e.colors, a = 0, o = i.length; a < o; a++)this.colors.push(i[a].clone()); for (var s = e.faces, l = 0, c = s.length; l < c; l++)this.faces.push(s[l].clone()); for (var u = 0, h = e.faceVertexUvs.length; u < h; u++) { var d = e.faceVertexUvs[u]; void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []); for (var p = 0, f = d.length; p < f; p++) { for (var m = d[p], v = [], g = 0, y = m.length; g < y; g++) { var b = m[g]; v.push(b.clone()) } this.faceVertexUvs[u].push(v) } } for (var x = e.morphTargets, _ = 0, w = x.length; _ < w; _++) { var M = {}; if (M.name = x[_].name, void 0 !== x[_].vertices) { M.vertices = []; for (var S = 0, T = x[_].vertices.length; S < T; S++)M.vertices.push(x[_].vertices[S].clone()) } if (void 0 !== x[_].normals) { M.normals = []; for (var E = 0, A = x[_].normals.length; E < A; E++)M.normals.push(x[_].normals[E].clone()) } this.morphTargets.push(M) } for (var R = e.morphNormals, k = 0, L = R.length; k < L; k++) { var C = {}; if (void 0 !== R[k].vertexNormals) { C.vertexNormals = []; for (var P = 0, O = R[k].vertexNormals.length; P < O; P++) { var I = R[k].vertexNormals[P], N = {}; N.a = I.a.clone(), N.b = I.b.clone(), N.c = I.c.clone(), C.vertexNormals.push(N) } } if (void 0 !== R[k].faceNormals) { C.faceNormals = []; for (var D = 0, F = R[k].faceNormals.length; D < F; D++)C.faceNormals.push(R[k].faceNormals[D].clone()) } this.morphNormals.push(C) } for (var U = e.skinWeights, z = 0, B = U.length; z < B; z++)this.skinWeights.push(U[z].clone()); for (var H = e.skinIndices, G = 0, V = H.length; G < V; G++)this.skinIndices.push(H[G].clone()); for (var j = e.lineDistances, W = 0, q = j.length; W < q; W++)this.lineDistances.push(j[W]); var X = e.boundingBox; null !== X && (this.boundingBox = X.clone()); var Y = e.boundingSphere; return null !== Y && (this.boundingSphere = Y.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); new Nr, new Nr, new Nr, new Ji; var Ic = function (e, t, n) { n = n || 2; var r, i, a, o, s, l, c, u = t && t.length, h = u ? t[0] * n : e.length, d = Nc(e, 0, h, n, !0), p = []; if (!d || d.next === d.prev) return p; if (u && (d = function (e, t, n, r) { var i, a, o, s, l, c = []; for (i = 0, a = t.length; i < a; i++)o = t[i] * r, s = i < a - 1 ? t[i + 1] * r : e.length, (l = Nc(e, o, s, r, !1)) === l.next && (l.steiner = !0), c.push(qc(l)); for (c.sort(Gc), i = 0; i < c.length; i++)Vc(c[i], n), n = Dc(n, n.next); return n }(e, t, d, n)), e.length > 80 * n) { r = a = e[0], i = o = e[1]; for (var f = n; f < h; f += n)(s = e[f]) < r && (r = s), (l = e[f + 1]) < i && (i = l), s > a && (a = s), l > o && (o = l); c = 0 !== (c = Math.max(a - r, o - i)) ? 1 / c : 0 } return Fc(d, p, n, r, i, c), p }; function Nc(e, t, n, r, i) { var a, o; if (i === function (e, t, n, r) { for (var i = 0, a = t, o = n - r; a < n; a += r)i += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a; return i }(e, t, n, r) > 0) for (a = t; a < n; a += r)o = nu(a, e[a], e[a + 1], o); else for (a = n - r; a >= t; a -= r)o = nu(a, e[a], e[a + 1], o); return o && Zc(o, o.next) && (ru(o), o = o.next), o } function Dc(e, t) { if (!e) return e; t || (t = e); var n, r = e; do { if (n = !1, r.steiner || !Zc(r, r.next) && 0 !== Jc(r.prev, r, r.next)) r = r.next; else { if (ru(r), (r = t = r.prev) === r.next) break; n = !0 } } while (n || r !== t); return t } function Fc(e, t, n, r, i, a, o) { if (e) { !o && a && function (e, t, n, r) { var i = e; do { null === i.z && (i.z = Wc(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== e); i.prevZ.nextZ = null, i.prevZ = null, function (e) { var t, n, r, i, a, o, s, l, c = 1; do { for (n = e, e = null, a = null, o = 0; n;) { for (o++, r = n, s = 0, t = 0; t < c && (s++, r = r.nextZ); t++); for (l = c; s > 0 || l > 0 && r;)0 !== s && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, l--), a ? a.nextZ = i : e = i, i.prevZ = a, a = i; n = r } a.nextZ = null, c *= 2 } while (o > 1) }(i) }(e, r, i, a); for (var s, l, c = e; e.prev !== e.next;)if (s = e.prev, l = e.next, a ? zc(e, r, i, a) : Uc(e)) t.push(s.i / n), t.push(e.i / n), t.push(l.i / n), ru(e), e = l.next, c = l.next; else if ((e = l) === c) { o ? 1 === o ? Fc(e = Bc(Dc(e), t, n), t, n, r, i, a, 2) : 2 === o && Hc(e, t, n, r, i, a) : Fc(Dc(e), t, n, r, i, a, 1); break } } } function Uc(e) { var t = e.prev, n = e, r = e.next; if (Jc(t, n, r) >= 0) return !1; for (var i = e.next.next; i !== e.prev;) { if (Xc(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && Jc(i.prev, i, i.next) >= 0) return !1; i = i.next } return !0 } function zc(e, t, n, r) { var i = e.prev, a = e, o = e.next; if (Jc(i, a, o) >= 0) return !1; for (var s = i.x < a.x ? i.x < o.x ? i.x : o.x : a.x < o.x ? a.x : o.x, l = i.y < a.y ? i.y < o.y ? i.y : o.y : a.y < o.y ? a.y : o.y, c = i.x > a.x ? i.x > o.x ? i.x : o.x : a.x > o.x ? a.x : o.x, u = i.y > a.y ? i.y > o.y ? i.y : o.y : a.y > o.y ? a.y : o.y, h = Wc(s, l, t, n, r), d = Wc(c, u, t, n, r), p = e.prevZ, f = e.nextZ; p && p.z >= h && f && f.z <= d;) { if (p !== e.prev && p !== e.next && Xc(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && Jc(p.prev, p, p.next) >= 0) return !1; if (p = p.prevZ, f !== e.prev && f !== e.next && Xc(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && Jc(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } for (; p && p.z >= h;) { if (p !== e.prev && p !== e.next && Xc(i.x, i.y, a.x, a.y, o.x, o.y, p.x, p.y) && Jc(p.prev, p, p.next) >= 0) return !1; p = p.prevZ } for (; f && f.z <= d;) { if (f !== e.prev && f !== e.next && Xc(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) && Jc(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } return !0 } function Bc(e, t, n) { var r = e; do { var i = r.prev, a = r.next.next; !Zc(i, a) && Kc(i, r, r.next, a) && eu(i, a) && eu(a, i) && (t.push(i.i / n), t.push(r.i / n), t.push(a.i / n), ru(r), ru(r.next), r = e = a), r = r.next } while (r !== e); return Dc(r) } function Hc(e, t, n, r, i, a) { var o = e; do { for (var s = o.next.next; s !== o.prev;) { if (o.i !== s.i && Yc(o, s)) { var l = tu(o, s); return o = Dc(o, o.next), l = Dc(l, l.next), Fc(o, t, n, r, i, a), void Fc(l, t, n, r, i, a) } s = s.next } o = o.next } while (o !== e) } function Gc(e, t) { return e.x - t.x } function Vc(e, t) { if (t = function (e, t) { var n, r = t, i = e.x, a = e.y, o = -1 / 0; do { if (a <= r.y && a >= r.next.y && r.next.y !== r.y) { var s = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r.y); if (s <= i && s > o) { if (o = s, s === i) { if (a === r.y) return r; if (a === r.next.y) return r.next } n = r.x < r.next.x ? r : r.next } } r = r.next } while (r !== t); if (!n) return null; if (i === o) return n; var l, c = n, u = n.x, h = n.y, d = 1 / 0; r = n; do { i >= r.x && r.x >= u && i !== r.x && Xc(a < h ? i : o, a, u, h, a < h ? o : i, a, r.x, r.y) && (l = Math.abs(a - r.y) / (i - r.x), eu(r, e) && (l < d || l === d && (r.x > n.x || r.x === n.x && jc(n, r))) && (n = r, d = l)), r = r.next } while (r !== c); return n }(e, t)) { var n = tu(t, e); Dc(t, t.next), Dc(n, n.next) } } function jc(e, t) { return Jc(e.prev, e, t.prev) < 0 && Jc(t.next, e, e.next) < 0 } function Wc(e, t, n, r, i) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function qc(e) { var t = e, n = e; do { (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next } while (t !== e); return n } function Xc(e, t, n, r, i, a, o, s) { return (i - o) * (t - s) - (e - o) * (a - s) >= 0 && (e - o) * (r - s) - (n - o) * (t - s) >= 0 && (n - o) * (a - s) - (i - o) * (r - s) >= 0 } function Yc(e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) { var n = e; do { if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Kc(n, n.next, e, t)) return !0; n = n.next } while (n !== e); return !1 }(e, t) && (eu(e, t) && eu(t, e) && function (e, t) { var n = e, r = !1, i = (e.x + t.x) / 2, a = (e.y + t.y) / 2; do { n.y > a != n.next.y > a && n.next.y !== n.y && i < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next } while (n !== e); return r }(e, t) && (Jc(e.prev, e, t.prev) || Jc(e, t.prev, t)) || Zc(e, t) && Jc(e.prev, e, e.next) > 0 && Jc(t.prev, t, t.next) > 0) } function Jc(e, t, n) { return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y) } function Zc(e, t) { return e.x === t.x && e.y === t.y } function Kc(e, t, n, r) { var i = $c(Jc(e, t, n)), a = $c(Jc(e, t, r)), o = $c(Jc(n, r, e)), s = $c(Jc(n, r, t)); return i !== a && o !== s || (!(0 !== i || !Qc(e, n, t)) || (!(0 !== a || !Qc(e, r, t)) || (!(0 !== o || !Qc(n, e, r)) || !(0 !== s || !Qc(n, t, r))))) } function Qc(e, t, n) { return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y) } function $c(e) { return e > 0 ? 1 : e < 0 ? -1 : 0 } function eu(e, t) { return Jc(e.prev, e, e.next) < 0 ? Jc(e, t, e.next) >= 0 && Jc(e, e.prev, t) >= 0 : Jc(e, t, e.prev) < 0 || Jc(e, e.next, t) < 0 } function tu(e, t) { var n = new iu(e.i, e.x, e.y), r = new iu(t.i, t.x, t.y), i = e.next, a = t.prev; return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, a.next = r, r.prev = a, r } function nu(e, t, n, r) { var i = new iu(e, t, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function ru(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function iu(e, t, n) { this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } var au = { area: function (e) { for (var t = e.length, n = 0, r = t - 1, i = 0; i < t; r = i++)n += e[r].x * e[i].y - e[i].x * e[r].y; return .5 * n }, isClockWise: function (e) { return au.area(e) < 0 }, triangulateShape: function (e, t) { var n = [], r = [], i = []; ou(e), su(n, e); var a = e.length; t.forEach(ou); for (var o = 0; o < t.length; o++)r.push(a), a += t[o].length, su(n, t[o]); for (var s = Ic(n, r), l = 0; l < s.length; l += 3)i.push(s.slice(l, l + 3)); return i } }; function ou(e) { var t = e.length; t > 2 && e[t - 1].equals(e[0]) && e.pop() } function su(e, t) { for (var n = 0; n < t.length; n++)e.push(t[n].x), e.push(t[n].y) } var lu = function (e) { _inherits(n, Ra); var t = _createSuper(n); function n(e, r) { var i; _classCallCheck(this, n), (i = t.call(this)).type = "ExtrudeBufferGeometry", i.parameters = { shapes: e, options: r }, e = Array.isArray(e) ? e : [e]; for (var a = _assertThisInitialized(i), o = [], s = [], l = 0, c = e.length; l < c; l++) { u(e[l]) } function u(e) { var t = [], n = void 0 !== r.curveSegments ? r.curveSegments : 12, i = void 0 !== r.steps ? r.steps : 1, l = void 0 !== r.depth ? r.depth : 100, c = void 0 === r.bevelEnabled || r.bevelEnabled, u = void 0 !== r.bevelThickness ? r.bevelThickness : 6, h = void 0 !== r.bevelSize ? r.bevelSize : u - 2, d = void 0 !== r.bevelOffset ? r.bevelOffset : 0, p = void 0 !== r.bevelSegments ? r.bevelSegments : 3, f = r.extrudePath, m = void 0 !== r.UVGenerator ? r.UVGenerator : cu; void 0 !== r.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = r.amount); var v, g, y, b, x, _ = !1; f && (v = f.getSpacedPoints(i), _ = !0, c = !1, g = f.computeFrenetFrames(i, !1), y = new Nr, b = new Nr, x = new Nr), c || (p = 0, u = 0, h = 0, d = 0); var w = e.extractPoints(n), M = w.shape, S = w.holes; if (!au.isClockWise(M)) { M = M.reverse(); for (var T = 0, E = S.length; T < E; T++) { var A = S[T]; au.isClockWise(A) && (S[T] = A.reverse()) } } for (var R = au.triangulateShape(M, S), k = M, L = 0, C = S.length; L < C; L++) { var P = S[L]; M = M.concat(P) } function O(e, t, n) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e) } var I = M.length, N = R.length; function D(e, t, n) { var r, i, a, o = e.x - t.x, s = e.y - t.y, l = n.x - e.x, c = n.y - e.y, u = o * o + s * s, h = o * c - s * l; if (Math.abs(h) > Number.EPSILON) { var d = Math.sqrt(u), p = Math.sqrt(l * l + c * c), f = t.x - s / d, m = t.y + o / d, v = ((n.x - c / p - f) * c - (n.y + l / p - m) * l) / (o * c - s * l), g = (r = f + o * v - e.x) * r + (i = m + s * v - e.y) * i; if (g <= 2) return new Er(r, i); a = Math.sqrt(g / 2) } else { var y = !1; o > Number.EPSILON ? l > Number.EPSILON && (y = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(c) && (y = !0), y ? (r = -s, i = o, a = Math.sqrt(u)) : (r = o, i = s, a = Math.sqrt(u / 2)) } return new Er(r / a, i / a) } for (var F = [], U = 0, z = k.length, B = z - 1, H = U + 1; U < z; U++, B++, H++)B === z && (B = 0), H === z && (H = 0), F[U] = D(k[U], k[B], k[H]); for (var G, V = [], j = F.concat(), W = 0, q = S.length; W < q; W++) { var X = S[W]; G = []; for (var Y = 0, J = X.length, Z = J - 1, K = Y + 1; Y < J; Y++, Z++, K++)Z === J && (Z = 0), K === J && (K = 0), G[Y] = D(X[Y], X[Z], X[K]); V.push(G), j = j.concat(G) } for (var Q = 0; Q < p; Q++) { for (var $ = Q / p, ee = u * Math.cos($ * Math.PI / 2), te = h * Math.sin($ * Math.PI / 2) + d, ne = 0, re = k.length; ne < re; ne++) { var ie = O(k[ne], F[ne], te); Ce(ie.x, ie.y, -ee) } for (var ae = 0, oe = S.length; ae < oe; ae++) { var se = S[ae]; G = V[ae]; for (var le = 0, ce = se.length; le < ce; le++) { var ue = O(se[le], G[le], te); Ce(ue.x, ue.y, -ee) } } } for (var he = h + d, de = 0; de < I; de++) { var pe = c ? O(M[de], j[de], he) : M[de]; _ ? (b.copy(g.normals[0]).multiplyScalar(pe.x), y.copy(g.binormals[0]).multiplyScalar(pe.y), x.copy(v[0]).add(b).add(y), Ce(x.x, x.y, x.z)) : Ce(pe.x, pe.y, 0) } for (var fe = 1; fe <= i; fe++)for (var me = 0; me < I; me++) { var ve = c ? O(M[me], j[me], he) : M[me]; _ ? (b.copy(g.normals[fe]).multiplyScalar(ve.x), y.copy(g.binormals[fe]).multiplyScalar(ve.y), x.copy(v[fe]).add(b).add(y), Ce(x.x, x.y, x.z)) : Ce(ve.x, ve.y, l / i * fe) } for (var ge = p - 1; ge >= 0; ge--) { for (var ye = ge / p, be = u * Math.cos(ye * Math.PI / 2), xe = h * Math.sin(ye * Math.PI / 2) + d, _e = 0, we = k.length; _e < we; _e++) { var Me = O(k[_e], F[_e], xe); Ce(Me.x, Me.y, l + be) } for (var Se = 0, Te = S.length; Se < Te; Se++) { var Ee = S[Se]; G = V[Se]; for (var Ae = 0, Re = Ee.length; Ae < Re; Ae++) { var ke = O(Ee[Ae], G[Ae], xe); _ ? Ce(ke.x, ke.y + v[i - 1].y, v[i - 1].x + be) : Ce(ke.x, ke.y, l + be) } } } function Le(e, t) { for (var n = e.length; --n >= 0;) { var r = n, a = n - 1; a < 0 && (a = e.length - 1); for (var o = 0, s = i + 2 * p; o < s; o++) { var l = I * o, c = I * (o + 1); Oe(t + r + l, t + a + l, t + a + c, t + r + c) } } } function Ce(e, n, r) { t.push(e), t.push(n), t.push(r) } function Pe(e, t, n) { Ie(e), Ie(t), Ie(n); var r = o.length / 3, i = m.generateTopUV(a, o, r - 3, r - 2, r - 1); Ne(i[0]), Ne(i[1]), Ne(i[2]) } function Oe(e, t, n, r) { Ie(e), Ie(t), Ie(r), Ie(t), Ie(n), Ie(r); var i = o.length / 3, s = m.generateSideWallUV(a, o, i - 6, i - 3, i - 2, i - 1); Ne(s[0]), Ne(s[1]), Ne(s[3]), Ne(s[1]), Ne(s[2]), Ne(s[3]) } function Ie(e) { o.push(t[3 * e + 0]), o.push(t[3 * e + 1]), o.push(t[3 * e + 2]) } function Ne(e) { s.push(e.x), s.push(e.y) } !function () { var e = o.length / 3; if (c) { for (var t = 0, n = I * t, r = 0; r < N; r++) { var s = R[r]; Pe(s[2] + n, s[1] + n, s[0] + n) } n = I * (t = i + 2 * p); for (var l = 0; l < N; l++) { var u = R[l]; Pe(u[0] + n, u[1] + n, u[2] + n) } } else { for (var h = 0; h < N; h++) { var d = R[h]; Pe(d[2], d[1], d[0]) } for (var f = 0; f < N; f++) { var m = R[f]; Pe(m[0] + I * i, m[1] + I * i, m[2] + I * i) } } a.addGroup(e, o.length / 3 - e, 0) }(), function () { var e = o.length / 3, t = 0; Le(k, t), t += k.length; for (var n = 0, r = S.length; n < r; n++) { var i = S[n]; Le(i, t), t += i.length } a.addGroup(e, o.length / 3 - e, 1) }() } return i.setAttribute("position", new ga(o, 3)), i.setAttribute("uv", new ga(s, 2)), i.computeVertexNormals(), i } return _createClass(n, [{ key: "toJSON", value: function () { var e = Ra.prototype.toJSON.call(this); return function (e, t, n) { if (n.shapes = [], Array.isArray(e)) for (var r = 0, i = e.length; r < i; r++) { var a = e[r]; n.shapes.push(a.uuid) } else n.shapes.push(e.uuid); void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()); return n }(this.parameters.shapes, this.parameters.options, e) } }]), n }(), cu = { generateTopUV: function (e, t, n, r, i) { var a = t[3 * n], o = t[3 * n + 1], s = t[3 * r], l = t[3 * r + 1], c = t[3 * i], u = t[3 * i + 1]; return [new Er(a, o), new Er(s, l), new Er(c, u)] }, generateSideWallUV: function (e, t, n, r, i, a) { var o = t[3 * n], s = t[3 * n + 1], l = t[3 * n + 2], c = t[3 * r], u = t[3 * r + 1], h = t[3 * r + 2], d = t[3 * i], p = t[3 * i + 1], f = t[3 * i + 2], m = t[3 * a], v = t[3 * a + 1], g = t[3 * a + 2]; return Math.abs(s - u) < .01 ? [new Er(o, 1 - l), new Er(c, 1 - h), new Er(d, 1 - f), new Er(m, 1 - g)] : [new Er(s, 1 - l), new Er(u, 1 - h), new Er(p, 1 - f), new Er(v, 1 - g)] } }; var uu = function (e) { _inherits(n, Oc); var t = _createSuper(n); function n(e, r) { var i; return _classCallCheck(this, n), (i = t.call(this)).type = "ExtrudeGeometry", i.parameters = { shapes: e, options: r }, i.fromBufferGeometry(new lu(e, r)), i.mergeVertices(), i } return _createClass(n, [{ key: "toJSON", value: function () { var e = _get(_getPrototypeOf(n.prototype), "toJSON", this).call(this); return function (e, t, n) { if (n.shapes = [], Array.isArray(e)) for (var r = 0, i = e.length; r < i; r++) { var a = e[r]; n.shapes.push(a.uuid) } else n.shapes.push(e.uuid); void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()); return n }(this.parameters.shapes, this.parameters.options, e) } }]), n }(); function hu(e, t, n) { Ra.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: e, slices: t, stacks: n }; var r = [], i = [], a = [], o = [], s = new Nr, l = new Nr, c = new Nr, u = new Nr, h = new Nr; e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); for (var d = t + 1, p = 0; p <= n; p++)for (var f = p / n, m = 0; m <= t; m++) { var v = m / t; e(v, f, l), i.push(l.x, l.y, l.z), v - 1e-5 >= 0 ? (e(v - 1e-5, f, c), u.subVectors(l, c)) : (e(v + 1e-5, f, c), u.subVectors(c, l)), f - 1e-5 >= 0 ? (e(v, f - 1e-5, c), h.subVectors(l, c)) : (e(v, f + 1e-5, c), h.subVectors(c, l)), s.crossVectors(u, h).normalize(), a.push(s.x, s.y, s.z), o.push(v, f) } for (var g = 0; g < n; g++)for (var y = 0; y < t; y++) { var b = g * d + y, x = g * d + y + 1, _ = (g + 1) * d + y + 1, w = (g + 1) * d + y; r.push(b, x, w), r.push(x, _, w) } this.setIndex(r), this.setAttribute("position", new ga(i, 3)), this.setAttribute("normal", new ga(a, 3)), this.setAttribute("uv", new ga(o, 2)) } function du(e, t, n) { Oc.call(this), this.type = "ParametricGeometry", this.parameters = { func: e, slices: t, stacks: n }, this.fromBufferGeometry(new hu(e, t, n)), this.mergeVertices() } hu.prototype = Object.create(Ra.prototype), hu.prototype.constructor = hu, du.prototype = Object.create(Oc.prototype), du.prototype.constructor = du; var pu = function (e) { _inherits(n, Ra); var t = _createSuper(n); function n(e, r) { var i; _classCallCheck(this, n), (i = t.call(this)).type = "ShapeBufferGeometry", i.parameters = { shapes: e, curveSegments: r }, r = r || 12; var a = [], o = [], s = [], l = [], c = 0, u = 0; if (!1 === Array.isArray(e)) d(e); else for (var h = 0; h < e.length; h++)d(e[h]), i.addGroup(c, u, h), c += u, u = 0; function d(e) { var t = o.length / 3, n = e.extractPoints(r), i = n.shape, c = n.holes; !1 === au.isClockWise(i) && (i = i.reverse()); for (var h = 0, d = c.length; h < d; h++) { var p = c[h]; !0 === au.isClockWise(p) && (c[h] = p.reverse()) } for (var f = au.triangulateShape(i, c), m = 0, v = c.length; m < v; m++) { var g = c[m]; i = i.concat(g) } for (var y = 0, b = i.length; y < b; y++) { var x = i[y]; o.push(x.x, x.y, 0), s.push(0, 0, 1), l.push(x.x, x.y) } for (var _ = 0, w = f.length; _ < w; _++) { var M = f[_], S = M[0] + t, T = M[1] + t, E = M[2] + t; a.push(S, T, E), u += 3 } } return i.setIndex(a), i.setAttribute("position", new ga(o, 3)), i.setAttribute("normal", new ga(s, 3)), i.setAttribute("uv", new ga(l, 2)), i } return _createClass(n, [{ key: "toJSON", value: function () { var e = Ra.prototype.toJSON.call(this); return function (e, t) { if (t.shapes = [], Array.isArray(e)) for (var n = 0, r = e.length; n < r; n++) { var i = e[n]; t.shapes.push(i.uuid) } else t.shapes.push(e.uuid); return t }(this.parameters.shapes, e) } }]), n }(); var fu = function (e) { _inherits(n, Oc); var t = _createSuper(n); function n(e, r) { var i; return _classCallCheck(this, n), (i = t.call(this)).type = "ShapeGeometry", "object" === _typeof(r) && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), r = r.curveSegments), i.parameters = { shapes: e, curveSegments: r }, i.fromBufferGeometry(new pu(e, r)), i.mergeVertices(), i } return _createClass(n, [{ key: "toJSON", value: function () { var e = Oc.prototype.toJSON.call(this); return function (e, t) { if (t.shapes = [], Array.isArray(e)) for (var n = 0, r = e.length; n < r; n++) { var i = e[n]; t.shapes.push(i.uuid) } else t.shapes.push(e.uuid); return t }(this.parameters.shapes, e) } }]), n }(); function mu(e) { aa.call(this), this.type = "ShadowMaterial", this.color = new na(0), this.transparent = !0, this.setValues(e) } function vu(e) { to.call(this, e), this.type = "RawShaderMaterial" } function gu(e) { aa.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new na(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new na(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fr, this.normalScale = new Er(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(e) } function yu(e) { gu.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Er(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", { get: function () { return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity) }, set: function (e) { this.reflectivity = Tr.clamp(2.5 * (e - 1) / (e + 1), 0, 1) } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(e) } function bu(e) { aa.call(this), this.type = "MeshPhongMaterial", this.color = new na(16777215), this.specular = new na(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new na(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fr, this.normalScale = new Er(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = vt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } function xu(e) { aa.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new na(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new na(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fr, this.normalScale = new Er(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } function _u(e) { aa.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fr, this.normalScale = new Er(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } function wu(e) { aa.call(this), this.type = "MeshLambertMaterial", this.color = new na(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new na(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = vt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } function Mu(e) { aa.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new na(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fr, this.normalScale = new Er(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } function Su(e) { sc.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } mu.prototype = Object.create(aa.prototype), mu.prototype.constructor = mu, mu.prototype.isShadowMaterial = !0, mu.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.color.copy(e.color), this }, vu.prototype = Object.create(to.prototype), vu.prototype.constructor = vu, vu.prototype.isRawShaderMaterial = !0, gu.prototype = Object.create(aa.prototype), gu.prototype.constructor = gu, gu.prototype.isMeshStandardMaterial = !0, gu.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.vertexTangents = e.vertexTangents, this }, yu.prototype = Object.create(gu.prototype), yu.prototype.constructor = yu, yu.prototype.isMeshPhysicalMaterial = !0, yu.prototype.copy = function (e) { return gu.prototype.copy.call(this, e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new na).copy(e.sheen) : this.sheen = null, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this }, bu.prototype = Object.create(aa.prototype), bu.prototype.constructor = bu, bu.prototype.isMeshPhongMaterial = !0, bu.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, xu.prototype = Object.create(aa.prototype), xu.prototype.constructor = xu, xu.prototype.isMeshToonMaterial = !0, xu.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, _u.prototype = Object.create(aa.prototype), _u.prototype.constructor = _u, _u.prototype.isMeshNormalMaterial = !0, _u.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, wu.prototype = Object.create(aa.prototype), wu.prototype.constructor = wu, wu.prototype.isMeshLambertMaterial = !0, wu.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, Mu.prototype = Object.create(aa.prototype), Mu.prototype.constructor = Mu, Mu.prototype.isMeshMatcapMaterial = !0, Mu.prototype.copy = function (e) { return aa.prototype.copy.call(this, e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, Su.prototype = Object.create(sc.prototype), Su.prototype.constructor = Su, Su.prototype.isLineDashedMaterial = !0, Su.prototype.copy = function (e) { return sc.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this }; var Tu = Object.freeze({ __proto__: null, ShadowMaterial: mu, SpriteMaterial: Rl, RawShaderMaterial: vu, ShaderMaterial: to, PointsMaterial: yc, MeshPhysicalMaterial: yu, MeshStandardMaterial: gu, MeshPhongMaterial: bu, MeshToonMaterial: xu, MeshNormalMaterial: _u, MeshLambertMaterial: wu, MeshDepthMaterial: ll, MeshDistanceMaterial: cl, MeshBasicMaterial: oa, MeshMatcapMaterial: Mu, LineDashedMaterial: Su, LineBasicMaterial: sc, Material: aa }), Eu = { arraySlice: function (e, t, n) { return Eu.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n) }, convertArray: function (e, t, n) { return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) }, isTypedArray: function (e) { return ArrayBuffer.isView(e) && !_instanceof(e, DataView) }, getKeyframeOrder: function (e) { for (var t = e.length, n = new Array(t), r = 0; r !== t; ++r)n[r] = r; return n.sort(function (t, n) { return e[t] - e[n] }), n }, sortedArray: function (e, t, n) { for (var r = e.length, i = new e.constructor(r), a = 0, o = 0; o !== r; ++a)for (var s = n[a] * t, l = 0; l !== t; ++l)i[o++] = e[s + l]; return i }, flattenJSON: function (e, t, n, r) { for (var i = 1, a = e[0]; void 0 !== a && void 0 === a[r];)a = e[i++]; if (void 0 !== a) { var o = a[r]; if (void 0 !== o) if (Array.isArray(o)) do { void 0 !== (o = a[r]) && (t.push(a.time), n.push.apply(n, o)), a = e[i++] } while (void 0 !== a); else if (void 0 !== o.toArray) do { void 0 !== (o = a[r]) && (t.push(a.time), o.toArray(n, n.length)), a = e[i++] } while (void 0 !== a); else do { void 0 !== (o = a[r]) && (t.push(a.time), n.push(o)), a = e[i++] } while (void 0 !== a) } }, subclip: function (e, t, n, r, i) { i = i || 30; var a = e.clone(); a.name = t; for (var o = [], s = 0; s < a.tracks.length; ++s) { for (var l = a.tracks[s], c = l.getValueSize(), u = [], h = [], d = 0; d < l.times.length; ++d) { var p = l.times[d] * i; if (!(p < n || p >= r)) { u.push(l.times[d]); for (var f = 0; f < c; ++f)h.push(l.values[d * c + f]) } } 0 !== u.length && (l.times = Eu.convertArray(u, l.times.constructor), l.values = Eu.convertArray(h, l.values.constructor), o.push(l)) } a.tracks = o; for (var m = 1 / 0, v = 0; v < a.tracks.length; ++v)m > a.tracks[v].times[0] && (m = a.tracks[v].times[0]); for (var g = 0; g < a.tracks.length; ++g)a.tracks[g].shift(-1 * m); return a.resetDuration(), a }, makeClipAdditive: function (e, t, n, r) { void 0 === t && (t = 0), void 0 === n && (n = e), (void 0 === r || r <= 0) && (r = 30); for (var i = n.tracks.length, a = t / r, o = function (t) { var r = n.tracks[t], i = r.ValueTypeName; if ("bool" === i || "string" === i) return "continue"; var o = e.tracks.find(function (e) { return e.name === r.name && e.ValueTypeName === i }); if (void 0 === o) return "continue"; var s = 0, l = r.getValueSize(); r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = l / 3); var c = 0, u = o.getValueSize(); o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3); var h = r.times.length - 1, d = void 0; if (a <= r.times[0]) { var p = s, f = l - s; d = Eu.arraySlice(r.values, p, f) } else if (a >= r.times[h]) { var m = h * l + s, v = m + l - s; d = Eu.arraySlice(r.values, m, v) } else { var g = r.createInterpolant(), y = s, b = l - s; g.evaluate(a), d = Eu.arraySlice(g.resultBuffer, y, b) } "quaternion" === i && (new Ir).fromArray(d).normalize().conjugate().toArray(d); for (var x = o.times.length, _ = 0; _ < x; ++_) { var w = _ * u + c; if ("quaternion" === i) Ir.multiplyQuaternionsFlat(o.values, w, d, 0, o.values, w); else for (var M = u - 2 * c, S = 0; S < M; ++S)o.values[w + S] -= d[S] } }, s = 0; s < i; ++s)o(s); return e.blendMode = 2501, e } }; function Au(e, t, n, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n } function Ru(e, t, n, r) { Au.call(this, e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 } function ku(e, t, n, r) { Au.call(this, e, t, n, r) } function Lu(e, t, n, r) { Au.call(this, e, t, n, r) } function Cu(e, t, n, r) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = Eu.convertArray(t, this.TimeBufferType), this.values = Eu.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } function Pu(e, t, n) { Cu.call(this, e, t, n) } function Ou(e, t, n, r) { Cu.call(this, e, t, n, r) } function Iu(e, t, n, r) { Cu.call(this, e, t, n, r) } function Nu(e, t, n, r) { Au.call(this, e, t, n, r) } function Du(e, t, n, r) { Cu.call(this, e, t, n, r) } function Fu(e, t, n, r) { Cu.call(this, e, t, n, r) } function Uu(e, t, n, r) { Cu.call(this, e, t, n, r) } function zu(e, t, n, r) { this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.blendMode = void 0 !== r ? r : nr, this.uuid = Tr.generateUUID(), this.duration < 0 && this.resetDuration() } function Bu(e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); var t = function (e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return Iu; case "vector": case "vector2": case "vector3": case "vector4": return Uu; case "color": return Ou; case "quaternion": return Du; case "bool": case "boolean": return Pu; case "string": return Fu }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { var n = [], r = []; Eu.flattenJSON(e.keys, n, r, "value"), e.times = n, e.values = r } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) } Object.assign(Au.prototype, { evaluate: function (e) { var t = this.parameterPositions, n = this._cachedIndex, r = t[n], i = t[n - 1]; e: { t: { var a; n: { r: if (!(e < r)) { for (var o = n + 2; ;) { if (void 0 === r) { if (e < i) break r; return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, i) } if (n === o) break; if (i = r, e < (r = t[++n])) break t } a = t.length; break n } if (e >= i) break e; var s = t[1]; e < s && (n = 2, i = s); for (var l = n - 2; ;) { if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, e, r); if (n === l) break; if (r = i, e >= (i = t[--n - 1])) break t } a = n, n = 0 } for (; n < a;) { var c = n + a >>> 1; e < t[c] ? a = c : n = c + 1 } if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, r); if (void 0 === r) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, e) } this._cachedIndex = n, this.intervalChanged_(n, i, r) } return this.interpolate_(n, i, e, r) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (e) { for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r, a = 0; a !== r; ++a)t[a] = n[i + a]; return t }, interpolate_: function () { throw new Error("call to abstract method") }, intervalChanged_: function () { } }), Object.assign(Au.prototype, { beforeStart_: Au.prototype.copySampleValue_, afterEnd_: Au.prototype.copySampleValue_ }), Ru.prototype = Object.assign(Object.create(Au.prototype), { constructor: Ru, DefaultSettings_: { endingStart: tr, endingEnd: tr }, intervalChanged_: function (e, t, n) { var r = this.parameterPositions, i = e - 2, a = e + 1, o = r[i], s = r[a]; if (void 0 === o) switch (this.getSettings_().endingStart) { case 2401: i = e, o = 2 * t - n; break; case 2402: o = t + r[i = r.length - 2] - r[i + 1]; break; default: i = e, o = n }if (void 0 === s) switch (this.getSettings_().endingEnd) { case 2401: a = e, s = 2 * n - t; break; case 2402: a = 1, s = n + r[1] - r[0]; break; default: a = e - 1, s = t }var l = .5 * (n - t), c = this.valueSize; this._weightPrev = l / (t - o), this._weightNext = l / (s - n), this._offsetPrev = i * c, this._offsetNext = a * c }, interpolate_: function (e, t, n, r) { for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - t) / (r - t), f = p * p, m = f * p, v = -h * m + 2 * h * f - h * p, g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, b = d * m - d * f, x = 0; x !== o; ++x)i[x] = v * a[c + x] + g * a[l + x] + y * a[s + x] + b * a[u + x]; return i } }), ku.prototype = Object.assign(Object.create(Au.prototype), { constructor: ku, interpolate_: function (e, t, n, r) { for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = (n - t) / (r - t), u = 1 - c, h = 0; h !== o; ++h)i[h] = a[l + h] * u + a[s + h] * c; return i } }), Lu.prototype = Object.assign(Object.create(Au.prototype), { constructor: Lu, interpolate_: function (e) { return this.copySampleValue_(e - 1) } }), Object.assign(Cu, { toJSON: function (e) { var t, n = e.constructor; if (void 0 !== n.toJSON) t = n.toJSON(e); else { t = { name: e.name, times: Eu.convertArray(e.times, Array), values: Eu.convertArray(e.values, Array) }; var r = e.getInterpolation(); r !== e.DefaultInterpolation && (t.interpolation = r) } return t.type = e.ValueTypeName, t } }), Object.assign(Cu.prototype, { constructor: Cu, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function (e) { return new Lu(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodLinear: function (e) { return new ku(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodSmooth: function (e) { return new Ru(this.times, this.values, this.getValueSize(), e) }, setInterpolation: function (e) { var t; switch (e) { case er: t = this.InterpolantFactoryMethodDiscrete; break; case 2301: t = this.InterpolantFactoryMethodLinear; break; case 2302: t = this.InterpolantFactoryMethodSmooth }if (void 0 === t) { var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(n); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", n), this } return this.createInterpolant = t, this }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return er; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302 } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (e) { if (0 !== e) for (var t = this.times, n = 0, r = t.length; n !== r; ++n)t[n] += e; return this }, scale: function (e) { if (1 !== e) for (var t = this.times, n = 0, r = t.length; n !== r; ++n)t[n] *= e; return this }, trim: function (e, t) { for (var n = this.times, r = n.length, i = 0, a = r - 1; i !== r && n[i] < e;)++i; for (; -1 !== a && n[a] > t;)--a; if (++a, 0 !== i || a !== r) { i >= a && (i = (a = Math.max(a, 1)) - 1); var o = this.getValueSize(); this.times = Eu.arraySlice(n, i, a), this.values = Eu.arraySlice(this.values, i * o, a * o) } return this }, validate: function () { var e = !0, t = this.getValueSize(); t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); var n = this.times, r = this.values, i = n.length; 0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); for (var a = null, o = 0; o !== i; o++) { var s = n[o]; if ("number" == typeof s && isNaN(s)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1; break } if (null !== a && a > s) { console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), e = !1; break } a = s } if (void 0 !== r && Eu.isTypedArray(r)) for (var l = 0, c = r.length; l !== c; ++l) { var u = r[l]; if (isNaN(u)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, l, u), e = !1; break } } return e }, optimize: function () { for (var e = Eu.arraySlice(this.times), t = Eu.arraySlice(this.values), n = this.getValueSize(), r = 2302 === this.getInterpolation(), i = e.length - 1, a = 1, o = 1; o < i; ++o) { var s = !1, l = e[o]; if (l !== e[o + 1] && (1 !== o || l !== l[0])) if (r) s = !0; else for (var c = o * n, u = c - n, h = c + n, d = 0; d !== n; ++d) { var p = t[c + d]; if (p !== t[u + d] || p !== t[h + d]) { s = !0; break } } if (s) { if (o !== a) { e[a] = e[o]; for (var f = o * n, m = a * n, v = 0; v !== n; ++v)t[m + v] = t[f + v] } ++a } } if (i > 0) { e[a] = e[i]; for (var g = i * n, y = a * n, b = 0; b !== n; ++b)t[y + b] = t[g + b]; ++a } return a !== e.length ? (this.times = Eu.arraySlice(e, 0, a), this.values = Eu.arraySlice(t, 0, a * n)) : (this.times = e, this.values = t), this }, clone: function () { var e = Eu.arraySlice(this.times, 0), t = Eu.arraySlice(this.values, 0), n = new (0, this.constructor)(this.name, e, t); return n.createInterpolant = this.createInterpolant, n } }), Pu.prototype = Object.assign(Object.create(Cu.prototype), { constructor: Pu, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: er, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Ou.prototype = Object.assign(Object.create(Cu.prototype), { constructor: Ou, ValueTypeName: "color" }), Iu.prototype = Object.assign(Object.create(Cu.prototype), { constructor: Iu, ValueTypeName: "number" }), Nu.prototype = Object.assign(Object.create(Au.prototype), { constructor: Nu, interpolate_: function (e, t, n, r) { for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (n - t) / (r - t), l = e * o, c = l + o; l !== c; l += 4)Ir.slerpFlat(i, 0, a, l - o, a, l, s); return i } }), Du.prototype = Object.assign(Object.create(Cu.prototype), { constructor: Du, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function (e) { return new Nu(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodSmooth: void 0 }), Fu.prototype = Object.assign(Object.create(Cu.prototype), { constructor: Fu, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: er, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Uu.prototype = Object.assign(Object.create(Cu.prototype), { constructor: Uu, ValueTypeName: "vector" }), Object.assign(zu, { parse: function (e) { for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, a = n.length; i !== a; ++i)t.push(Bu(n[i]).scale(r)); return new zu(e.name, e.duration, t, e.blendMode) }, toJSON: function (e) { for (var t = [], n = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }, i = 0, a = n.length; i !== a; ++i)t.push(Cu.toJSON(n[i])); return r }, CreateFromMorphTargetSequence: function (e, t, n, r) { for (var i = t.length, a = [], o = 0; o < i; o++) { var s = [], l = []; s.push((o + i - 1) % i, o, (o + 1) % i), l.push(0, 1, 0); var c = Eu.getKeyframeOrder(s); s = Eu.sortedArray(s, 1, c), l = Eu.sortedArray(l, 1, c), r || 0 !== s[0] || (s.push(i), l.push(l[0])), a.push(new Iu(".morphTargetInfluences[" + t[o].name + "]", s, l).scale(1 / n)) } return new zu(e, -1, a) }, findByName: function (e, t) { var n = e; if (!Array.isArray(e)) { var r = e; n = r.geometry && r.geometry.animations || r.animations } for (var i = 0; i < n.length; i++)if (n[i].name === t) return n[i]; return null }, CreateClipsFromMorphTargetSequences: function (e, t, n) { for (var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) { var s = e[a], l = s.name.match(i); if (l && l.length > 1) { var c = l[1], u = r[c]; u || (r[c] = u = []), u.push(s) } } var h = []; for (var d in r) h.push(zu.CreateFromMorphTargetSequence(d, r[d], t, n)); return h }, parseAnimation: function (e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; for (var n = function (e, t, n, r, i) { if (0 !== n.length) { var a = [], o = []; Eu.flattenJSON(n, a, o, r), 0 !== a.length && i.push(new e(t, a, o)) } }, r = [], i = e.name || "default", a = e.fps || 30, o = e.blendMode, s = e.length || -1, l = e.hierarchy || [], c = 0; c < l.length; c++) { var u = l[c].keys; if (u && 0 !== u.length) if (u[0].morphTargets) { var h = {}, d = void 0; for (d = 0; d < u.length; d++)if (u[d].morphTargets) for (var p = 0; p < u[d].morphTargets.length; p++)h[u[d].morphTargets[p]] = -1; for (var f in h) { for (var m = [], v = [], g = 0; g !== u[d].morphTargets.length; ++g) { var y = u[d]; m.push(y.time), v.push(y.morphTarget === f ? 1 : 0) } r.push(new Iu(".morphTargetInfluence[" + f + "]", m, v)) } s = h.length * (a || 1) } else { var b = ".bones[" + t[c].name + "]"; n(Uu, b + ".position", u, "pos", r), n(Du, b + ".quaternion", u, "rot", r), n(Uu, b + ".scale", u, "scl", r) } } return 0 === r.length ? null : new zu(i, s, r, o) } }), Object.assign(zu.prototype, { resetDuration: function () { for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) { var r = this.tracks[t]; e = Math.max(e, r.times[r.times.length - 1]) } return this.duration = e, this }, trim: function () { for (var e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this }, validate: function () { for (var e = !0, t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e }, optimize: function () { for (var e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this }, clone: function () { for (var e = [], t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new zu(this.name, this.duration, e, this.blendMode) } }); var Hu = { enabled: !1, files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; var Gu = new function (e, t, n) { var r = this, i = !1, a = 0, o = 0, s = void 0, l = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) { o++, !1 === i && void 0 !== r.onStart && r.onStart(e, a, o), i = !0 }, this.itemEnd = function (e) { a++, void 0 !== r.onProgress && r.onProgress(e, a, o), a === o && (i = !1, void 0 !== r.onLoad && r.onLoad()) }, this.itemError = function (e) { void 0 !== r.onError && r.onError(e) }, this.resolveURL = function (e) { return s ? s(e) : e }, this.setURLModifier = function (e) { return s = e, this }, this.addHandler = function (e, t) { return l.push(e, t), this }, this.removeHandler = function (e) { var t = l.indexOf(e); return -1 !== t && l.splice(t, 2), this }, this.getHandler = function (e) { for (var t = 0, n = l.length; t < n; t += 2) { var r = l[t], i = l[t + 1]; if (r.global && (r.lastIndex = 0), r.test(e)) return i } return null } }; function Vu(e) { this.manager = void 0 !== e ? e : Gu, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } Object.assign(Vu.prototype, { load: function () { }, loadAsync: function (e, t) { var n = this; return new Promise(function (r, i) { n.load(e, r, t, i) }) }, parse: function () { }, setCrossOrigin: function (e) { return this.crossOrigin = e, this }, setWithCredentials: function (e) { return this.withCredentials = e, this }, setPath: function (e) { return this.path = e, this }, setResourcePath: function (e) { return this.resourcePath = e, this }, setRequestHeader: function (e) { return this.requestHeader = e, this } }); var ju = {}; function Wu(e) { Vu.call(this, e) } function qu(e) { Vu.call(this, e) } function Xu(e) { Vu.call(this, e) } function Yu(e) { Vu.call(this, e) } function Ju(e) { Vu.call(this, e) } function Zu(e) { Vu.call(this, e) } function Ku(e) { Vu.call(this, e) } function Qu() { this.type = "Curve", this.arcLengthDivisions = 200 } function $u(e, t, n, r, i, a, o, s) { Qu.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0 } function eh(e, t, n, r, i, a) { $u.call(this, e, t, n, n, r, i, a), this.type = "ArcCurve" } function th() { var e = 0, t = 0, n = 0, r = 0; function i(i, a, o, s) { e = i, t = o, n = -3 * i + 3 * a - 2 * o - s, r = 2 * i - 2 * a + o + s } return { initCatmullRom: function (e, t, n, r, a) { i(t, n, a * (n - e), a * (r - t)) }, initNonuniformCatmullRom: function (e, t, n, r, a, o, s) { var l = (t - e) / a - (n - e) / (a + o) + (n - t) / o, c = (n - t) / o - (r - t) / (o + s) + (r - n) / s; i(t, n, l *= o, c *= o) }, calc: function (i) { var a = i * i; return e + t * i + n * a + r * (a * i) } } } Wu.prototype = Object.assign(Object.create(Vu.prototype), { constructor: Wu, load: function (e, t, n, r) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); var i = this, a = Hu.get(e); if (void 0 !== a) return i.manager.itemStart(e), setTimeout(function () { t && t(a), i.manager.itemEnd(e) }, 0), a; if (void 0 === ju[e]) { var o, s = e.match(/^data:(.*?)(;base64)?,(.*)$/); if (s) { var l = s[1], c = !!s[2], u = s[3]; u = decodeURIComponent(u), c && (u = atob(u)); try { var h, d = (this.responseType || "").toLowerCase(); switch (d) { case "arraybuffer": case "blob": for (var p = new Uint8Array(u.length), f = 0; f < u.length; f++)p[f] = u.charCodeAt(f); h = "blob" === d ? new Blob([p.buffer], { type: l }) : p.buffer; break; case "document": var m = new DOMParser; h = m.parseFromString(u, l); break; case "json": h = JSON.parse(u); break; default: h = u }setTimeout(function () { t && t(h), i.manager.itemEnd(e) }, 0) } catch (t) { setTimeout(function () { r && r(t), i.manager.itemError(e), i.manager.itemEnd(e) }, 0) } } else { for (var v in ju[e] = [], ju[e].push({ onLoad: t, onProgress: n, onError: r }), (o = new XMLHttpRequest).open("GET", e, !0), o.addEventListener("load", function (t) { var n = this.response, r = ju[e]; if (delete ju[e], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Hu.add(e, n); for (var a = 0, o = r.length; a < o; a++) { var s = r[a]; s.onLoad && s.onLoad(n) } i.manager.itemEnd(e) } else { for (var l = 0, c = r.length; l < c; l++) { var u = r[l]; u.onError && u.onError(t) } i.manager.itemError(e), i.manager.itemEnd(e) } }, !1), o.addEventListener("progress", function (t) { for (var n = ju[e], r = 0, i = n.length; r < i; r++) { var a = n[r]; a.onProgress && a.onProgress(t) } }, !1), o.addEventListener("error", function (t) { var n = ju[e]; delete ju[e]; for (var r = 0, a = n.length; r < a; r++) { var o = n[r]; o.onError && o.onError(t) } i.manager.itemError(e), i.manager.itemEnd(e) }, !1), o.addEventListener("abort", function (t) { var n = ju[e]; delete ju[e]; for (var r = 0, a = n.length; r < a; r++) { var o = n[r]; o.onError && o.onError(t) } i.manager.itemError(e), i.manager.itemEnd(e) }, !1), void 0 !== this.responseType && (o.responseType = this.responseType), void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials), o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) o.setRequestHeader(v, this.requestHeader[v]); o.send(null) } return i.manager.itemStart(e), o } ju[e].push({ onLoad: t, onProgress: n, onError: r }) }, setResponseType: function (e) { return this.responseType = e, this }, setMimeType: function (e) { return this.mimeType = e, this } }), qu.prototype = Object.assign(Object.create(Vu.prototype), { constructor: qu, load: function (e, t, n, r) { var i = this, a = new Wu(i.manager); a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, function (n) { try { t(i.parse(JSON.parse(n))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, n, r) }, parse: function (e) { for (var t = [], n = 0; n < e.length; n++) { var r = zu.parse(e[n]); t.push(r) } return t } }), Xu.prototype = Object.assign(Object.create(Vu.prototype), { constructor: Xu, load: function (e, t, n, r) { var i = this, a = [], o = new Ec; o.image = a; var s = new Wu(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(i.withCredentials); var l = 0; function c(c) { s.load(e[c], function (e) { var n = i.parse(e, !0); a[c] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }, 6 === (l += 1) && (1 === n.mipmapCount && (o.minFilter = Ft), o.format = n.format, o.needsUpdate = !0, t && t(o)) }, n, r) } if (Array.isArray(e)) for (var u = 0, h = e.length; u < h; ++u)c(u); else s.load(e, function (e) { var n = i.parse(e, !0); if (n.isCubemap) for (var r = n.mipmaps.length / n.mipmapCount, s = 0; s < r; s++) { a[s] = { mipmaps: [] }; for (var l = 0; l < n.mipmapCount; l++)a[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + l]), a[s].format = n.format, a[s].width = n.width, a[s].height = n.height } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps; 1 === n.mipmapCount && (o.minFilter = Ft), o.format = n.format, o.needsUpdate = !0, t && t(o) }, n, r); return o } }), Yu.prototype = Object.assign(Object.create(Vu.prototype), { constructor: Yu, load: function (e, t, n, r) { void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); var i = this, a = Hu.get(e); if (void 0 !== a) return i.manager.itemStart(e), setTimeout(function () { t && t(a), i.manager.itemEnd(e) }, 0), a; var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function s() { o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), Hu.add(e, this), t && t(this), i.manager.itemEnd(e) } function l(t) { o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e) } return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(e), o.src = e, o } }), Ju.prototype = Object.assign(Object.create(Vu.prototype), { constructor: Ju, load: function (e, t, n, r) { var i = new so, a = new Yu(this.manager); a.setCrossOrigin(this.crossOrigin), a.setPath(this.path); var o = 0; function s(n) { a.load(e[n], function (e) { i.images[n] = e, 6 === ++o && (i.needsUpdate = !0, t && t(i)) }, void 0, r) } for (var l = 0; l < e.length; ++l)s(l); return i } }), Zu.prototype = Object.assign(Object.create(Vu.prototype), { constructor: Zu, load: function (e, t, n, r) { var i = this, a = new co, o = new Wu(this.manager); return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(i.withCredentials), o.load(e, function (e) { var n = i.parse(e); n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : Pt, a.wrapT = void 0 !== n.wrapT ? n.wrapT : Pt, a.magFilter = void 0 !== n.magFilter ? n.magFilter : Ft, a.minFilter = void 0 !== n.minFilter ? n.minFilter : Ft, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps, a.minFilter = zt), 1 === n.mipmapCount && (a.minFilter = Ft), a.needsUpdate = !0, t && t(a, n)) }, n, r), a } }), Ku.prototype = Object.assign(Object.create(Vu.prototype), { constructor: Ku, load: function (e, t, n, r) { var i = new Lr, a = new Yu(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function (n) { i.image = n; var r = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/); i.format = r ? $t : en, i.needsUpdate = !0, void 0 !== t && t(i) }, n, r), i } }), Object.assign(Qu.prototype, { getPoint: function () { return console.warn("THREE.Curve: .getPoint() not implemented."), null }, getPointAt: function (e, t) { var n = this.getUtoTmapping(e); return this.getPoint(n, t) }, getPoints: function (e) { void 0 === e && (e = 5); for (var t = [], n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return t }, getSpacedPoints: function (e) { void 0 === e && (e = 5); for (var t = [], n = 0; n <= e; n++)t.push(this.getPointAt(n / e)); return t }, getLength: function () { var e = this.getLengths(); return e[e.length - 1] }, getLengths: function (e) { if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; var t, n = [], r = this.getPoint(0), i = 0; n.push(0); for (var a = 1; a <= e; a++)i += (t = this.getPoint(a / e)).distanceTo(r), n.push(i), r = t; return this.cacheArcLengths = n, n }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function (e, t) { var n, r = this.getLengths(), i = 0, a = r.length; n = t || e * r[a - 1]; for (var o, s = 0, l = a - 1; s <= l;)if ((o = r[i = Math.floor(s + (l - s) / 2)] - n) < 0) s = i + 1; else { if (!(o > 0)) { l = i; break } l = i - 1 } if (r[i = l] === n) return i / (a - 1); var c = r[i]; return (i + (n - c) / (r[i + 1] - c)) / (a - 1) }, getTangent: function (e, t) { var n = e - 1e-4, r = e + 1e-4; n < 0 && (n = 0), r > 1 && (r = 1); var i = this.getPoint(n), a = this.getPoint(r), o = t || (i.isVector2 ? new Er : new Nr); return o.copy(a).sub(i).normalize(), o }, getTangentAt: function (e, t) { var n = this.getUtoTmapping(e); return this.getTangent(n, t) }, computeFrenetFrames: function (e, t) { for (var n = new Nr, r = [], i = [], a = [], o = new Nr, s = new ci, l = 0; l <= e; l++) { var c = l / e; r[l] = this.getTangentAt(c, new Nr), r[l].normalize() } i[0] = new Nr, a[0] = new Nr; var u = Number.MAX_VALUE, h = Math.abs(r[0].x), d = Math.abs(r[0].y), p = Math.abs(r[0].z); h <= u && (u = h, n.set(1, 0, 0)), d <= u && (u = d, n.set(0, 1, 0)), p <= u && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), a[0].crossVectors(r[0], i[0]); for (var f = 1; f <= e; f++) { if (i[f] = i[f - 1].clone(), a[f] = a[f - 1].clone(), o.crossVectors(r[f - 1], r[f]), o.length() > Number.EPSILON) { o.normalize(); var m = Math.acos(Tr.clamp(r[f - 1].dot(r[f]), -1, 1)); i[f].applyMatrix4(s.makeRotationAxis(o, m)) } a[f].crossVectors(r[f], i[f]) } if (!0 === t) { var v = Math.acos(Tr.clamp(i[0].dot(i[e]), -1, 1)); v /= e, r[0].dot(o.crossVectors(i[0], i[e])) > 0 && (v = -v); for (var g = 1; g <= e; g++)i[g].applyMatrix4(s.makeRotationAxis(r[g], v * g)), a[g].crossVectors(r[g], i[g]) } return { tangents: r, normals: i, binormals: a } }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.arcLengthDivisions = e.arcLengthDivisions, this }, toJSON: function () { var e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e }, fromJSON: function (e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } }), $u.prototype = Object.create(Qu.prototype), $u.prototype.constructor = $u, $u.prototype.isEllipseCurve = !0, $u.prototype.getPoint = function (e, t) { for (var n = t || new Er, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, a = Math.abs(i) < Number.EPSILON; i < 0;)i += r; for (; i > r;)i -= r; i < Number.EPSILON && (i = a ? 0 : r), !0 !== this.aClockwise || a || (i === r ? i = -r : i -= r); var o = this.aStartAngle + e * i, s = this.aX + this.xRadius * Math.cos(o), l = this.aY + this.yRadius * Math.sin(o); if (0 !== this.aRotation) { var c = Math.cos(this.aRotation), u = Math.sin(this.aRotation), h = s - this.aX, d = l - this.aY; s = h * c - d * u + this.aX, l = h * u + d * c + this.aY } return n.set(s, l) }, $u.prototype.copy = function (e) { return Qu.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this }, $u.prototype.toJSON = function () { var e = Qu.prototype.toJSON.call(this); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e }, $u.prototype.fromJSON = function (e) { return Qu.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this }, eh.prototype = Object.create($u.prototype), eh.prototype.constructor = eh, eh.prototype.isArcCurve = !0; var nh = new Nr, rh = new th, ih = new th, ah = new th; function oh(e, t, n, r) { Qu.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = void 0 !== r ? r : .5 } function sh(e, t, n, r, i) { var a = .5 * (r - t), o = .5 * (i - n), s = e * e; return (2 * n - 2 * r + a + o) * (e * s) + (-3 * n + 3 * r - 2 * a - o) * s + a * e + n } function lh(e, t, n, r) { return function (e, t) { var n = 1 - e; return n * n * t }(e, t) + function (e, t) { return 2 * (1 - e) * e * t }(e, n) + function (e, t) { return e * e * t }(e, r) } function ch(e, t, n, r, i) { return function (e, t) { var n = 1 - e; return n * n * n * t }(e, t) + function (e, t) { var n = 1 - e; return 3 * n * n * e * t }(e, n) + function (e, t) { return 3 * (1 - e) * e * e * t }(e, r) + function (e, t) { return e * e * e * t }(e, i) } function uh(e, t, n, r) { Qu.call(this), this.type = "CubicBezierCurve", this.v0 = e || new Er, this.v1 = t || new Er, this.v2 = n || new Er, this.v3 = r || new Er } function hh(e, t, n, r) { Qu.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new Nr, this.v1 = t || new Nr, this.v2 = n || new Nr, this.v3 = r || new Nr } function dh(e, t) { Qu.call(this), this.type = "LineCurve", this.v1 = e || new Er, this.v2 = t || new Er } function ph(e, t) { Qu.call(this), this.type = "LineCurve3", this.v1 = e || new Nr, this.v2 = t || new Nr } function fh(e, t, n) { Qu.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new Er, this.v1 = t || new Er, this.v2 = n || new Er } function mh(e, t, n) { Qu.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new Nr, this.v1 = t || new Nr, this.v2 = n || new Nr } function vh(e) { Qu.call(this), this.type = "SplineCurve", this.points = e || [] } oh.prototype = Object.create(Qu.prototype), oh.prototype.constructor = oh, oh.prototype.isCatmullRomCurve3 = !0, oh.prototype.getPoint = function (e, t) { var n, r, i = t || new Nr, a = this.points, o = a.length, s = (o - (this.closed ? 0 : 1)) * e, l = Math.floor(s), c = s - l; this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / o) + 1) * o : 0 === c && l === o - 1 && (l = o - 2, c = 1), this.closed || l > 0 ? n = a[(l - 1) % o] : (nh.subVectors(a[0], a[1]).add(a[0]), n = nh); var u = a[l % o], h = a[(l + 1) % o]; if (this.closed || l + 2 < o ? r = a[(l + 2) % o] : (nh.subVectors(a[o - 1], a[o - 2]).add(a[o - 1]), r = nh), "centripetal" === this.curveType || "chordal" === this.curveType) { var d = "chordal" === this.curveType ? .5 : .25, p = Math.pow(n.distanceToSquared(u), d), f = Math.pow(u.distanceToSquared(h), d), m = Math.pow(h.distanceToSquared(r), d); f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), rh.initNonuniformCatmullRom(n.x, u.x, h.x, r.x, p, f, m), ih.initNonuniformCatmullRom(n.y, u.y, h.y, r.y, p, f, m), ah.initNonuniformCatmullRom(n.z, u.z, h.z, r.z, p, f, m) } else "catmullrom" === this.curveType && (rh.initCatmullRom(n.x, u.x, h.x, r.x, this.tension), ih.initCatmullRom(n.y, u.y, h.y, r.y, this.tension), ah.initCatmullRom(n.z, u.z, h.z, r.z, this.tension)); return i.set(rh.calc(c), ih.calc(c), ah.calc(c)), i }, oh.prototype.copy = function (e) { Qu.prototype.copy.call(this, e), this.points = []; for (var t = 0, n = e.points.length; t < n; t++) { var r = e.points[t]; this.points.push(r.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this }, oh.prototype.toJSON = function () { var e = Qu.prototype.toJSON.call(this); e.points = []; for (var t = 0, n = this.points.length; t < n; t++) { var r = this.points[t]; e.points.push(r.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e }, oh.prototype.fromJSON = function (e) { Qu.prototype.fromJSON.call(this, e), this.points = []; for (var t = 0, n = e.points.length; t < n; t++) { var r = e.points[t]; this.points.push((new Nr).fromArray(r)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this }, uh.prototype = Object.create(Qu.prototype), uh.prototype.constructor = uh, uh.prototype.isCubicBezierCurve = !0, uh.prototype.getPoint = function (e, t) { var n = t || new Er, r = this.v0, i = this.v1, a = this.v2, o = this.v3; return n.set(ch(e, r.x, i.x, a.x, o.x), ch(e, r.y, i.y, a.y, o.y)), n }, uh.prototype.copy = function (e) { return Qu.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this }, uh.prototype.toJSON = function () { var e = Qu.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e }, uh.prototype.fromJSON = function (e) { return Qu.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this }, hh.prototype = Object.create(Qu.prototype), hh.prototype.constructor = hh, hh.prototype.isCubicBezierCurve3 = !0, hh.prototype.getPoint = function (e, t) { var n = t || new Nr, r = this.v0, i = this.v1, a = this.v2, o = this.v3; return n.set(ch(e, r.x, i.x, a.x, o.x), ch(e, r.y, i.y, a.y, o.y), ch(e, r.z, i.z, a.z, o.z)), n }, hh.prototype.copy = function (e) { return Qu.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this }, hh.prototype.toJSON = function () { var e = Qu.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e }, hh.prototype.fromJSON = function (e) { return Qu.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this }, dh.prototype = Object.create(Qu.prototype), dh.prototype.constructor = dh, dh.prototype.isLineCurve = !0, dh.prototype.getPoint = function (e, t) { var n = t || new Er; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n }, dh.prototype.getPointAt = function (e, t) { return this.getPoint(e, t) }, dh.prototype.getTangent = function (e, t) { var n = t || new Er; return n.copy(this.v2).sub(this.v1).normalize(), n }, dh.prototype.copy = function (e) { return Qu.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, dh.prototype.toJSON = function () { var e = Qu.prototype.toJSON.call(this); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, dh.prototype.fromJSON = function (e) { return Qu.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, ph.prototype = Object.create(Qu.prototype), ph.prototype.constructor = ph, ph.prototype.isLineCurve3 = !0, ph.prototype.getPoint = function (e, t) { var n = t || new Nr; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n }, ph.prototype.getPointAt = function (e, t) { return this.getPoint(e, t) }, ph.prototype.copy = function (e) { return Qu.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, ph.prototype.toJSON = function () { var e = Qu.prototype.toJSON.call(this); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, ph.prototype.fromJSON = function (e) { return Qu.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, fh.prototype = Object.create(Qu.prototype), fh.prototype.constructor = fh, fh.prototype.isQuadraticBezierCurve = !0, fh.prototype.getPoint = function (e, t) { var n = t || new Er, r = this.v0, i = this.v1, a = this.v2; return n.set(lh(e, r.x, i.x, a.x), lh(e, r.y, i.y, a.y)), n }, fh.prototype.copy = function (e) { return Qu.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, fh.prototype.toJSON = function () { var e = Qu.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, fh.prototype.fromJSON = function (e) { return Qu.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, mh.prototype = Object.create(Qu.prototype), mh.prototype.constructor = mh, mh.prototype.isQuadraticBezierCurve3 = !0, mh.prototype.getPoint = function (e, t) { var n = t || new Nr, r = this.v0, i = this.v1, a = this.v2; return n.set(lh(e, r.x, i.x, a.x), lh(e, r.y, i.y, a.y), lh(e, r.z, i.z, a.z)), n }, mh.prototype.copy = function (e) { return Qu.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, mh.prototype.toJSON = function () { var e = Qu.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, mh.prototype.fromJSON = function (e) { return Qu.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, vh.prototype = Object.create(Qu.prototype), vh.prototype.constructor = vh, vh.prototype.isSplineCurve = !0, vh.prototype.getPoint = function (e, t) { var n = t || new Er, r = this.points, i = (r.length - 1) * e, a = Math.floor(i), o = i - a, s = r[0 === a ? a : a - 1], l = r[a], c = r[a > r.length - 2 ? r.length - 1 : a + 1], u = r[a > r.length - 3 ? r.length - 1 : a + 2]; return n.set(sh(o, s.x, l.x, c.x, u.x), sh(o, s.y, l.y, c.y, u.y)), n }, vh.prototype.copy = function (e) { Qu.prototype.copy.call(this, e), this.points = []; for (var t = 0, n = e.points.length; t < n; t++) { var r = e.points[t]; this.points.push(r.clone()) } return this }, vh.prototype.toJSON = function () { var e = Qu.prototype.toJSON.call(this); e.points = []; for (var t = 0, n = this.points.length; t < n; t++) { var r = this.points[t]; e.points.push(r.toArray()) } return e }, vh.prototype.fromJSON = function (e) { Qu.prototype.fromJSON.call(this, e), this.points = []; for (var t = 0, n = e.points.length; t < n; t++) { var r = e.points[t]; this.points.push((new Er).fromArray(r)) } return this }; var gh = Object.freeze({ __proto__: null, ArcCurve: eh, CatmullRomCurve3: oh, CubicBezierCurve: uh, CubicBezierCurve3: hh, EllipseCurve: $u, LineCurve: dh, LineCurve3: ph, QuadraticBezierCurve: fh, QuadraticBezierCurve3: mh, SplineCurve: vh }); function yh() { Qu.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } function bh(e) { yh.call(this), this.type = "Path", this.currentPoint = new Er, e && this.setFromPoints(e) } function xh(e) { bh.call(this, e), this.uuid = Tr.generateUUID(), this.type = "Shape", this.holes = [] } function _h(e, t) { Ii.call(this), this.type = "Light", this.color = new na(e), this.intensity = void 0 !== t ? t : 1 } function wh(e, t, n) { _h.call(this, e, n), this.type = "HemisphereLight", this.position.copy(Ii.DefaultUp), this.updateMatrix(), this.groundColor = new na(t) } function Mh(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Er(512, 512), this.map = null, this.mapPass = null, this.matrix = new ci, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new po, this._frameExtents = new Er(1, 1), this._viewportCount = 1, this._viewports = [new Cr(0, 0, 1, 1)] } function Sh() { Mh.call(this, new ro(50, 1, .5, 500)), this.focus = 1 } function Th(e, t, n, r, i, a) { _h.call(this, e, t), this.type = "SpotLight", this.position.copy(Ii.DefaultUp), this.updateMatrix(), this.target = new Ii, Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (e) { this.intensity = e / Math.PI } }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Sh } function Eh() { Mh.call(this, new ro(90, 1, .5, 500)), this._frameExtents = new Er(4, 2), this._viewportCount = 6, this._viewports = [new Cr(2, 1, 1, 1), new Cr(0, 1, 1, 1), new Cr(3, 1, 1, 1), new Cr(1, 1, 1, 1), new Cr(3, 0, 1, 1), new Cr(1, 0, 1, 1)], this._cubeDirections = [new Nr(1, 0, 0), new Nr(-1, 0, 0), new Nr(0, 0, 1), new Nr(0, 0, -1), new Nr(0, 1, 0), new Nr(0, -1, 0)], this._cubeUps = [new Nr(0, 1, 0), new Nr(0, 1, 0), new Nr(0, 1, 0), new Nr(0, 1, 0), new Nr(0, 0, 1), new Nr(0, 0, -1)] } function Ah(e, t, n, r) { _h.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI }, set: function (e) { this.intensity = e / (4 * Math.PI) } }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new Eh } function Rh(e, t, n, r, i, a) { no.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== r ? r : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix() } function kh() { Mh.call(this, new Rh(-5, 5, 5, -5, .5, 500)) } function Lh(e, t) { _h.call(this, e, t), this.type = "DirectionalLight", this.position.copy(Ii.DefaultUp), this.updateMatrix(), this.target = new Ii, this.shadow = new kh } function Ch(e, t) { _h.call(this, e, t), this.type = "AmbientLight" } function Ph(e, t, n, r) { _h.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10 } yh.prototype = Object.assign(Object.create(Qu.prototype), { constructor: yh, add: function (e) { this.curves.push(e) }, closePath: function () { var e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new dh(t, e)) }, getPoint: function (e) { for (var t = e * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) { if (n[r] >= t) { var i = n[r] - t, a = this.curves[r], o = a.getLength(), s = 0 === o ? 0 : 1 - i / o; return a.getPointAt(s) } r++ } return null }, getLength: function () { var e = this.getCurveLengths(); return e[e.length - 1] }, updateArcLengths: function () { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++)t += this.curves[n].getLength(), e.push(t); return this.cacheLengths = e, e }, getSpacedPoints: function (e) { void 0 === e && (e = 40); for (var t = [], n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return this.autoClose && t.push(t[0]), t }, getPoints: function (e) { e = e || 12; for (var t, n = [], r = 0, i = this.curves; r < i.length; r++)for (var a = i[r], o = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e, s = a.getPoints(o), l = 0; l < s.length; l++) { var c = s[l]; t && t.equals(c) || (n.push(c), t = c) } return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n }, copy: function (e) { Qu.prototype.copy.call(this, e), this.curves = []; for (var t = 0, n = e.curves.length; t < n; t++) { var r = e.curves[t]; this.curves.push(r.clone()) } return this.autoClose = e.autoClose, this }, toJSON: function () { var e = Qu.prototype.toJSON.call(this); e.autoClose = this.autoClose, e.curves = []; for (var t = 0, n = this.curves.length; t < n; t++) { var r = this.curves[t]; e.curves.push(r.toJSON()) } return e }, fromJSON: function (e) { Qu.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = []; for (var t = 0, n = e.curves.length; t < n; t++) { var r = e.curves[t]; this.curves.push((new gh[r.type]).fromJSON(r)) } return this } }), bh.prototype = Object.assign(Object.create(yh.prototype), { constructor: bh, setFromPoints: function (e) { this.moveTo(e[0].x, e[0].y); for (var t = 1, n = e.length; t < n; t++)this.lineTo(e[t].x, e[t].y); return this }, moveTo: function (e, t) { return this.currentPoint.set(e, t), this }, lineTo: function (e, t) { var n = new dh(this.currentPoint.clone(), new Er(e, t)); return this.curves.push(n), this.currentPoint.set(e, t), this }, quadraticCurveTo: function (e, t, n, r) { var i = new fh(this.currentPoint.clone(), new Er(e, t), new Er(n, r)); return this.curves.push(i), this.currentPoint.set(n, r), this }, bezierCurveTo: function (e, t, n, r, i, a) { var o = new uh(this.currentPoint.clone(), new Er(e, t), new Er(n, r), new Er(i, a)); return this.curves.push(o), this.currentPoint.set(i, a), this }, splineThru: function (e) { var t = new vh([this.currentPoint.clone()].concat(e)); return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this }, arc: function (e, t, n, r, i, a) { var o = this.currentPoint.x, s = this.currentPoint.y; return this.absarc(e + o, t + s, n, r, i, a), this }, absarc: function (e, t, n, r, i, a) { return this.absellipse(e, t, n, n, r, i, a), this }, ellipse: function (e, t, n, r, i, a, o, s) { var l = this.currentPoint.x, c = this.currentPoint.y; return this.absellipse(e + l, t + c, n, r, i, a, o, s), this }, absellipse: function (e, t, n, r, i, a, o, s) { var l = new $u(e, t, n, r, i, a, o, s); if (this.curves.length > 0) { var c = l.getPoint(0); c.equals(this.currentPoint) || this.lineTo(c.x, c.y) } this.curves.push(l); var u = l.getPoint(1); return this.currentPoint.copy(u), this }, copy: function (e) { return yh.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this }, toJSON: function () { var e = yh.prototype.toJSON.call(this); return e.currentPoint = this.currentPoint.toArray(), e }, fromJSON: function (e) { return yh.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this } }), xh.prototype = Object.assign(Object.create(bh.prototype), { constructor: xh, getPointsHoles: function (e) { for (var t = [], n = 0, r = this.holes.length; n < r; n++)t[n] = this.holes[n].getPoints(e); return t }, extractPoints: function (e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } }, copy: function (e) { bh.prototype.copy.call(this, e), this.holes = []; for (var t = 0, n = e.holes.length; t < n; t++) { var r = e.holes[t]; this.holes.push(r.clone()) } return this }, toJSON: function () { var e = bh.prototype.toJSON.call(this); e.uuid = this.uuid, e.holes = []; for (var t = 0, n = this.holes.length; t < n; t++) { var r = this.holes[t]; e.holes.push(r.toJSON()) } return e }, fromJSON: function (e) { bh.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = []; for (var t = 0, n = e.holes.length; t < n; t++) { var r = e.holes[t]; this.holes.push((new bh).fromJSON(r)) } return this } }), _h.prototype = Object.assign(Object.create(Ii.prototype), { constructor: _h, isLight: !0, copy: function (e) { return Ii.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this }, toJSON: function (e) { var t = Ii.prototype.toJSON.call(this, e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } }), wh.prototype = Object.assign(Object.create(_h.prototype), { constructor: wh, isHemisphereLight: !0, copy: function (e) { return _h.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this } }), Object.assign(Mh.prototype, { _projScreenMatrix: new ci, _lightPositionWorld: new Nr, _lookTarget: new Nr, getViewportCount: function () { return this._viewportCount }, getFrustum: function () { return this._frustum }, updateMatrices: function (e) { var t = this.camera, n = this.matrix, r = this._projScreenMatrix, i = this._lookTarget, a = this._lightPositionWorld; a.setFromMatrixPosition(e.matrixWorld), t.position.copy(a), i.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(i), t.updateMatrixWorld(), r.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(r), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse) }, getViewport: function (e) { return this._viewports[e] }, getFrameExtents: function () { return this._frameExtents }, copy: function (e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { var e = {}; return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } }), Sh.prototype = Object.assign(Object.create(Mh.prototype), { constructor: Sh, isSpotLightShadow: !0, updateMatrices: function (e) { var t = this.camera, n = 2 * Tr.RAD2DEG * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, i = e.distance || t.far; n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), Mh.prototype.updateMatrices.call(this, e) } }), Th.prototype = Object.assign(Object.create(_h.prototype), { constructor: Th, isSpotLight: !0, copy: function (e) { return _h.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } }), Eh.prototype = Object.assign(Object.create(Mh.prototype), { constructor: Eh, isPointLightShadow: !0, updateMatrices: function (e, t) { void 0 === t && (t = 0); var n = this.camera, r = this.matrix, i = this._lightPositionWorld, a = this._lookTarget, o = this._projScreenMatrix; i.setFromMatrixPosition(e.matrixWorld), n.position.copy(i), a.copy(n.position), a.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(a), n.updateMatrixWorld(), r.makeTranslation(-i.x, -i.y, -i.z), o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(o) } }), Ah.prototype = Object.assign(Object.create(_h.prototype), { constructor: Ah, isPointLight: !0, copy: function (e) { return _h.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } }), Rh.prototype = Object.assign(Object.create(no.prototype), { constructor: Rh, isOrthographicCamera: !0, copy: function (e, t) { return no.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this }, setViewOffset: function (e, t, n, r, i, a) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2, i = n - e, a = n + e, o = r + t, s = r - t; if (null !== this.view && this.view.enabled) { var l = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom; a = (i += l * this.view.offsetX) + l * this.view.width, s = (o -= c * this.view.offsetY) - c * this.view.height } this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (e) { var t = Ii.prototype.toJSON.call(this, e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } }), kh.prototype = Object.assign(Object.create(Mh.prototype), { constructor: kh, isDirectionalLightShadow: !0, updateMatrices: function (e) { Mh.prototype.updateMatrices.call(this, e) } }), Lh.prototype = Object.assign(Object.create(_h.prototype), { constructor: Lh, isDirectionalLight: !0, copy: function (e) { return _h.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } }), Ch.prototype = Object.assign(Object.create(_h.prototype), { constructor: Ch, isAmbientLight: !0 }), Ph.prototype = Object.assign(Object.create(_h.prototype), { constructor: Ph, isRectAreaLight: !0, copy: function (e) { return _h.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this }, toJSON: function (e) { var t = _h.prototype.toJSON.call(this, e); return t.object.width = this.width, t.object.height = this.height, t } }); var Oh = function () { function e() { _classCallCheck(this, e), Object.defineProperty(this, "isSphericalHarmonics3", { value: !0 }), this.coefficients = []; for (var t = 0; t < 9; t++)this.coefficients.push(new Nr) } return _createClass(e, [{ key: "set", value: function (e) { for (var t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } }, { key: "zero", value: function () { for (var e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } }, { key: "getAt", value: function (e, t) { var n = e.x, r = e.y, i = e.z, a = this.coefficients; return t.copy(a[0]).multiplyScalar(.282095), t.addScaledVector(a[1], .488603 * r), t.addScaledVector(a[2], .488603 * i), t.addScaledVector(a[3], .488603 * n), t.addScaledVector(a[4], n * r * 1.092548), t.addScaledVector(a[5], r * i * 1.092548), t.addScaledVector(a[6], .315392 * (3 * i * i - 1)), t.addScaledVector(a[7], n * i * 1.092548), t.addScaledVector(a[8], .546274 * (n * n - r * r)), t } }, { key: "getIrradianceAt", value: function (e, t) { var n = e.x, r = e.y, i = e.z, a = this.coefficients; return t.copy(a[0]).multiplyScalar(.886227), t.addScaledVector(a[1], 1.023328 * r), t.addScaledVector(a[2], 1.023328 * i), t.addScaledVector(a[3], 1.023328 * n), t.addScaledVector(a[4], .858086 * n * r), t.addScaledVector(a[5], .858086 * r * i), t.addScaledVector(a[6], .743125 * i * i - .247708), t.addScaledVector(a[7], .858086 * n * i), t.addScaledVector(a[8], .429043 * (n * n - r * r)), t } }, { key: "add", value: function (e) { for (var t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } }, { key: "addScaledSH", value: function (e, t) { for (var n = 0; n < 9; n++)this.coefficients[n].addScaledVector(e.coefficients[n], t); return this } }, { key: "scale", value: function (e) { for (var t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } }, { key: "lerp", value: function (e, t) { for (var n = 0; n < 9; n++)this.coefficients[n].lerp(e.coefficients[n], t); return this } }, { key: "equals", value: function (e) { for (var t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } }, { key: "copy", value: function (e) { return this.set(e.coefficients) } }, { key: "clone", value: function () { return (new this.constructor).copy(this) } }, { key: "fromArray", value: function (e, t) { void 0 === t && (t = 0); for (var n = this.coefficients, r = 0; r < 9; r++)n[r].fromArray(e, t + 3 * r); return this } }, { key: "toArray", value: function (e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); for (var n = this.coefficients, r = 0; r < 9; r++)n[r].toArray(e, t + 3 * r); return e } }], [{ key: "getBasisAt", value: function (e, t) { var n = e.x, r = e.y, i = e.z; t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r) } }]), e }(); function Ih(e, t) { _h.call(this, void 0, t), this.type = "LightProbe", this.sh = void 0 !== e ? e : new Oh } function Nh(e) { Vu.call(this, e), this.textures = {} } Ih.prototype = Object.assign(Object.create(_h.prototype), { constructor: Ih, isLightProbe: !0, copy: function (e) { return _h.prototype.copy.call(this, e), this.sh.copy(e.sh), this }, fromJSON: function (e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this }, toJSON: function (e) { var t = _h.prototype.toJSON.call(this, e); return t.object.sh = this.sh.toArray(), t } }), Nh.prototype = Object.assign(Object.create(Vu.prototype), { constructor: Nh, load: function (e, t, n, r) { var i = this, a = new Wu(i.manager); a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, function (n) { try { t(i.parse(JSON.parse(n))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, n, r) }, parse: function (e) { var t = this.textures; function n(e) { return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e] } var r = new Tu[e.type]; if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = (new na).setHex(e.sheen)), void 0 !== e.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && r.specular.setHex(e.specular), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (r.skinning = e.skinning), void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets), void 0 !== e.morphNormals && (r.morphNormals = e.morphNormals), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.vertexTangents && (r.vertexTangents = e.vertexTangents), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), void 0 !== e.uniforms) for (var i in e.uniforms) { var a = e.uniforms[i]; switch (r.uniforms[i] = {}, a.type) { case "t": r.uniforms[i].value = n(a.value); break; case "c": r.uniforms[i].value = (new na).setHex(a.value); break; case "v2": r.uniforms[i].value = (new Er).fromArray(a.value); break; case "v3": r.uniforms[i].value = (new Nr).fromArray(a.value); break; case "v4": r.uniforms[i].value = (new Cr).fromArray(a.value); break; case "m3": r.uniforms[i].value = (new Ar).fromArray(a.value); break; case "m4": r.uniforms[i].value = (new ci).fromArray(a.value); break; default: r.uniforms[i].value = a.value } } if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.extensions) for (var o in e.extensions) r.extensions[o] = e.extensions[o]; if (void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) { var s = e.normalScale; !1 === Array.isArray(s) && (s = [s, s]), r.normalScale = (new Er).fromArray(s) } return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new Er).fromArray(e.clearcoatNormalScale)), void 0 !== e.transmission && (r.transmission = e.transmission), void 0 !== e.transmissionMap && (r.transmissionMap = n(e.transmissionMap)), r }, setTextures: function (e) { return this.textures = e, this } }); var Dh = { decodeText: function (e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); for (var t = "", n = 0, r = e.length; n < r; n++)t += String.fromCharCode(e[n]); try { return decodeURIComponent(escape(t)) } catch (e) { return t } }, extractUrlBase: function (e) { var t = e.lastIndexOf("/"); return -1 === t ? "./" : e.substr(0, t + 1) } }; function Fh() { Ra.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } function Uh(e, t, n, r) { "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), ca.call(this, e, t, n), this.meshPerAttribute = r || 1 } function zh(e) { Vu.call(this, e) } Fh.prototype = Object.assign(Object.create(Ra.prototype), { constructor: Fh, isInstancedBufferGeometry: !0, copy: function (e) { return Ra.prototype.copy.call(this, e), this.instanceCount = e.instanceCount, this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { var e = Ra.prototype.toJSON.call(this); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } }), Uh.prototype = Object.assign(Object.create(ca.prototype), { constructor: Uh, isInstancedBufferAttribute: !0, copy: function (e) { return ca.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this }, toJSON: function () { var e = ca.prototype.toJSON.call(this); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } }), zh.prototype = Object.assign(Object.create(Vu.prototype), { constructor: zh, load: function (e, t, n, r) { var i = this, a = new Wu(i.manager); a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, function (n) { try { t(i.parse(JSON.parse(n))) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, n, r) }, parse: function (e) { var t = {}, n = {}; function r(e, r) { if (void 0 !== t[r]) return t[r]; var i = e.interleavedBuffers[r], a = function (e, t) { if (void 0 !== n[t]) return n[t]; var r = e.arrayBuffers[t], i = new Uint32Array(r).buffer; return n[t] = i, i }(e, i.buffer), o = new Sl(new Hh[i.type](a), i.stride); return o.uuid = i.uuid, t[r] = o, o } var i = e.isInstancedBufferGeometry ? new Fh : new Ra, a = e.data.index; if (void 0 !== a) { var o = new Hh[a.type](a.array); i.setIndex(new ca(o, 1)) } var s = e.data.attributes; for (var l in s) { var c = s[l], u = void 0; if (c.isInterleavedBufferAttribute) { u = new Al(r(e.data, c.data), c.itemSize, c.offset, c.normalized) } else { var h = new Hh[c.type](c.array); u = new (c.isInstancedBufferAttribute ? Uh : ca)(h, c.itemSize, c.normalized) } void 0 !== c.name && (u.name = c.name), i.setAttribute(l, u) } var d = e.data.morphAttributes; if (d) for (var p in d) { for (var f = d[p], m = [], v = 0, g = f.length; v < g; v++) { var y = f[v], b = void 0; if (y.isInterleavedBufferAttribute) b = new Al(r(e.data, y.data), y.itemSize, y.offset, y.normalized); else b = new ca(new Hh[y.type](y.array), y.itemSize, y.normalized); void 0 !== y.name && (b.name = y.name), m.push(b) } i.morphAttributes[p] = m } e.data.morphTargetsRelative && (i.morphTargetsRelative = !0); var x = e.data.groups || e.data.drawcalls || e.data.offsets; if (void 0 !== x) for (var _ = 0, w = x.length; _ !== w; ++_) { var M = x[_]; i.addGroup(M.start, M.count, M.materialIndex) } var S = e.data.boundingSphere; if (void 0 !== S) { var T = new Nr; void 0 !== S.center && T.fromArray(S.center), i.boundingSphere = new ei(T, S.radius) } return e.name && (i.name = e.name), e.userData && (i.userData = e.userData), i } }); var Bh, Hh = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function Gh(e) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Vu.call(this, e), this.options = { premultiplyAlpha: "none" } } function Vh() { this.type = "ShapePath", this.color = new na, this.subPaths = [], this.currentPath = null } function jh(e) { this.type = "Font", this.data = e } function Wh(e, t, n, r, i) { var a = i.glyphs[e] || i.glyphs["?"]; if (a) { var o, s, l, c, u, h, d, p, f = new Vh; if (a.o) for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), v = 0, g = m.length; v < g;) { switch (m[v++]) { case "m": o = m[v++] * t + n, s = m[v++] * t + r, f.moveTo(o, s); break; case "l": o = m[v++] * t + n, s = m[v++] * t + r, f.lineTo(o, s); break; case "q": l = m[v++] * t + n, c = m[v++] * t + r, u = m[v++] * t + n, h = m[v++] * t + r, f.quadraticCurveTo(u, h, l, c); break; case "b": l = m[v++] * t + n, c = m[v++] * t + r, u = m[v++] * t + n, h = m[v++] * t + r, d = m[v++] * t + n, p = m[v++] * t + r, f.bezierCurveTo(u, h, d, p, l, c) } } return { offsetX: a.ha * t, path: f } } console.error('THREE.Font: character "' + e + '" does not exists in font family ' + i.familyName + ".") } function qh(e) { Vu.call(this, e) } Gh.prototype = Object.assign(Object.create(Vu.prototype), { constructor: Gh, isImageBitmapLoader: !0, setOptions: function (e) { return this.options = e, this }, load: function (e, t, n, r) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); var i = this, a = Hu.get(e); if (void 0 !== a) return i.manager.itemStart(e), setTimeout(function () { t && t(a), i.manager.itemEnd(e) }, 0), a; var o = {}; o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", fetch(e, o).then(function (e) { return e.blob() }).then(function (e) { return createImageBitmap(e, i.options) }).then(function (n) { Hu.add(e, n), t && t(n), i.manager.itemEnd(e) }).catch(function (t) { r && r(t), i.manager.itemError(e), i.manager.itemEnd(e) }), i.manager.itemStart(e) } }), Object.assign(Vh.prototype, { moveTo: function (e, t) { return this.currentPath = new bh, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this }, lineTo: function (e, t) { return this.currentPath.lineTo(e, t), this }, quadraticCurveTo: function (e, t, n, r) { return this.currentPath.quadraticCurveTo(e, t, n, r), this }, bezierCurveTo: function (e, t, n, r, i, a) { return this.currentPath.bezierCurveTo(e, t, n, r, i, a), this }, splineThru: function (e) { return this.currentPath.splineThru(e), this }, toShapes: function (e, t) { function n(e) { for (var t = [], n = 0, r = e.length; n < r; n++) { var i = e[n], a = new xh; a.curves = i.curves, t.push(a) } return t } function r(e, t) { for (var n = t.length, r = !1, i = n - 1, a = 0; a < n; i = a++) { var o = t[i], s = t[a], l = s.x - o.x, c = s.y - o.y; if (Math.abs(c) > Number.EPSILON) { if (c < 0 && (o = t[a], l = -l, s = t[i], c = -c), e.y < o.y || e.y > s.y) continue; if (e.y === o.y) { if (e.x === o.x) return !0 } else { var u = c * (e.x - o.x) - l * (e.y - o.y); if (0 === u) return !0; if (u < 0) continue; r = !r } } else { if (e.y !== o.y) continue; if (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x) return !0 } } return r } var i, a, o, s = au.isClockWise, l = this.subPaths; if (0 === l.length) return []; if (!0 === t) return n(l); var c = []; if (1 === l.length) return a = l[0], (o = new xh).curves = a.curves, c.push(o), c; var u = !s(l[0].getPoints()); u = e ? !u : u; var h, d, p = [], f = [], m = [], v = 0; f[v] = void 0, m[v] = []; for (var g = 0, y = l.length; g < y; g++)i = s(h = (a = l[g]).getPoints()), (i = e ? !i : i) ? (!u && f[v] && v++, f[v] = { s: new xh, p: h }, f[v].s.curves = a.curves, u && v++, m[v] = []) : m[v].push({ h: a, p: h[0] }); if (!f[0]) return n(l); if (f.length > 1) { for (var b = !1, x = [], _ = 0, w = f.length; _ < w; _++)p[_] = []; for (var M = 0, S = f.length; M < S; M++)for (var T = m[M], E = 0; E < T.length; E++) { for (var A = T[E], R = !0, k = 0; k < f.length; k++)r(A.p, f[k].p) && (M !== k && x.push({ froms: M, tos: k, hole: E }), R ? (R = !1, p[k].push(A)) : b = !0); R && p[M].push(A) } x.length > 0 && (b || (m = p)) } for (var L = 0, C = f.length; L < C; L++) { o = f[L].s, c.push(o); for (var P = 0, O = (d = m[L]).length; P < O; P++)o.holes.push(d[P].h) } return c } }), Object.assign(jh.prototype, { isFont: !0, generateShapes: function (e, t) { void 0 === t && (t = 100); for (var n = [], r = function (e, t, n) { for (var r = Array.from ? Array.from(e) : String(e).split(""), i = t / n.resolution, a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, o = [], s = 0, l = 0, c = 0; c < r.length; c++) { var u = r[c]; if ("\n" === u) s = 0, l -= a; else { var h = Wh(u, i, s, l, n); s += h.offsetX, o.push(h.path) } } return o }(e, t, this.data), i = 0, a = r.length; i < a; i++)Array.prototype.push.apply(n, r[i].toShapes()); return n } }), qh.prototype = Object.assign(Object.create(Vu.prototype), { constructor: qh, load: function (e, t, n, r) { var i = this, a = new Wu(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, function (e) { var n; try { n = JSON.parse(e) } catch (t) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2)) } var r = i.parse(n); t && t(r) }, n, r) }, parse: function (e) { return new jh(e) } }); var Xh = function () { return void 0 === Bh && (Bh = new (window.AudioContext || window.webkitAudioContext)), Bh }; function Yh(e) { Vu.call(this, e) } function Jh(e, t, n) { Ih.call(this, void 0, n); var r = (new na).set(e), i = (new na).set(t), a = new Nr(r.r, r.g, r.b), o = new Nr(i.r, i.g, i.b), s = Math.sqrt(Math.PI), l = s * Math.sqrt(.75); this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s), this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(l) } function Zh(e, t) { Ih.call(this, void 0, t); var n = (new na).set(e); this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } Yh.prototype = Object.assign(Object.create(Vu.prototype), { constructor: Yh, load: function (e, t, n, r) { var i = this, a = new Wu(i.manager); a.setResponseType("arraybuffer"), a.setPath(i.path), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(e, function (n) { try { var a = n.slice(0); Xh().decodeAudioData(a, function (e) { t(e) }) } catch (t) { r ? r(t) : console.error(t), i.manager.itemError(e) } }, n, r) } }), Jh.prototype = Object.assign(Object.create(Ih.prototype), { constructor: Jh, isHemisphereLightProbe: !0, copy: function (e) { return Ih.prototype.copy.call(this, e), this }, toJSON: function (e) { return Ih.prototype.toJSON.call(this, e) } }), Zh.prototype = Object.assign(Object.create(Ih.prototype), { constructor: Zh, isAmbientLightProbe: !0, copy: function (e) { return Ih.prototype.copy.call(this, e), this }, toJSON: function (e) { return Ih.prototype.toJSON.call(this, e) } }); var Kh = new ci, Qh = new ci; Object.assign(function () { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ro, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ro, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } }.prototype, { update: function (e) { var t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep; var n, r, i = e.projectionMatrix.clone(), a = t.eyeSep / 2, o = a * t.near / t.focus, s = t.near * Math.tan(Tr.DEG2RAD * t.fov * .5) / t.zoom; Qh.elements[12] = -a, Kh.elements[12] = a, n = -s * t.aspect + o, r = s * t.aspect + o, i.elements[0] = 2 * t.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraL.projectionMatrix.copy(i), n = -s * t.aspect - o, r = s * t.aspect - o, i.elements[0] = 2 * t.near / (r - n), i.elements[8] = (r + n) / (r - n), this.cameraR.projectionMatrix.copy(i) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Qh), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Kh) } }); var $h = function (e) { _inherits(n, Ii); var t = _createSuper(n); function n(e) { var r; return _classCallCheck(this, n), (r = t.call(this)).type = "Audio", r.listener = e, r.context = e.context, r.gain = r.context.createGain(), r.gain.connect(e.getInput()), r.autoplay = !1, r.buffer = null, r.detune = 0, r.loop = !1, r.loopStart = 0, r.loopEnd = 0, r.offset = 0, r.duration = void 0, r.playbackRate = 1, r.isPlaying = !1, r.hasPlaybackControl = !0, r.source = null, r.sourceType = "empty", r._startedAt = 0, r._progress = 0, r._connected = !1, r.filters = [], r } return _createClass(n, [{ key: "getOutput", value: function () { return this.gain } }, { key: "setNodeSource", value: function (e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } }, { key: "setMediaElementSource", value: function (e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } }, { key: "setMediaStreamSource", value: function (e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } }, { key: "setBuffer", value: function (e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } }, { key: "play", value: function (e) { if (void 0 === e && (e = 0), !0 !== this.isPlaying) { if (!1 !== this.hasPlaybackControl) { this._startedAt = this.context.currentTime + e; var t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } console.warn("THREE.Audio: this Audio has no playback control.") } else console.warn("THREE.Audio: Audio is already playing.") } }, { key: "pause", value: function () { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") } }, { key: "stop", value: function () { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") } }, { key: "connect", value: function () { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (var e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } }, { key: "disconnect", value: function () { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (var e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } }, { key: "getFilters", value: function () { return this.filters } }, { key: "setFilters", value: function (e) { return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this } }, { key: "setDetune", value: function (e) { if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } }, { key: "getDetune", value: function () { return this.detune } }, { key: "getFilter", value: function () { return this.getFilters()[0] } }, { key: "setFilter", value: function (e) { return this.setFilters(e ? [e] : []) } }, { key: "setPlaybackRate", value: function (e) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") } }, { key: "getPlaybackRate", value: function () { return this.playbackRate } }, { key: "onEnded", value: function () { this.isPlaying = !1 } }, { key: "getLoop", value: function () { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } }, { key: "setLoop", value: function (e) { if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") } }, { key: "setLoopStart", value: function (e) { return this.loopStart = e, this } }, { key: "setLoopEnd", value: function (e) { return this.loopEnd = e, this } }, { key: "getVolume", value: function () { return this.gain.gain.value } }, { key: "setVolume", value: function (e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } }]), n }(); function ed(e, t, n) { var r, i, a; switch (this.binding = e, this.valueSize = n, t) { case "quaternion": r = this._slerp, i = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5; break; case "string": case "bool": r = this._select, i = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n); break; default: r = this._lerp, i = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } Object.assign(ed.prototype, { accumulate: function (e, t) { var n = this.buffer, r = this.valueSize, i = e * r + r, a = this.cumulativeWeight; if (0 === a) { for (var o = 0; o !== r; ++o)n[i + o] = n[o]; a = t } else { var s = t / (a += t); this._mixBufferRegion(n, i, 0, s, r) } this.cumulativeWeight = a }, accumulateAdditive: function (e) { var t = this.buffer, n = this.valueSize, r = n * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e }, apply: function (e) { var t = this.valueSize, n = this.buffer, r = e * t + t, i = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) { var s = t * this._origIndex; this._mixBufferRegion(n, r, s, 1 - i, t) } a > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t); for (var l = t, c = t + t; l !== c; ++l)if (n[l] !== n[l + t]) { o.setValue(n, r); break } }, saveOriginalState: function () { var e = this.binding, t = this.buffer, n = this.valueSize, r = n * this._origIndex; e.getValue(t, r); for (var i = n, a = r; i !== a; ++i)t[i] = t[r + i % n]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 }, restoreOriginalState: function () { var e = 3 * this.valueSize; this.binding.setValue(this.buffer, e) }, _setAdditiveIdentityNumeric: function () { for (var e = this._addIndex * this.valueSize, t = e + this.valueSize, n = e; n < t; n++)this.buffer[n] = 0 }, _setAdditiveIdentityQuaternion: function () { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 }, _setAdditiveIdentityOther: function () { for (var e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize, n = 0; n < this.valueSize; n++)this.buffer[t + n] = this.buffer[e + n] }, _select: function (e, t, n, r, i) { if (r >= .5) for (var a = 0; a !== i; ++a)e[t + a] = e[n + a] }, _slerp: function (e, t, n, r) { Ir.slerpFlat(e, t, e, t, e, n, r) }, _slerpAdditive: function (e, t, n, r, i) { var a = this._workIndex * i; Ir.multiplyQuaternionsFlat(e, a, e, t, e, n), Ir.slerpFlat(e, t, e, t, e, a, r) }, _lerp: function (e, t, n, r, i) { for (var a = 1 - r, o = 0; o !== i; ++o) { var s = t + o; e[s] = e[s] * a + e[n + o] * r } }, _lerpAdditive: function (e, t, n, r, i) { for (var a = 0; a !== i; ++a) { var o = t + a; e[o] = e[o] + e[n + a] * r } } }); var td = new RegExp("[\\[\\]\\.:\\/]", "g"), nd = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", rd = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), id = /(WCOD+)?/.source.replace("WCOD", nd), ad = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), od = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), sd = new RegExp("^" + rd + id + ad + od + "$"), ld = ["material", "materials", "bones"]; function cd(e, t, n) { var r = n || ud.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, r) } function ud(e, t, n) { this.path = t, this.parsedPath = n || ud.parseTrackName(t), this.node = ud.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e } Object.assign(cd.prototype, { getValue: function (e, t) { this.bind(); var n = this._targetGroup.nCachedObjects_, r = this._bindings[n]; void 0 !== r && r.getValue(e, t) }, setValue: function (e, t) { for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r)n[r].setValue(e, t) }, bind: function () { for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].bind() }, unbind: function () { for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].unbind() } }), Object.assign(ud, { Composite: cd, create: function (e, t, n) { return e && e.isAnimationObjectGroup ? new ud.Composite(e, t, n) : new ud(e, t, n) }, sanitizeNodeName: function (e) { return e.replace(/\s/g, "_").replace(td, "") }, parseTrackName: function (e) { var t = sd.exec(e); if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); var n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== r && -1 !== r) { var i = n.nodeName.substring(r + 1); -1 !== ld.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return n }, findNode: function (e, t) { if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e; if (e.skeleton) { var n = e.skeleton.getBoneByName(t); if (void 0 !== n) return n } if (e.children) { var r = function e(n) { for (var r = 0; r < n.length; r++) { var i = n[r]; if (i.name === t || i.uuid === t) return i; var a = e(i.children); if (a) return a } return null }(e.children); if (r) return r } return null } }), Object.assign(ud.prototype, { _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (e, t) { e[t] = this.node[this.propertyName] }, function (e, t) { for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r)e[t++] = n[r] }, function (e, t) { e[t] = this.resolvedProperty[this.propertyIndex] }, function (e, t) { this.resolvedProperty.toArray(e, t) }], SetterByBindingTypeAndVersioning: [[function (e, t) { this.targetObject[this.propertyName] = e[t] }, function (e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 }, function (e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (e, t) { for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r)n[r] = e[t++] }, function (e, t) { for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r)n[r] = e[t++]; this.targetObject.needsUpdate = !0 }, function (e, t) { for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r)n[r] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (e, t) { this.resolvedProperty[this.propertyIndex] = e[t] }, function (e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 }, function (e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (e, t) { this.resolvedProperty.fromArray(e, t) }, function (e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 }, function (e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 }]], getValue: function (e, t) { this.bind(), this.getValue(e, t) }, setValue: function (e, t) { this.bind(), this.setValue(e, t) }, bind: function () { var e = this.node, t = this.parsedPath, n = t.objectName, r = t.propertyName, i = t.propertyIndex; if (e || (e = ud.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) { if (n) { var a = t.objectIndex; switch (n) { case "materials": if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); e = e.material.materials; break; case "bones": if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); e = e.skeleton.bones; for (var o = 0; o < e.length; o++)if (e[o].name === a) { a = o; break } break; default: if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); e = e[n] }if (void 0 !== a) { if (void 0 === e[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); e = e[a] } } var s = e[r]; if (void 0 !== s) { var l = this.Versioning.None; this.targetObject = e, void 0 !== e.needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate); var c = this.BindingType.Direct; if (void 0 !== i) { if ("morphTargetInfluences" === r) { if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i]) } c = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i } else void 0 !== s.fromArray && void 0 !== s.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (c = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r; this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l] } else { var u = t.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + r + " but it wasn't found.", e) } } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.") }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }), Object.assign(ud.prototype, { _getValue_unbound: ud.prototype.getValue, _setValue_unbound: ud.prototype.setValue }), Object.assign(function () { this.uuid = Tr.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; var e = {}; this._indicesByUUID = e; for (var t = 0, n = arguments.length; t !== n; ++t)e[arguments[t].uuid] = t; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; var r = this; this.stats = { objects: { get total() { return r._objects.length }, get inUse() { return this.total - r.nCachedObjects_ } }, get bindingsPerObject() { return r._bindings.length } } }.prototype, { isAnimationObjectGroup: !0, add: function () { for (var e = this._objects, t = this._indicesByUUID, n = this._paths, r = this._parsedPaths, i = this._bindings, a = i.length, o = void 0, s = e.length, l = this.nCachedObjects_, c = 0, u = arguments.length; c !== u; ++c) { var h = arguments[c], d = h.uuid, p = t[d]; if (void 0 === p) { p = s++, t[d] = p, e.push(h); for (var f = 0, m = a; f !== m; ++f)i[f].push(new ud(h, n[f], r[f])) } else if (p < l) { o = e[p]; var v = --l, g = e[v]; t[g.uuid] = p, e[p] = g, t[d] = v, e[v] = h; for (var y = 0, b = a; y !== b; ++y) { var x = i[y], _ = x[v], w = x[p]; x[p] = _, void 0 === w && (w = new ud(h, n[y], r[y])), x[v] = w } } else e[p] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = l }, remove: function () { for (var e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length, i = this.nCachedObjects_, a = 0, o = arguments.length; a !== o; ++a) { var s = arguments[a], l = s.uuid, c = t[l]; if (void 0 !== c && c >= i) { var u = i++, h = e[u]; t[h.uuid] = c, e[c] = h, t[l] = u, e[u] = s; for (var d = 0, p = r; d !== p; ++d) { var f = n[d], m = f[u], v = f[c]; f[c] = m, f[u] = v } } } this.nCachedObjects_ = i }, uncache: function () { for (var e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length, i = this.nCachedObjects_, a = e.length, o = 0, s = arguments.length; o !== s; ++o) { var l = arguments[o].uuid, c = t[l]; if (void 0 !== c) if (delete t[l], c < i) { var u = --i, h = e[u], d = --a, p = e[d]; t[h.uuid] = c, e[c] = h, t[p.uuid] = u, e[u] = p, e.pop(); for (var f = 0, m = r; f !== m; ++f) { var v = n[f], g = v[u], y = v[d]; v[c] = g, v[u] = y, v.pop() } } else { var b = --a, x = e[b]; t[x.uuid] = c, e[c] = x, e.pop(); for (var _ = 0, w = r; _ !== w; ++_) { var M = n[_]; M[c] = M[b], M.pop() } } } this.nCachedObjects_ = i }, subscribe_: function (e, t) { var n = this._bindingsIndicesByPath, r = n[e], i = this._bindings; if (void 0 !== r) return i[r]; var a = this._paths, o = this._parsedPaths, s = this._objects, l = s.length, c = this.nCachedObjects_, u = new Array(l); r = i.length, n[e] = r, a.push(e), o.push(t), i.push(u); for (var h = c, d = s.length; h !== d; ++h) { var p = s[h]; u[h] = new ud(p, e, t) } return u }, unsubscribe_: function (e) { var t = this._bindingsIndicesByPath, n = t[e]; if (void 0 !== n) { var r = this._paths, i = this._parsedPaths, a = this._bindings, o = a.length - 1, s = a[o]; t[e[o]] = n, a[n] = s, a.pop(), i[n] = i[o], i.pop(), r[n] = r[o], r.pop() } } }); var hd = function () { function e(t, n, r, i) { _classCallCheck(this, e), this._mixer = t, this._clip = n, this._localRoot = r || null, this.blendMode = i || n.blendMode; for (var a = n.tracks, o = a.length, s = new Array(o), l = { endingStart: tr, endingEnd: tr }, c = 0; c !== o; ++c) { var u = a[c].createInterpolant(null); s[c] = u, u.settings = l } this._interpolantSettings = l, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = $n, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } return _createClass(e, [{ key: "play", value: function () { return this._mixer._activateAction(this), this } }, { key: "stop", value: function () { return this._mixer._deactivateAction(this), this.reset() } }, { key: "reset", value: function () { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } }, { key: "isRunning", value: function () { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } }, { key: "isScheduled", value: function () { return this._mixer._isActiveAction(this) } }, { key: "startAt", value: function (e) { return this._startTime = e, this } }, { key: "setLoop", value: function (e, t) { return this.loop = e, this.repetitions = t, this } }, { key: "setEffectiveWeight", value: function (e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } }, { key: "getEffectiveWeight", value: function () { return this._effectiveWeight } }, { key: "fadeIn", value: function (e) { return this._scheduleFading(e, 0, 1) } }, { key: "fadeOut", value: function (e) { return this._scheduleFading(e, 1, 0) } }, { key: "crossFadeFrom", value: function (e, t, n) { if (e.fadeOut(t), this.fadeIn(t), n) { var r = this._clip.duration, i = e._clip.duration, a = i / r, o = r / i; e.warp(1, a, t), this.warp(o, 1, t) } return this } }, { key: "crossFadeTo", value: function (e, t, n) { return e.crossFadeFrom(this, t, n) } }, { key: "stopFading", value: function () { var e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } }, { key: "setEffectiveTimeScale", value: function (e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } }, { key: "getEffectiveTimeScale", value: function () { return this._effectiveTimeScale } }, { key: "setDuration", value: function (e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } }, { key: "syncWith", value: function (e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } }, { key: "halt", value: function (e) { return this.warp(this._effectiveTimeScale, 0, e) } }, { key: "warp", value: function (e, t, n) { var r = this._mixer, i = r.time, a = this.timeScale, o = this._timeScaleInterpolant; null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o); var s = o.parameterPositions, l = o.sampleValues; return s[0] = i, s[1] = i + n, l[0] = e / a, l[1] = t / a, this } }, { key: "stopWarping", value: function () { var e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } }, { key: "getMixer", value: function () { return this._mixer } }, { key: "getClip", value: function () { return this._clip } }, { key: "getRoot", value: function () { return this._localRoot || this._mixer._root } }, { key: "_update", value: function (e, t, n, r) { if (this.enabled) { var i = this._startTime; if (null !== i) { var a = (e - i) * n; if (a < 0 || 0 === n) return; this._startTime = null, t = n * a } t *= this._updateTimeScale(e); var o = this._updateTime(t), s = this._updateWeight(e); if (s > 0) { var l = this._interpolants, c = this._propertyBindings; switch (this.blendMode) { case 2501: for (var u = 0, h = l.length; u !== h; ++u)l[u].evaluate(o), c[u].accumulateAdditive(s); break; case nr: default: for (var d = 0, p = l.length; d !== p; ++d)l[d].evaluate(o), c[d].accumulate(r, s) } } } else this._updateWeight(e) } }, { key: "_updateWeight", value: function (e) { var t = 0; if (this.enabled) { t = this.weight; var n = this._weightInterpolant; if (null !== n) { var r = n.evaluate(e)[0]; t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1)) } } return this._effectiveWeight = t, t } }, { key: "_updateTimeScale", value: function (e) { var t = 0; if (!this.paused) { t = this.timeScale; var n = this._timeScaleInterpolant; if (null !== n) t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t) } return this._effectiveTimeScale = t, t } }, { key: "_updateTime", value: function (e) { var t = this._clip.duration, n = this.loop, r = this.time + e, i = this._loopCount, a = 2202 === n; if (0 === e) return -1 === i ? r : a && 1 == (1 & i) ? t - r : r; if (2200 === n) { -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= t) r = t; else { if (!(r < 0)) { this.time = r; break e } r = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), r >= t || r < 0) { var o = Math.floor(r / t); r -= t * o, i += Math.abs(o); var s = this.repetitions - i; if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (1 === s) { var l = e < 0; this._setEndings(l, !l, a) } else this._setEndings(!1, !1, a); this._loopCount = i, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: o }) } } else this.time = r; if (a && 1 == (1 & i)) return t - r } return r } }, { key: "_setEndings", value: function (e, t, n) { var r = this._interpolantSettings; n ? (r.endingStart = 2401, r.endingEnd = 2401) : (r.endingStart = e ? this.zeroSlopeAtStart ? 2401 : tr : 2402, r.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : tr : 2402) } }, { key: "_scheduleFading", value: function (e, t, n) { var r = this._mixer, i = r.time, a = this._weightInterpolant; null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a); var o = a.parameterPositions, s = a.sampleValues; return o[0] = i, s[0] = t, o[1] = i + e, s[1] = n, this } }]), e }(); function dd(e) { this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } dd.prototype = Object.assign(Object.create(xr.prototype), { constructor: dd, _bindAction: function (e, t) { var n = e._localRoot || this._root, r = e._clip.tracks, i = r.length, a = e._propertyBindings, o = e._interpolants, s = n.uuid, l = this._bindingsByRootAndName, c = l[s]; void 0 === c && (c = {}, l[s] = c); for (var u = 0; u !== i; ++u) { var h = r[u], d = h.name, p = c[d]; if (void 0 !== p) a[u] = p; else { if (void 0 !== (p = a[u])) { null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d)); continue } var f = t && t._propertyBindings[u].binding.parsedPath; ++(p = new ed(ud.create(n, d, f), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), a[u] = p } o[u].resultBuffer = p.buffer } }, _activateAction: function (e) { if (!this._isActiveAction(e)) { if (null === e._cacheIndex) { var t = (e._localRoot || this._root).uuid, n = e._clip.uuid, r = this._actionsByClip[n]; this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t) } for (var i = e._propertyBindings, a = 0, o = i.length; a !== o; ++a) { var s = i[a]; 0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState()) } this._lendAction(e) } }, _deactivateAction: function (e) { if (this._isActiveAction(e)) { for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) { var i = t[n]; 0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i)) } this._takeBackAction(e) } }, _initMemoryManager: function () { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; var e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } }, _isActiveAction: function (e) { var t = e._cacheIndex; return null !== t && t < this._nActiveActions }, _addInactiveAction: function (e, t, n) { var r = this._actions, i = this._actionsByClip, a = i[t]; if (void 0 === a) a = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, i[t] = a; else { var o = a.knownActions; e._byClipCacheIndex = o.length, o.push(e) } e._cacheIndex = r.length, r.push(e), a.actionByRoot[n] = e }, _removeInactiveAction: function (e) { var t = this._actions, n = t[t.length - 1], r = e._cacheIndex; n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null; var i = e._clip.uuid, a = this._actionsByClip, o = a[i], s = o.knownActions, l = s[s.length - 1], c = e._byClipCacheIndex; l._byClipCacheIndex = c, s[c] = l, s.pop(), e._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete a[i], this._removeInactiveBindingsForAction(e) }, _removeInactiveBindingsForAction: function (e) { for (var t = e._propertyBindings, n = 0, r = t.length; n !== r; ++n) { var i = t[n]; 0 == --i.referenceCount && this._removeInactiveBinding(i) } }, _lendAction: function (e) { var t = this._actions, n = e._cacheIndex, r = this._nActiveActions++, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i }, _takeBackAction: function (e) { var t = this._actions, n = e._cacheIndex, r = --this._nActiveActions, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i }, _addInactiveBinding: function (e, t, n) { var r = this._bindingsByRootAndName, i = this._bindings, a = r[t]; void 0 === a && (a = {}, r[t] = a), a[n] = e, e._cacheIndex = i.length, i.push(e) }, _removeInactiveBinding: function (e) { var t = this._bindings, n = e.binding, r = n.rootNode.uuid, i = n.path, a = this._bindingsByRootAndName, o = a[r], s = t[t.length - 1], l = e._cacheIndex; s._cacheIndex = l, t[l] = s, t.pop(), delete o[i], 0 === Object.keys(o).length && delete a[r] }, _lendBinding: function (e) { var t = this._bindings, n = e._cacheIndex, r = this._nActiveBindings++, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i }, _takeBackBinding: function (e) { var t = this._bindings, n = e._cacheIndex, r = --this._nActiveBindings, i = t[r]; e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i }, _lendControlInterpolant: function () { var e = this._controlInterpolants, t = this._nActiveControlInterpolants++, n = e[t]; return void 0 === n && ((n = new ku(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = n), n }, _takeBackControlInterpolant: function (e) { var t = this._controlInterpolants, n = e.__cacheIndex, r = --this._nActiveControlInterpolants, i = t[r]; e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (e, t, n) { var r = t || this._root, i = r.uuid, a = "string" == typeof e ? zu.findByName(r, e) : e, o = null !== a ? a.uuid : e, s = this._actionsByClip[o], l = null; if (void 0 === n && (n = null !== a ? a.blendMode : nr), void 0 !== s) { var c = s.actionByRoot[i]; if (void 0 !== c && c.blendMode === n) return c; l = s.knownActions[0], null === a && (a = l._clip) } if (null === a) return null; var u = new hd(this, a, t, n); return this._bindAction(u, l), this._addInactiveAction(u, o, i), u }, existingAction: function (e, t) { var n = t || this._root, r = n.uuid, i = "string" == typeof e ? zu.findByName(n, e) : e, a = i ? i.uuid : e, o = this._actionsByClip[a]; return void 0 !== o && o.actionByRoot[r] || null }, stopAllAction: function () { for (var e = this._actions, t = this._nActiveActions - 1; t >= 0; --t)e[t].stop(); return this }, update: function (e) { e *= this.timeScale; for (var t = this._actions, n = this._nActiveActions, r = this.time += e, i = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) { t[o]._update(r, e, i, a) } for (var s = this._bindings, l = this._nActiveBindings, c = 0; c !== l; ++c)s[c].apply(a); return this }, setTime: function (e) { this.time = 0; for (var t = 0; t < this._actions.length; t++)this._actions[t].time = 0; return this.update(e) }, getRoot: function () { return this._root }, uncacheClip: function (e) { var t = this._actions, n = e.uuid, r = this._actionsByClip, i = r[n]; if (void 0 !== i) { for (var a = i.knownActions, o = 0, s = a.length; o !== s; ++o) { var l = a[o]; this._deactivateAction(l); var c = l._cacheIndex, u = t[t.length - 1]; l._cacheIndex = null, l._byClipCacheIndex = null, u._cacheIndex = c, t[c] = u, t.pop(), this._removeInactiveBindingsForAction(l) } delete r[n] } }, uncacheRoot: function (e) { var t = e.uuid, n = this._actionsByClip; for (var r in n) { var i = n[r].actionByRoot[t]; void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } var a = this._bindingsByRootAndName[t]; if (void 0 !== a) for (var o in a) { var s = a[o]; s.restoreOriginalState(), this._removeInactiveBinding(s) } }, uncacheAction: function (e, t) { var n = this.existingAction(e, t); null !== n && (this._deactivateAction(n), this._removeInactiveAction(n)) } }); var pd = function () { function e(t) { _classCallCheck(this, e), "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t } return _createClass(e, [{ key: "clone", value: function () { return new e(void 0 === this.value.clone ? this.value : this.value.clone()) } }]), e }(); function fd(e, t, n) { Sl.call(this, e, t), this.meshPerAttribute = n || 1 } function md(e, t, n, r, i) { this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0 } function vd(e, t, n, r) { this.ray = new li(e, t), this.near = n || 0, this.far = r || 1 / 0, this.camera = null, this.layers = new xi, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function () { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) } function gd(e, t) { return e.distance - t.distance } function yd(e, t, n, r) { if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r) for (var i = e.children, a = 0, o = i.length; a < o; a++)yd(i[a], t, n, !0) } fd.prototype = Object.assign(Object.create(Sl.prototype), { constructor: fd, isInstancedInterleavedBuffer: !0, copy: function (e) { return Sl.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this }, clone: function (e) { var t = Sl.prototype.clone.call(this, e); return t.meshPerAttribute = this.meshPerAttribute, t }, toJSON: function (e) { var t = Sl.prototype.toJSON.call(this, e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } }), Object.defineProperty(md.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }), Object.assign(md.prototype, { isGLBufferAttribute: !0, setBuffer: function (e) { return this.buffer = e, this }, setType: function (e, t) { return this.type = e, this.elementSize = t, this }, setItemSize: function (e) { return this.itemSize = e, this }, setCount: function (e) { return this.count = e, this } }), Object.assign(vd.prototype, { set: function (e, t) { this.ray.set(e, t) }, setFromCamera: function (e, t) { t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function (e, t, n) { var r = n || []; return yd(e, this, r, t), r.sort(gd), r }, intersectObjects: function (e, t, n) { var r = n || []; if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r; for (var i = 0, a = e.length; i < a; i++)yd(e[i], this, r, t); return r.sort(gd), r } }); var bd = function () { function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; return _classCallCheck(this, e), this.radius = t, this.phi = n, this.theta = r, this } return _createClass(e, [{ key: "set", value: function (e, t, n) { return this.radius = e, this.phi = t, this.theta = n, this } }, { key: "clone", value: function () { return (new this.constructor).copy(this) } }, { key: "copy", value: function (e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } }, { key: "makeSafe", value: function () { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } }, { key: "setFromVector3", value: function (e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } }, { key: "setFromCartesianCoords", value: function (e, t, n) { return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Tr.clamp(t / this.radius, -1, 1))), this } }]), e }(), xd = new Er, _d = function () { function e(t, n) { _classCallCheck(this, e), Object.defineProperty(this, "isBox2", { value: !0 }), this.min = void 0 !== t ? t : new Er(1 / 0, 1 / 0), this.max = void 0 !== n ? n : new Er(-1 / 0, -1 / 0) } return _createClass(e, [{ key: "set", value: function (e, t) { return this.min.copy(e), this.max.copy(t), this } }, { key: "setFromPoints", value: function (e) { this.makeEmpty(); for (var t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } }, { key: "setFromCenterAndSize", value: function (e, t) { var n = xd.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } }, { key: "clone", value: function () { return (new this.constructor).copy(this) } }, { key: "copy", value: function (e) { return this.min.copy(e.min), this.max.copy(e.max), this } }, { key: "makeEmpty", value: function () { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } }, { key: "isEmpty", value: function () { return this.max.x < this.min.x || this.max.y < this.min.y } }, { key: "getCenter", value: function (e) { return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new Er), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } }, { key: "getSize", value: function (e) { return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new Er), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } }, { key: "expandByPoint", value: function (e) { return this.min.min(e), this.max.max(e), this } }, { key: "expandByVector", value: function (e) { return this.min.sub(e), this.max.add(e), this } }, { key: "expandByScalar", value: function (e) { return this.min.addScalar(-e), this.max.addScalar(e), this } }, { key: "containsPoint", value: function (e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } }, { key: "containsBox", value: function (e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } }, { key: "getParameter", value: function (e, t) { return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new Er), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } }, { key: "intersectsBox", value: function (e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } }, { key: "clampPoint", value: function (e, t) { return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new Er), t.copy(e).clamp(this.min, this.max) } }, { key: "distanceToPoint", value: function (e) { return xd.copy(e).clamp(this.min, this.max).sub(e).length() } }, { key: "intersect", value: function (e) { return this.min.max(e.min), this.max.min(e.max), this } }, { key: "union", value: function (e) { return this.min.min(e.min), this.max.max(e.max), this } }, { key: "translate", value: function (e) { return this.min.add(e), this.max.add(e), this } }, { key: "equals", value: function (e) { return e.min.equals(this.min) && e.max.equals(this.max) } }]), e }(); function wd(e) { Ii.call(this), this.material = e, this.render = function () { }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } wd.prototype = Object.create(Ii.prototype), wd.prototype.constructor = wd, wd.prototype.isImmediateRenderObject = !0; var Md = new Nr, Sd = new ci, Td = new ci, Ed = function (e) { _inherits(n, vc); var t = _createSuper(n); function n(e) { var r; _classCallCheck(this, n); for (var i = function e(t) { var n = []; t && t.isBone && n.push(t); for (var r = 0; r < t.children.length; r++)n.push.apply(n, e(t.children[r])); return n }(e), a = new Ra, o = [], s = [], l = new na(0, 0, 1), c = new na(0, 1, 0), u = 0; u < i.length; u++) { var h = i[u]; h.parent && h.parent.isBone && (o.push(0, 0, 0), o.push(0, 0, 0), s.push(l.r, l.g, l.b), s.push(c.r, c.g, c.b)) } a.setAttribute("position", new ga(o, 3)), a.setAttribute("color", new ga(s, 3)); var d = new sc({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }); return (r = t.call(this, a, d)).type = "SkeletonHelper", r.isSkeletonHelper = !0, r.root = e, r.bones = i, r.matrix = e.matrixWorld, r.matrixAutoUpdate = !1, r } return _createClass(n, [{ key: "updateMatrixWorld", value: function (e) { var t = this.bones, r = this.geometry, i = r.getAttribute("position"); Td.getInverse(this.root.matrixWorld); for (var a = 0, o = 0; a < t.length; a++) { var s = t[a]; s.parent && s.parent.isBone && (Sd.multiplyMatrices(Td, s.matrixWorld), Md.setFromMatrixPosition(Sd), i.setXYZ(o, Md.x, Md.y, Md.z), Sd.multiplyMatrices(Td, s.parent.matrixWorld), Md.setFromMatrixPosition(Sd), i.setXYZ(o + 1, Md.x, Md.y, Md.z), o += 2) } r.getAttribute("position").needsUpdate = !0, _get(_getPrototypeOf(n.prototype), "updateMatrixWorld", this).call(this, e) } }]), n }(); var Ad = 4, Rd = 8, kd = Math.pow(2, Rd), Ld = [.125, .215, .35, .446, .526, .582], Cd = Rd - Ad + 1 + Ld.length, Pd = 20, Od = (_defineProperty(t = {}, ir, 0), _defineProperty(t, ar, 1), _defineProperty(t, sr, 2), _defineProperty(t, cr, 3), _defineProperty(t, ur, 4), _defineProperty(t, hr, 5), _defineProperty(t, or, 6), t), Id = new Rh, Nd = Wd(), Dd = Nd._lodPlanes, Fd = Nd._sizeLods, Ud = Nd._sigmas, zd = null, Bd = (1 + Math.sqrt(5)) / 2, Hd = 1 / Bd, Gd = [new Nr(1, 1, 1), new Nr(-1, 1, 1), new Nr(1, 1, -1), new Nr(-1, 1, -1), new Nr(0, Bd, Hd), new Nr(0, Bd, -Hd), new Nr(Hd, 0, Bd), new Nr(-Hd, 0, Bd), new Nr(Bd, Hd, 0), new Nr(-Bd, Hd, 0)], Vd = function () { function e(t) { var n, r, i; _classCallCheck(this, e), this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = (n = Pd, r = new Float32Array(n), i = new Nr(0, 1, 0), new vu({ name: "SphericalGaussianBlur", defines: { n: n }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: r }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: i }, inputEncoding: { value: Od[ir] }, outputEncoding: { value: Od[ir] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t".concat("\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t", "\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"), blending: Be, depthTest: !1, depthWrite: !1 })), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial) } return _createClass(e, [{ key: "fromScene", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 100; zd = this._renderer.getRenderTarget(); var i = this._allocateTargets(); return this._sceneToCubeUV(e, n, r, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i } }, { key: "fromEquirectangular", value: function (e) { return this._fromTexture(e) } }, { key: "fromCubemap", value: function (e) { return this._fromTexture(e) } }, { key: "compileCubemapShader", value: function () { null === this._cubemapShader && (this._cubemapShader = Jd(), this._compileMaterial(this._cubemapShader)) } }, { key: "compileEquirectangularShader", value: function () { null === this._equirectShader && (this._equirectShader = Yd(), this._compileMaterial(this._equirectShader)) } }, { key: "dispose", value: function () { this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for (var e = 0; e < Dd.length; e++)Dd[e].dispose() } }, { key: "_cleanup", value: function (e) { this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(zd), e.scissorTest = !1, Xd(e, 0, 0, e.width, e.height) } }, { key: "_fromTexture", value: function (e) { zd = this._renderer.getRenderTarget(); var t = this._allocateTargets(e); return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t } }, { key: "_allocateTargets", value: function (e) { var t = { magFilter: It, minFilter: It, generateMipmaps: !1, type: Bt, format: rn, encoding: jd(e) ? e.encoding : sr, depthBuffer: !1 }, n = qd(t); return n.depthBuffer = !e, this._pingPongRenderTarget = qd(t), n } }, { key: "_compileMaterial", value: function (e) { var t = new qa(Dd[0], e); this._renderer.compile(t, Id) } }, { key: "_sceneToCubeUV", value: function (e, t, n, r) { var i = new ro(90, 1, t, n), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], s = this._renderer, l = s.outputEncoding, c = s.toneMapping, u = s.getClearColor(), h = s.getClearAlpha(); s.toneMapping = bt, s.outputEncoding = ir; var d = e.background; if (d && d.isColor) { d.convertSRGBToLinear(); var p = Math.max(d.r, d.g, d.b), f = Math.min(Math.max(Math.ceil(Math.log2(p)), -128), 127); d = d.multiplyScalar(Math.pow(2, -f)); var m = (f + 128) / 255; s.setClearColor(d, m), e.background = null } for (var v = 0; v < 6; v++) { var g = v % 3; 0 == g ? (i.up.set(0, a[v], 0), i.lookAt(o[v], 0, 0)) : 1 == g ? (i.up.set(0, 0, a[v]), i.lookAt(0, o[v], 0)) : (i.up.set(0, a[v], 0), i.lookAt(0, 0, o[v])), Xd(r, g * kd, v > 2 ? kd : 0, kd, kd), s.setRenderTarget(r), s.render(e, i) } s.toneMapping = c, s.outputEncoding = l, s.setClearColor(u, h) } }, { key: "_textureToCubeUV", value: function (e, t) { var n = this._renderer; e.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Jd()) : null == this._equirectShader && (this._equirectShader = Yd()); var r = e.isCubeTexture ? this._cubemapShader : this._equirectShader, i = new qa(Dd[0], r), a = r.uniforms; a.envMap.value = e, e.isCubeTexture || a.texelSize.value.set(1 / e.image.width, 1 / e.image.height), a.inputEncoding.value = Od[e.encoding], a.outputEncoding.value = Od[t.texture.encoding], Xd(t, 0, 0, 3 * kd, 2 * kd), n.setRenderTarget(t), n.render(i, Id) } }, { key: "_applyPMREM", value: function (e) { var t = this._renderer, n = t.autoClear; t.autoClear = !1; for (var r = 1; r < Cd; r++) { var i = Math.sqrt(Ud[r] * Ud[r] - Ud[r - 1] * Ud[r - 1]), a = Gd[(r - 1) % Gd.length]; this._blur(e, r - 1, r, i, a) } t.autoClear = n } }, { key: "_blur", value: function (e, t, n, r, i) { var a = this._pingPongRenderTarget; this._halfBlur(e, a, t, n, r, "latitudinal", i), this._halfBlur(a, e, n, n, r, "longitudinal", i) } }, { key: "_halfBlur", value: function (e, t, n, r, i, a, o) { var s = this._renderer, l = this._blurMaterial; "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!"); var c = new qa(Dd[r], l), u = l.uniforms, h = Fd[n] - 1, d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / (2 * Pd - 1), p = i / d, f = isFinite(i) ? 1 + Math.floor(3 * p) : Pd; f > Pd && console.warn("sigmaRadians, ".concat(i, ", is too large and will clip, as it requested ").concat(f, " samples when the maximum is set to ").concat(Pd)); for (var m = [], v = 0, g = 0; g < Pd; ++g) { var y = g / p, b = Math.exp(-y * y / 2); m.push(b), 0 == g ? v += b : g < f && (v += 2 * b) } for (var x = 0; x < m.length; x++)m[x] = m[x] / v; u.envMap.value = e.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === a, o && (u.poleAxis.value = o), u.dTheta.value = d, u.mipInt.value = Rd - n, u.inputEncoding.value = Od[e.texture.encoding], u.outputEncoding.value = Od[e.texture.encoding]; var _ = Fd[r]; Xd(t, 3 * Math.max(0, kd - 2 * _), (0 === r ? 0 : 2 * kd) + 2 * _ * (r > Rd - Ad ? r - Rd + Ad : 0), 3 * _, 2 * _), s.setRenderTarget(t), s.render(c, Id) } }]), e }(); function jd(e) { return void 0 !== e && e.type === Bt && (e.encoding === ir || e.encoding === ar || e.encoding === or) } function Wd() { for (var e = [], t = [], n = [], r = Rd, i = 0; i < Cd; i++) { var a = Math.pow(2, r); t.push(a); var o = 1 / a; i > Rd - Ad ? o = Ld[i - Rd + Ad - 1] : 0 == i && (o = 0), n.push(o); for (var s = 1 / (a - 1), l = -s / 2, c = 1 + s / 2, u = [l, l, c, l, c, c, l, l, c, c, l, c], h = new Float32Array(108), d = new Float32Array(72), p = new Float32Array(36), f = 0; f < 6; f++) { var m = f % 3 * 2 / 3 - 1, v = f > 2 ? 0 : -1, g = [m, v, 0, m + 2 / 3, v, 0, m + 2 / 3, v + 1, 0, m, v, 0, m + 2 / 3, v + 1, 0, m, v + 1, 0]; h.set(g, 18 * f), d.set(u, 12 * f); var y = [f, f, f, f, f, f]; p.set(y, 6 * f) } var b = new Ra; b.setAttribute("position", new ca(h, 3)), b.setAttribute("uv", new ca(d, 2)), b.setAttribute("faceIndex", new ca(p, 1)), e.push(b), r > Ad && r-- } return { _lodPlanes: e, _sizeLods: t, _sigmas: n } } function qd(e) { var t = new Pr(3 * kd, 3 * kd, e); return t.texture.mapping = kt, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t } function Xd(e, t, n, r, i) { e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i) } function Yd() { return new vu({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: new Er(1, 1) }, inputEncoding: { value: Od[ir] }, outputEncoding: { value: Od[ir] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t".concat("\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t", "\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"), blending: Be, depthTest: !1, depthWrite: !1 }) } function Jd() { return new vu({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: Od[ir] }, outputEncoding: { value: Od[ir] } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t".concat("\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t", "\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t"), blending: Be, depthTest: !1, depthWrite: !1 }) } function Zd(e) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), oh.call(this, e), this.type = "catmullrom" } Qu.create = function (e, t) { return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Qu.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e }, Object.assign(yh.prototype, { createPointsGeometry: function (e) { console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); var t = this.getPoints(e); return this.createGeometry(t) }, createSpacedPointsGeometry: function (e) { console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); var t = this.getSpacedPoints(e); return this.createGeometry(t) }, createGeometry: function (e) { console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); for (var t = new Oc, n = 0, r = e.length; n < r; n++) { var i = e[n]; t.vertices.push(new Nr(i.x, i.y, i.z || 0)) } return t } }), Object.assign(bh.prototype, { fromPoints: function (e) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e) } }), Zd.prototype = Object.create(oh.prototype), Object.assign(Zd.prototype, { initFromArray: function () { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function () { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function () { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), Ed.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(Vu.prototype, { extractUrlBase: function (e) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Dh.extractUrlBase(e) } }), Vu.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, Object.assign(_d.prototype, { center: function (e) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e) }, empty: function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (e) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, size: function (e) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e) } }), Object.assign(Ur.prototype, { center: function (e) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, empty: function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (e) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, isIntersectionSphere: function (e) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, size: function (e) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e) } }), Object.assign(ei.prototype, { empty: function () { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() } }), po.prototype.setFromMatrix = function (e) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e) }, Object.assign(Tr, { random16: function () { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function (e) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Tr.floorPowerOfTwo(e) }, nextPowerOfTwo: function (e) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Tr.ceilPowerOfTwo(e) } }), Object.assign(Ar.prototype, { flattenToArrayOffset: function (e, t) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, multiplyVector3: function (e) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBufferAttribute: function (e) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, applyToVector3Array: function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }), Object.assign(ci.prototype, { extractPosition: function (e) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e) }, flattenToArrayOffset: function (e, t) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, getPosition: function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Nr).setFromMatrixColumn(this, 3) }, setRotationFromQuaternion: function (e) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e) }, multiplyToArray: function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function (e) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, multiplyVector4: function (e) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function (e) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this) }, crossVector: function (e) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, translate: function () { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBufferAttribute: function (e) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, applyToVector3Array: function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function (e, t, n, r, i, a) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, n, i, a) } }), Ui.prototype.isIntersectionLine = function (e) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e) }, Ir.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this) }, Object.assign(li.prototype, { isIntersectionBox: function (e) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, isIntersectionPlane: function (e) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e) }, isIntersectionSphere: function (e) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) } }), Object.assign(Ji.prototype, { area: function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function (e, t) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t) }, midpoint: function (e) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e) }, normal: function (e) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e) }, plane: function (e) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e) } }), Object.assign(Ji, { barycoordFromPoint: function (e, t, n, r, i) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Ji.getBarycoord(e, t, n, r, i) }, normal: function (e, t, n, r) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Ji.getNormal(e, t, n, r) } }), Object.assign(xh.prototype, { extractAllPoints: function (e) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e) }, extrude: function (e) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new uu(this, e) }, makeGeometry: function (e) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new fu(this, e) } }), Object.assign(Er.prototype, { fromAttribute: function (e, t, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, distanceToManhattan: function (e) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, lengthManhattan: function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Nr.prototype, { setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (e) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e) }, getScaleFromMatrix: function (e) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e) }, getColumnFromMatrix: function (e, t) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, applyProjection: function (e) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e) }, fromAttribute: function (e, t, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, distanceToManhattan: function (e) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, lengthManhattan: function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Cr.prototype, { fromAttribute: function (e, t, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, lengthManhattan: function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Oc.prototype, { computeTangents: function () { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function () { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") }, applyMatrix: function (e) { return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) } }), Object.assign(Ii.prototype, { getChildByName: function (e) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e) }, renderDepth: function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function (e, t) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e) }, getWorldRotation: function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, applyMatrix: function (e) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) } }), Object.defineProperties(Ii.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (e) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.assign(qa.prototype, { setDrawMode: function () { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } }), Object.defineProperties(qa.prototype, { drawMode: { get: function () { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function () { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Object.defineProperties(Zl.prototype, { objects: { get: function () { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(ec.prototype, "useVertexTexture", { get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), Kl.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(Qu.prototype, "__arcLengthDivisions", { get: function () { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function (e) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e } }), ro.prototype.setLens = function (e, t) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e) }, Object.defineProperties(_h.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (e) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e } }, shadowCameraLeft: { set: function (e) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e } }, shadowCameraRight: { set: function (e) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e } }, shadowCameraTop: { set: function (e) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e } }, shadowCameraBottom: { set: function (e) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e } }, shadowCameraNear: { set: function (e) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e } }, shadowCameraFar: { set: function (e) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (e) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (e) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e } }, shadowMapHeight: { set: function (e) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e } } }), Object.defineProperties(ca.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048) } } }), Object.assign(ca.prototype, { setDynamic: function (e) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? 35048 : yr), this }, copyIndicesArray: function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, setArray: function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(Ra.prototype, { addIndex: function (e) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e) }, addAttribute: function (e, t) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new ca(arguments[1], arguments[2]))) }, addDrawCall: function (e, t, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t) }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function () { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, removeAttribute: function (e) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e) }, applyMatrix: function (e) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) } }), Object.defineProperties(Ra.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.defineProperties(Fh.prototype, { maxInstancedCount: { get: function () { return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount }, set: function (e) { console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = e } } }), Object.defineProperties(vd.prototype, { linePrecision: { get: function () { return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold }, set: function (e) { console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = e } } }), Object.defineProperties(Sl.prototype, { dynamic: { get: function () { return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), 35048 === this.usage }, set: function (e) { console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(e) } } }), Object.assign(Sl.prototype, { setDynamic: function (e) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? 35048 : yr), this }, setArray: function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(lu.prototype, { getArrays: function () { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.") }, addShapeList: function () { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.") }, addShape: function () { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.") } }), Object.assign(Ml.prototype, { dispose: function () { console.error("THREE.Scene: .dispose() has been removed.") } }), Object.defineProperties(pd.prototype, { dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(aa.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new na } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (e) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e } } }), Object.defineProperties(bu.prototype, { metal: { get: function () { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(yu.prototype, { transparency: { get: function () { return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission }, set: function (e) { console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = e } } }), Object.defineProperties(to.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (e) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e } } }), Object.assign(_l.prototype, { clearTarget: function (e, t, n, r) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, r) }, animate: function (e) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e) }, getCurrentRenderTarget: function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function (e) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e) }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, allocTextureUnit: function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, setTexture: function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, setTexture2D: function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, setTextureCube: function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, getActiveMipMapLevel: function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() } }), Object.defineProperties(_l.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function () { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function (e) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? ar : ir } }, toneMappingWhitePoint: { get: function () { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function () { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(dl.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Pr.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e } } }), Object.defineProperties($h.prototype, { load: { value: function (e) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); var t = this; return (new Yh).load(e, function (e) { t.setBuffer(e) }), this } }, startTime: { set: function () { console.warn("THREE.Audio: .startTime is now .play( delay ).") } } }), oo.prototype.updateCubeMap = function (e, t) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t) }, Rr.crossOrigin = void 0, Rr.loadTexture = function (e, t, n, r) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); var i = new Ku; i.setCrossOrigin(this.crossOrigin); var a = i.load(e, n, void 0, r); return t && (a.mapping = t), a }, Rr.loadTextureCube = function (e, t, n, r) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); var i = new Ju; i.setCrossOrigin(this.crossOrigin); var a = i.load(e, n, void 0, r); return t && (a.mapping = t), a }, Rr.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, Rr.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "121" } })); var Kd = function (e) { Vu.call(this, e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } }; Kd.prototype = Object.assign(Object.create(Vu.prototype), { constructor: Kd, setDecoderPath: function (e) { return this.decoderPath = e, this }, setDecoderConfig: function (e) { return this.decoderConfig = e, this }, setWorkerLimit: function (e) { return this.workerLimit = e, this }, setVerbosity: function () { console.warn("THREE.DRACOLoader: The .setVerbosity() method has been removed.") }, setDrawMode: function () { console.warn("THREE.DRACOLoader: The .setDrawMode() method has been removed.") }, setSkipDequantization: function () { console.warn("THREE.DRACOLoader: The .setSkipDequantization() method has been removed.") }, load: function (e, t, n, r) { var i = this, a = new Wu(this.manager); a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (e) { var n = { attributeIDs: i.defaultAttributeIDs, attributeTypes: i.defaultAttributeTypes, useUniqueIDs: !1 }; i.decodeGeometry(e, n).then(t).catch(r) }, n, r) }, decodeDracoFile: function (e, t, n, r) { var i = { attributeIDs: n || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!n }; this.decodeGeometry(e, i).then(t) }, decodeGeometry: function (e, t) { var n = this; for (var r in t.attributeTypes) { var i = t.attributeTypes[r]; void 0 !== i.BYTES_PER_ELEMENT && (t.attributeTypes[r] = i.name) } var a, o = JSON.stringify(t); if (Kd.taskCache.has(e)) { var s = Kd.taskCache.get(e); if (s.key === o) return s.promise; if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } var l = this.workerNextTaskID++, c = e.byteLength, u = this._getWorker(l, c).then(function (n) { return a = n, new Promise(function (n, r) { a._callbacks[l] = { resolve: n, reject: r }, a.postMessage({ type: "decode", id: l, taskConfig: t, buffer: e }, [e]) }) }).then(function (e) { return n._createGeometry(e.geometry) }); return u.catch(function () { return !0 }).then(function () { a && l && n._releaseTask(a, l) }), Kd.taskCache.set(e, { key: o, promise: u }), u }, _createGeometry: function (e) { var t = new Ra; e.index && t.setIndex(new ca(e.index.array, 1)); for (var n = 0; n < e.attributes.length; n++) { var r = e.attributes[n], i = r.name, a = r.array, o = r.itemSize; t.setAttribute(i, new ca(a, o)) } return t }, _loadLibrary: function (e, t) { var n = new Wu(this.manager); return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(function (t, r) { n.load(e, t, void 0, r) }) }, preload: function () { return this._initDecoder(), this }, _initDecoder: function () { var e = this; if (this.decoderPending) return this.decoderPending; var t = "object" !== ("undefined" == typeof WebAssembly ? "undefined" : _typeof(WebAssembly)) || "js" === this.decoderConfig.type, n = []; return t ? n.push(this._loadLibrary("draco_decoder.js", "text")) : (n.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), n.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(n).then(function (n) { var r = n[0]; t || (e.decoderConfig.wasmBinary = n[1]); var i = Kd.DRACOWorker.toString(), a = ["/* draco decoder */", r, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n"); e.workerSourceURL = URL.createObjectURL(new Blob([a])) }), this.decoderPending }, _getWorker: function (e, t) { var n = this; return this._initDecoder().then(function () { var r; n.workerPool.length < n.workerLimit ? ((r = new Worker(n.workerSourceURL))._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({ type: "init", decoderConfig: n.decoderConfig }), r.onmessage = function (e) { var t = e.data; switch (t.type) { case "decode": r._callbacks[t.id].resolve(t); break; case "error": r._callbacks[t.id].reject(t); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + t.type + '"') } }, n.workerPool.push(r)) : n.workerPool.sort(function (e, t) { return e._taskLoad > t._taskLoad ? -1 : 1 }); return (r = n.workerPool[n.workerPool.length - 1])._taskCosts[e] = t, r._taskLoad += t, r }) }, _releaseTask: function (e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] }, debug: function () { console.log("Task load: ", this.workerPool.map(function (e) { return e._taskLoad })) }, dispose: function () { for (var e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this } }), Kd.DRACOWorker = function () { var e, t; function n(e, t, n, r, i, a) { var o = a.num_components(), s = n.num_points() * o, l = s * i.BYTES_PER_ELEMENT, c = function (e, t) { switch (t) { case Float32Array: return e.DT_FLOAT32; case Int8Array: return e.DT_INT8; case Int16Array: return e.DT_INT16; case Int32Array: return e.DT_INT32; case Uint8Array: return e.DT_UINT8; case Uint16Array: return e.DT_UINT16; case Uint32Array: return e.DT_UINT32 } }(e, i), u = e._malloc(l); t.GetAttributeDataArrayForAllPoints(n, a, c, l, u); var h = new i(e.HEAPF32.buffer, u, s).slice(); return e._free(u), { name: r, array: h, itemSize: o } } onmessage = function (r) { var i = r.data; switch (i.type) { case "init": e = i.decoderConfig, t = new Promise(function (t) { e.onModuleLoaded = function (e) { t({ draco: e }) }, DracoDecoderModule(e) }); break; case "decode": var a = i.buffer, o = i.taskConfig; t.then(function (e) { var t = e.draco, r = new t.Decoder, s = new t.DecoderBuffer; s.Init(new Int8Array(a), a.byteLength); try { var l = function (e, t, r, i) { var a, o, s = i.attributeIDs, l = i.attributeTypes, c = t.GetEncodedGeometryType(r); if (c === e.TRIANGULAR_MESH) a = new e.Mesh, o = t.DecodeBufferToMesh(r, a); else { if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type."); a = new e.PointCloud, o = t.DecodeBufferToPointCloud(r, a) } if (!o.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + o.error_msg()); var u = { index: null, attributes: [] }; for (var h in s) { var d, p, f = self[l[h]]; if (i.useUniqueIDs) p = s[h], d = t.GetAttributeByUniqueId(a, p); else { if (-1 === (p = t.GetAttributeId(a, e[s[h]]))) continue; d = t.GetAttribute(a, p) } u.attributes.push(n(e, t, a, h, f, d)) } c === e.TRIANGULAR_MESH && (u.index = function (e, t, n) { var r = 3 * n.num_faces(), i = 4 * r, a = e._malloc(i); t.GetTrianglesUInt32Array(n, i, a); var o = new Uint32Array(e.HEAPF32.buffer, a, r).slice(); return e._free(a), { array: o, itemSize: 1 } }(e, t, a)); return e.destroy(a), u }(t, r, s, o), c = l.attributes.map(function (e) { return e.array.buffer }); l.index && c.push(l.index.array.buffer), self.postMessage({ type: "decode", id: i.id, geometry: l }, c) } catch (e) { console.error(e), self.postMessage({ type: "error", id: i.id, error: e.message }) } finally { t.destroy(s), t.destroy(r) } }) } } }, Kd.taskCache = new WeakMap, Kd.setDecoderPath = function () { console.warn("THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.") }, Kd.setDecoderConfig = function () { console.warn("THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.") }, Kd.releaseDecoderModule = function () { console.warn("THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.") }, Kd.getDecoderModule = function () { console.warn("THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.") }; var Qd, $d, ep, tp, np, rp, ip = function () { function e(e) { Vu.call(this, e), this.dracoLoader = null, this.ddsLoader = null, this.ktx2Loader = null, this.pluginCallbacks = [], this.register(function (e) { return new o(e) }), this.register(function (e) { return new l(e) }), this.register(function (e) { return new s(e) }), this.register(function (e) { return new i(e) }) } function t() { var e = {}; return { get: function (t) { return e[t] }, add: function (t, n) { e[t] = n }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } e.prototype = Object.assign(Object.create(Vu.prototype), { constructor: e, load: function (e, t, n, r) { var i, a = this; i = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Dh.extractUrlBase(e), this.manager.itemStart(e); var o = function (t) { r ? r(t) : console.error(t), a.manager.itemError(e), a.manager.itemEnd(e) }, s = new Wu(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, function (n) { try { a.parse(n, i, function (n) { t(n), a.manager.itemEnd(e) }, o) } catch (e) { o(e) } }, n, o) }, setDRACOLoader: function (e) { return this.dracoLoader = e, this }, setDDSLoader: function (e) { return this.ddsLoader = e, this }, setKTX2Loader: function (e) { return this.ktx2Loader = e, this }, register: function (e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this }, unregister: function (e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this }, parse: function (e, t, i, o) { var s, l = {}, u = {}; if ("string" == typeof e) s = e; else if (Dh.decodeText(new Uint8Array(e, 0, 4)) === c) { try { l[n.KHR_BINARY_GLTF] = new d(e) } catch (e) { return void (o && o(e)) } s = l[n.KHR_BINARY_GLTF].content } else s = Dh.decodeText(new Uint8Array(e)); var h = JSON.parse(s); if (void 0 === h.asset || h.asset.version[0] < 2) o && o(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); else { var m = new H(h, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, manager: this.manager, ktx2Loader: this.ktx2Loader }); m.fileLoader.setRequestHeader(this.requestHeader); for (var y = 0; y < this.pluginCallbacks.length; y++) { var b = this.pluginCallbacks[y](m); u[b.name] = b, l[b.name] = !0 } if (h.extensionsUsed) for (y = 0; y < h.extensionsUsed.length; ++y) { var x = h.extensionsUsed[y], _ = h.extensionsRequired || []; switch (x) { case n.KHR_MATERIALS_UNLIT: l[x] = new a; break; case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: l[x] = new v; break; case n.KHR_DRACO_MESH_COMPRESSION: l[x] = new p(h, this.dracoLoader); break; case n.MSFT_TEXTURE_DDS: l[x] = new r(this.ddsLoader); break; case n.KHR_TEXTURE_TRANSFORM: l[x] = new f; break; case n.KHR_MESH_QUANTIZATION: l[x] = new g; break; default: _.indexOf(x) >= 0 && void 0 === u[x] && console.warn('THREE.GLTFLoader: Unknown extension "' + x + '".') } } m.setExtensions(l), m.setPlugins(u), m.parse(i, o) } } }); var n = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", MSFT_TEXTURE_DDS: "MSFT_texture_dds" }; function r(e) { if (!e) throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader"); this.name = n.MSFT_TEXTURE_DDS, this.ddsLoader = e } function i(e) { this.parser = e, this.name = n.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } function a() { this.name = n.KHR_MATERIALS_UNLIT } function o(e) { this.parser = e, this.name = n.KHR_MATERIALS_CLEARCOAT } function s(e) { this.parser = e, this.name = n.KHR_MATERIALS_TRANSMISSION } function l(e) { this.parser = e, this.name = n.KHR_TEXTURE_BASISU } i.prototype._markDefs = function () { for (var e = this.parser, t = this.parser.json.nodes || [], n = 0, r = t.length; n < r; n++) { var i = t[n]; i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light) } }, i.prototype._loadLight = function (e) { var t = this.parser, n = "light:" + e, r = t.cache.get(n); if (r) return r; var i, a = t.json, o = ((a.extensions && a.extensions[this.name] || {}).lights || [])[e], s = new na(16777215); void 0 !== o.color && s.fromArray(o.color); var l = void 0 !== o.range ? o.range : 0; switch (o.type) { case "directional": (i = new Lh(s)).target.position.set(0, 0, -1), i.add(i.target); break; case "point": (i = new Ah(s)).distance = l; break; case "spot": (i = new Th(s)).distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, i.angle = o.spot.outerConeAngle, i.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, i.target.position.set(0, 0, -1), i.add(i.target); break; default: throw new Error('THREE.GLTFLoader: Unexpected light type, "' + o.type + '".') }return i.position.set(0, 0, 0), i.decay = 2, void 0 !== o.intensity && (i.intensity = o.intensity), i.name = t.createUniqueName(o.name || "light_" + e), r = Promise.resolve(i), t.cache.add(n, r), r }, i.prototype.createNodeAttachment = function (e) { var t = this, n = this.parser, r = n.json.nodes[e], i = (r.extensions && r.extensions[this.name] || {}).light; return void 0 === i ? null : this._loadLight(i).then(function (e) { return n._getNodeRef(t.cache, i, e) }) }, a.prototype.getMaterialType = function () { return oa }, a.prototype.extendParams = function (e, t, n) { var r = []; e.color = new na(1, 1, 1), e.opacity = 1; var i = t.pbrMetallicRoughness; if (i) { if (Array.isArray(i.baseColorFactor)) { var a = i.baseColorFactor; e.color.fromArray(a), e.opacity = a[3] } void 0 !== i.baseColorTexture && r.push(n.assignTexture(e, "map", i.baseColorTexture)) } return Promise.all(r) }, o.prototype.getMaterialType = function (e) { var t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? yu : null }, o.prototype.extendMaterialParams = function (e, t) { var n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); var i = [], a = r.extensions[this.name]; if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && i.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && i.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (i.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) { var o = a.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new Er(o, o) } return Promise.all(i) }, s.prototype.getMaterialType = function (e) { var t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? yu : null }, s.prototype.extendMaterialParams = function (e, t) { var n = this.parser, r = n.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); var i = [], a = r.extensions[this.name]; return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(i) }, l.prototype.loadTexture = function (e) { var t = this.parser, n = t.json, r = n.textures[e]; if (!r.extensions || !r.extensions[this.name]) return null; var i = r.extensions[this.name], a = n.images[i.source], o = t.options.ktx2Loader; if (!o) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return t.loadTextureImage(e, a, o) }; var c = "glTF", u = 12, h = { JSON: 1313821514, BIN: 5130562 }; function d(e) { this.name = n.KHR_BINARY_GLTF, this.content = null, this.body = null; var t = new DataView(e, 0, u); if (this.header = { magic: Dh.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== c) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); for (var r = new DataView(e, u), i = 0; i < r.byteLength;) { var a = r.getUint32(i, !0); i += 4; var o = r.getUint32(i, !0); if (i += 4, o === h.JSON) { var s = new Uint8Array(e, u + i, a); this.content = Dh.decodeText(s) } else if (o === h.BIN) { var l = u + i; this.body = e.slice(l, l + a) } i += a } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } function p(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = n.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } function f() { this.name = n.KHR_TEXTURE_TRANSFORM } function m(e) { gu.call(this), this.isGLTFSpecularGlossinessMaterial = !0; var t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), i = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), o = { specular: { value: (new na).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = o, this.onBeforeCompile = function (e) { for (var s in o) e.uniforms[s] = o[s]; e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", i).replace("#include <lights_physical_fragment>", a) }, Object.defineProperties(this, { specular: { get: function () { return o.specular.value }, set: function (e) { o.specular.value = e } }, specularMap: { get: function () { return o.specularMap.value }, set: function (e) { o.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return o.glossiness.value }, set: function (e) { o.glossiness.value = e } }, glossinessMap: { get: function () { return o.glossinessMap.value }, set: function (e) { o.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e) } function v() { return { name: n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"], getMaterialType: function () { return m }, extendParams: function (e, t, n) { var r = t.extensions[this.name]; e.color = new na(1, 1, 1), e.opacity = 1; var i = []; if (Array.isArray(r.diffuseFactor)) { var a = r.diffuseFactor; e.color.fromArray(a), e.opacity = a[3] } if (void 0 !== r.diffuseTexture && i.push(n.assignTexture(e, "map", r.diffuseTexture)), e.emissive = new na(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new na(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) { var o = r.specularGlossinessTexture; i.push(n.assignTexture(e, "glossinessMap", o)), i.push(n.assignTexture(e, "specularMap", o)) } return Promise.all(i) }, createMaterial: function (e) { var t = new m(e); return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = fr, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } } function g() { this.name = n.KHR_MESH_QUANTIZATION } function y(e, t, n, r) { Au.call(this, e, t, n, r) } p.prototype.decodePrimitive = function (e, t) { var n = this.json, r = this.dracoLoader, i = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, s = {}, l = {}; for (var c in a) { var u = L[c] || c.toLowerCase(); o[u] = a[c] } for (c in e.attributes) { u = L[c] || c.toLowerCase(); if (void 0 !== a[c]) { var h = n.accessors[e.attributes[c]], d = E[h.componentType]; l[u] = d, s[u] = !0 === h.normalized } } return t.getDependency("bufferView", i).then(function (e) { return new Promise(function (t) { r.decodeDracoFile(e, function (e) { for (var n in e.attributes) { var r = e.attributes[n], i = s[n]; void 0 !== i && (r.normalized = i) } t(e) }, o, l) }) }) }, f.prototype.extendTexture = function (e, t) { return e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), e.needsUpdate = !0, e }, m.prototype = Object.create(gu.prototype), m.prototype.constructor = m, m.prototype.copy = function (e) { return gu.prototype.copy.call(this, e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }, y.prototype = Object.create(Au.prototype), y.prototype.constructor = y, y.prototype.copySampleValue_ = function (e) { for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r * 3 + r, a = 0; a !== r; a++)t[a] = n[i + a]; return t }, y.prototype.beforeStart_ = y.prototype.copySampleValue_, y.prototype.afterEnd_ = y.prototype.copySampleValue_, y.prototype.interpolate_ = function (e, t, n, r) { for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = 2 * o, l = 3 * o, c = r - t, u = (n - t) / c, h = u * u, d = h * u, p = e * l, f = p - l, m = -2 * d + 3 * h, v = d - h, g = 1 - m, y = v - h + u, b = 0; b !== o; b++) { var x = a[f + b + o], _ = a[f + b + s] * c, w = a[p + b + o], M = a[p + b] * c; i[b] = g * x + y * _ + m * w + v * M } return i }; var b = 0, x = 1, _ = 2, w = 3, M = 4, S = 5, T = 6, E = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, A = { 9728: It, 9729: Ft, 9984: Nt, 9985: Ut, 9986: Dt, 9987: zt }, R = { 33071: Pt, 33648: Ot, 10497: Ct }, k = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, L = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, C = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, P = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: er }, O = "OPAQUE", I = "MASK", N = "BLEND"; function D(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) ? e : /^data:.*,.*$/i.test(e) ? e : /^blob:.*$/i.test(e) ? e : t + e) } function F(e, t, n) { for (var r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r]) } function U(e, t) { void 0 !== t.extras && ("object" === _typeof(t.extras) ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function z(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (var n = 0, r = t.weights.length; n < r; n++)e.morphTargetInfluences[n] = t.weights[n]; if (t.extras && Array.isArray(t.extras.targetNames)) { var i = t.extras.targetNames; if (e.morphTargetInfluences.length === i.length) { e.morphTargetDictionary = {}; for (n = 0, r = i.length; n < r; n++)e.morphTargetDictionary[i[n]] = n } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function B(e) { for (var t = "", n = Object.keys(e).sort(), r = 0, i = n.length; r < i; r++)t += n[r] + ":" + e[n[r]] + ";"; return t } function H(e, n) { this.json = e || {}, this.extensions = {}, this.plugins = {}, this.options = n || {}, this.cache = new t, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new Gh(this.options.manager) : this.textureLoader = new Ku(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new Wu(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } function G(e, t, n) { var r = t.attributes, i = []; function a(t, r) { return n.getDependency("accessor", t).then(function (t) { e.setAttribute(r, t) }) } for (var o in r) { var s = L[o] || o.toLowerCase(); s in e.attributes || i.push(a(r[o], s)) } if (void 0 !== t.indices && !e.index) { var l = n.getDependency("accessor", t.indices).then(function (t) { e.setIndex(t) }); i.push(l) } return U(e, t), function (e, t, n) { var r = t.attributes, i = new Ur; if (void 0 !== r.POSITION) { var a = (d = n.json.accessors[r.POSITION]).min, o = d.max; if (void 0 !== a && void 0 !== o) { i.set(new Nr(a[0], a[1], a[2]), new Nr(o[0], o[1], o[2])); var s = t.targets; if (void 0 !== s) { for (var l = new Nr, c = new Nr, u = 0, h = s.length; u < h; u++) { var d, p = s[u]; if (void 0 !== p.POSITION) a = (d = n.json.accessors[p.POSITION]).min, o = d.max, void 0 !== a && void 0 !== o ? (c.setX(Math.max(Math.abs(a[0]), Math.abs(o[0]))), c.setY(Math.max(Math.abs(a[1]), Math.abs(o[1]))), c.setZ(Math.max(Math.abs(a[2]), Math.abs(o[2]))), l.max(c)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } i.expandByVector(l) } e.boundingBox = i; var f = new ei; i.getCenter(f.center), f.radius = i.min.distanceTo(i.max) / 2, e.boundingSphere = f } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } }(e, t, n), Promise.all(i).then(function () { return void 0 !== t.targets ? function (e, t, n) { for (var r = !1, i = !1, a = 0, o = t.length; a < o && (void 0 !== (c = t[a]).POSITION && (r = !0), void 0 !== c.NORMAL && (i = !0), !r || !i); a++); if (!r && !i) return Promise.resolve(e); var s = [], l = []; for (a = 0, o = t.length; a < o; a++) { var c = t[a]; if (r) { var u = void 0 !== c.POSITION ? n.getDependency("accessor", c.POSITION) : e.attributes.position; s.push(u) } i && (u = void 0 !== c.NORMAL ? n.getDependency("accessor", c.NORMAL) : e.attributes.normal, l.push(u)) } return Promise.all([Promise.all(s), Promise.all(l)]).then(function (t) { var n = t[0], a = t[1]; return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = a), e.morphTargetsRelative = !0, e }) }(e, t.targets, n) : e }) } function V(e, t) { var n = e.getIndex(); if (null === n) { var r = [], i = e.getAttribute("position"); if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (var a = 0; a < i.count; a++)r.push(a); e.setIndex(r), n = e.getIndex() } var o = n.count - 2, s = []; if (t === rr) for (a = 1; a <= o; a++)s.push(n.getX(0)), s.push(n.getX(a)), s.push(n.getX(a + 1)); else for (a = 0; a < o; a++)a % 2 == 0 ? (s.push(n.getX(a)), s.push(n.getX(a + 1)), s.push(n.getX(a + 2))) : (s.push(n.getX(a + 2)), s.push(n.getX(a + 1)), s.push(n.getX(a))); s.length / 3 !== o && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); var l = e.clone(); return l.setIndex(s), l } return H.prototype.setExtensions = function (e) { this.extensions = e }, H.prototype.setPlugins = function (e) { this.plugins = e }, H.prototype.parse = function (e, t) { var n = this, r = this.json, i = this.extensions; this.cache.removeAll(), this._invokeAll(function (e) { return e._markDefs && e._markDefs() }), Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then(function (t) { var a = { scene: t[0][r.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: r.asset, parser: n, userData: {} }; F(i, a, r), U(a, r), e(a) }).catch(t) }, H.prototype._markDefs = function () { for (var e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [], r = 0, i = t.length; r < i; r++)for (var a = t[r].joints, o = 0, s = a.length; o < s; o++)e[a[o]].isBone = !0; for (var l = 0, c = e.length; l < c; l++) { var u = e[l]; void 0 !== u.mesh && (this._addNodeRef(this.meshCache, u.mesh), void 0 !== u.skin && (n[u.mesh].isSkinnedMesh = !0)), void 0 !== u.camera && this._addNodeRef(this.cameraCache, u.camera) } }, H.prototype._addNodeRef = function (e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) }, H.prototype._getNodeRef = function (e, t, n) { if (e.refs[t] <= 1) return n; var r = n.clone(); return r.name += "_instance_" + e.uses[t]++, r }, H.prototype._invokeOne = function (e) { var t = Object.values(this.plugins); t.push(this); for (var n = 0; n < t.length; n++) { var r = e(t[n]); if (r) return r } }, H.prototype._invokeAll = function (e) { var t = Object.values(this.plugins); t.unshift(this); for (var n = [], r = 0; r < t.length; r++) { var i = e(t[r]); i && n.push(i) } return n }, H.prototype.getDependency = function (e, t) { var n = e + ":" + t, r = this.cache.get(n); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this.loadNode(t); break; case "mesh": r = this._invokeOne(function (e) { return e.loadMesh && e.loadMesh(t) }); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne(function (e) { return e.loadBufferView && e.loadBufferView(t) }); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne(function (e) { return e.loadMaterial && e.loadMaterial(t) }); break; case "texture": r = this._invokeOne(function (e) { return e.loadTexture && e.loadTexture(t) }); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this.loadAnimation(t); break; case "camera": r = this.loadCamera(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(n, r) } return r }, H.prototype.getDependencies = function (e) { var t = this.cache.get(e); if (!t) { var n = this, r = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(r.map(function (t, r) { return n.getDependency(e, r) })), this.cache.add(e, t) } return t }, H.prototype.loadBuffer = function (e) { var t = this.json.buffers[e], r = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body); var i = this.options; return new Promise(function (e, n) { r.load(D(t.uri, i.path), e, void 0, function () { n(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) }) }) }, H.prototype.loadBufferView = function (e) { var t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then(function (e) { var n = t.byteLength || 0, r = t.byteOffset || 0; return e.slice(r, r + n) }) }, H.prototype.loadAccessor = function (e) { var t = this, n = this.json, r = this.json.accessors[e]; if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null); var i = []; return void 0 !== r.bufferView ? i.push(this.getDependency("bufferView", r.bufferView)) : i.push(null), void 0 !== r.sparse && (i.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(i).then(function (e) { var i, a = e[0], o = k[r.type], s = E[r.componentType], l = s.BYTES_PER_ELEMENT, c = l * o, u = r.byteOffset || 0, h = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0, d = !0 === r.normalized; if (h && h !== c) { var p = Math.floor(u / h), f = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + p + ":" + r.count, m = t.cache.get(f); m || (m = new Sl(new s(a, p * h, r.count * h / l), h / l), t.cache.add(f, m)), i = new Al(m, o, u % h / l, d) } else i = new ca(null === a ? new s(r.count * o) : new s(a, u, r.count * o), o, d); if (void 0 !== r.sparse) { var v = k.SCALAR, g = E[r.sparse.indices.componentType], y = r.sparse.indices.byteOffset || 0, b = r.sparse.values.byteOffset || 0, x = new g(e[1], y, r.sparse.count * v), _ = new s(e[2], b, r.sparse.count * o); null !== a && (i = new ca(i.array.slice(), i.itemSize, i.normalized)); for (var w = 0, M = x.length; w < M; w++) { var S = x[w]; if (i.setX(S, _[w * o]), o >= 2 && i.setY(S, _[w * o + 1]), o >= 3 && i.setZ(S, _[w * o + 2]), o >= 4 && i.setW(S, _[w * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return i }) }, H.prototype.loadTexture = function (e) { var t, r, i = this.json, a = this.options, o = i.textures[e], s = o.extensions || {}; return (t = s[n.MSFT_TEXTURE_DDS] ? i.images[s[n.MSFT_TEXTURE_DDS].source] : i.images[o.source]).uri && (r = a.manager.getHandler(t.uri)), r || (r = s[n.MSFT_TEXTURE_DDS] ? this.extensions[n.MSFT_TEXTURE_DDS].ddsLoader : this.textureLoader), this.loadTextureImage(e, t, r) }, H.prototype.loadTextureImage = function (e, t, n) { var r = this, i = this.json, a = this.options, o = i.textures[e], s = self.URL || self.webkitURL, l = t.uri, c = !1, u = !0; return "image/jpeg" === t.mimeType && (u = !1), void 0 !== t.bufferView && (l = r.getDependency("bufferView", t.bufferView).then(function (e) { if ("image/png" === t.mimeType) { var n = new DataView(e, 25, 1).getUint8(0, !1); u = 6 === n || 4 === n || 3 === n } c = !0; var r = new Blob([e], { type: t.mimeType }); return l = s.createObjectURL(r) })), Promise.resolve(l).then(function (e) { return new Promise(function (t, r) { var i = t; !0 === n.isImageBitmapLoader && (i = function (e) { t(new Ac(e)) }), n.load(D(e, a.path), i, void 0, r) }) }).then(function (t) { !0 === c && s.revokeObjectURL(l), t.flipY = !1, o.name && (t.name = o.name), u || (t.format = $t); var n = (i.samplers || {})[o.sampler] || {}; return t.magFilter = A[n.magFilter] || Ft, t.minFilter = A[n.minFilter] || zt, t.wrapS = R[n.wrapS] || Ct, t.wrapT = R[n.wrapT] || Ct, r.associations.set(t, { type: "textures", index: e }), t }) }, H.prototype.assignTexture = function (e, t, r) { var i = this; return this.getDependency("texture", r.index).then(function (a) { if (void 0 === r.texCoord || 0 == r.texCoord || "aoMap" === t && 1 == r.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + r.texCoord + " for texture " + t + " not yet supported."), i.extensions[n.KHR_TEXTURE_TRANSFORM]) { var o = void 0 !== r.extensions ? r.extensions[n.KHR_TEXTURE_TRANSFORM] : void 0; if (o) { var s = i.associations.get(a); a = i.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), i.associations.set(a, s) } } e[t] = a }) }, H.prototype.assignFinalMaterial = function (e) { var t = e.geometry, n = e.material, r = void 0 !== t.attributes.tangent, i = void 0 !== t.attributes.color, a = void 0 === t.attributes.normal, o = !0 === e.isSkinnedMesh, s = Object.keys(t.morphAttributes).length > 0, l = s && void 0 !== t.morphAttributes.normal; if (e.isPoints) { var c = "PointsMaterial:" + n.uuid, u = this.cache.get(c); u || (u = new yc, aa.prototype.copy.call(u, n), u.color.copy(n.color), u.map = n.map, u.sizeAttenuation = !1, this.cache.add(c, u)), n = u } else if (e.isLine) { c = "LineBasicMaterial:" + n.uuid; var h = this.cache.get(c); h || (h = new sc, aa.prototype.copy.call(h, n), h.color.copy(n.color), this.cache.add(c, h)), n = h } if (r || i || a || o || s) { c = "ClonedMaterial:" + n.uuid + ":"; n.isGLTFSpecularGlossinessMaterial && (c += "specular-glossiness:"), o && (c += "skinning:"), r && (c += "vertex-tangents:"), i && (c += "vertex-colors:"), a && (c += "flat-shading:"), s && (c += "morph-targets:"), l && (c += "morph-normals:"); var d = this.cache.get(c); d || (d = n.clone(), o && (d.skinning = !0), r && (d.vertexTangents = !0), i && (d.vertexColors = !0), a && (d.flatShading = !0), s && (d.morphTargets = !0), l && (d.morphNormals = !0), this.cache.add(c, d), this.associations.set(d, this.associations.get(n))), n = d } n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), n.normalScale && !r && (n.normalScale.y = -n.normalScale.y), n.clearcoatNormalScale && !r && (n.clearcoatNormalScale.y = -n.clearcoatNormalScale.y), e.material = n }, H.prototype.getMaterialType = function () { return gu }, H.prototype.loadMaterial = function (e) { var t, r = this, i = this.json, a = this.extensions, o = i.materials[e], s = {}, l = o.extensions || {}, c = []; if (l[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { var u = a[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; t = u.getMaterialType(), c.push(u.extendParams(s, o, r)) } else if (l[n.KHR_MATERIALS_UNLIT]) { var h = a[n.KHR_MATERIALS_UNLIT]; t = h.getMaterialType(), c.push(h.extendParams(s, o, r)) } else { var d = o.pbrMetallicRoughness || {}; if (s.color = new na(1, 1, 1), s.opacity = 1, Array.isArray(d.baseColorFactor)) { var p = d.baseColorFactor; s.color.fromArray(p), s.opacity = p[3] } void 0 !== d.baseColorTexture && c.push(r.assignTexture(s, "map", d.baseColorTexture)), s.metalness = void 0 !== d.metallicFactor ? d.metallicFactor : 1, s.roughness = void 0 !== d.roughnessFactor ? d.roughnessFactor : 1, void 0 !== d.metallicRoughnessTexture && (c.push(r.assignTexture(s, "metalnessMap", d.metallicRoughnessTexture)), c.push(r.assignTexture(s, "roughnessMap", d.metallicRoughnessTexture))), t = this._invokeOne(function (t) { return t.getMaterialType && t.getMaterialType(e) }), c.push(Promise.all(this._invokeAll(function (t) { return t.extendMaterialParams && t.extendMaterialParams(e, s) }))) } !0 === o.doubleSided && (s.side = ze); var f = o.alphaMode || O; return f === N ? (s.transparent = !0, s.depthWrite = !1) : (s.transparent = !1, f === I && (s.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : .5)), void 0 !== o.normalTexture && t !== oa && (c.push(r.assignTexture(s, "normalMap", o.normalTexture)), s.normalScale = new Er(1, 1), void 0 !== o.normalTexture.scale && s.normalScale.set(o.normalTexture.scale, o.normalTexture.scale)), void 0 !== o.occlusionTexture && t !== oa && (c.push(r.assignTexture(s, "aoMap", o.occlusionTexture)), void 0 !== o.occlusionTexture.strength && (s.aoMapIntensity = o.occlusionTexture.strength)), void 0 !== o.emissiveFactor && t !== oa && (s.emissive = (new na).fromArray(o.emissiveFactor)), void 0 !== o.emissiveTexture && t !== oa && c.push(r.assignTexture(s, "emissiveMap", o.emissiveTexture)), Promise.all(c).then(function () { var i; return i = t === m ? a[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s) : new t(s), o.name && (i.name = o.name), i.map && (i.map.encoding = ar), i.emissiveMap && (i.emissiveMap.encoding = ar), U(i, o), r.associations.set(i, { type: "materials", index: e }), o.extensions && F(a, i, o), i }) }, H.prototype.createUniqueName = function (e) { for (var t = ud.sanitizeNodeName(e || ""), n = 1; this.nodeNamesUsed[t]; ++n)t = e + "_" + n; return this.nodeNamesUsed[t] = !0, t }, H.prototype.loadGeometries = function (e) { var t = this, r = this.extensions, i = this.primitiveCache; function a(e) { return r[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function (n) { return G(n, e, t) }) } for (var o, s, l = [], c = 0, u = e.length; c < u; c++) { var h, d = e[c], p = (s = void 0, (s = (o = d).extensions && o.extensions[n.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + s.bufferView + ":" + s.indices + ":" + B(s.attributes) : o.indices + ":" + B(o.attributes) + ":" + o.mode), f = i[p]; if (f) l.push(f.promise); else h = d.extensions && d.extensions[n.KHR_DRACO_MESH_COMPRESSION] ? a(d) : G(new Ra, d, t), i[p] = { primitive: d, promise: h }, l.push(h) } return Promise.all(l) }, H.prototype.loadMesh = function (e) { for (var t, n = this, r = this.json.meshes[e], i = r.primitives, a = [], o = 0, s = i.length; o < s; o++) { var l = void 0 === i[o].material ? (void 0 === (t = this.cache).DefaultMaterial && (t.DefaultMaterial = new gu({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: Fe })), t.DefaultMaterial) : this.getDependency("material", i[o].material); a.push(l) } return a.push(n.loadGeometries(i)), Promise.all(a).then(function (t) { for (var a = t.slice(0, t.length - 1), o = t[t.length - 1], s = [], l = 0, c = o.length; l < c; l++) { var u, h = o[l], d = i[l], p = a[l]; if (d.mode === M || d.mode === S || d.mode === T || void 0 === d.mode) !0 !== (u = !0 === r.isSkinnedMesh ? new Kl(h, p) : new qa(h, p)).isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), d.mode === S ? u.geometry = V(u.geometry, 1) : d.mode === T && (u.geometry = V(u.geometry, rr)); else if (d.mode === x) u = new vc(h, p); else if (d.mode === w) u = new pc(h, p); else if (d.mode === _) u = new gc(h, p); else { if (d.mode !== b) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + d.mode); u = new Mc(h, p) } Object.keys(u.geometry.morphAttributes).length > 0 && z(u, r), u.name = n.createUniqueName(r.name || "mesh_" + e), o.length > 1 && (u.name += "_" + l), U(u, r), n.assignFinalMaterial(u), s.push(u) } if (1 === s.length) return s[0]; var f = new gl; for (l = 0, c = s.length; l < c; l++)f.add(s[l]); return f }) }, H.prototype.loadCamera = function (e) { var t, n = this.json.cameras[e], r = n[n.type]; if (r) return "perspective" === n.type ? t = new ro(Tr.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new Rh(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), U(t, n), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") }, H.prototype.loadSkin = function (e) { var t = this.json.skins[e], n = { joints: t.joints }; return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then(function (e) { return n.inverseBindMatrices = e, n }) }, H.prototype.loadAnimation = function (e) { for (var t = this.json.animations[e], n = [], r = [], i = [], a = [], o = [], s = 0, l = t.channels.length; s < l; s++) { var c = t.channels[s], u = t.samplers[c.sampler], h = c.target, d = void 0 !== h.node ? h.node : h.id, p = void 0 !== t.parameters ? t.parameters[u.input] : u.input, f = void 0 !== t.parameters ? t.parameters[u.output] : u.output; n.push(this.getDependency("node", d)), r.push(this.getDependency("accessor", p)), i.push(this.getDependency("accessor", f)), a.push(u), o.push(h) } return Promise.all([Promise.all(n), Promise.all(r), Promise.all(i), Promise.all(a), Promise.all(o)]).then(function (n) { for (var r = n[0], i = n[1], a = n[2], o = n[3], s = n[4], l = [], c = 0, u = r.length; c < u; c++) { var h = r[c], d = i[c], p = a[c], f = o[c], m = s[c]; if (void 0 !== h) { var v; switch (h.updateMatrix(), h.matrixAutoUpdate = !0, C[m.path]) { case C.weights: v = Iu; break; case C.rotation: v = Du; break; case C.position: case C.scale: default: v = Uu }var g = h.name ? h.name : h.uuid, b = void 0 !== f.interpolation ? P[f.interpolation] : 2301, x = []; C[m.path] === C.weights ? h.traverse(function (e) { !0 === e.isMesh && e.morphTargetInfluences && x.push(e.name ? e.name : e.uuid) }) : x.push(g); var _ = p.array; if (p.normalized) { var w; if (_.constructor === Int8Array) w = 1 / 127; else if (_.constructor === Uint8Array) w = 1 / 255; else if (_.constructor == Int16Array) w = 1 / 32767; else { if (_.constructor !== Uint16Array) throw new Error("THREE.GLTFLoader: Unsupported output accessor component type."); w = 1 / 65535 } for (var M = new Float32Array(_.length), S = 0, T = _.length; S < T; S++)M[S] = _[S] * w; _ = M } for (S = 0, T = x.length; S < T; S++) { var E = new v(x[S] + "." + C[m.path], d.array, _, b); "CUBICSPLINE" === f.interpolation && (E.createInterpolant = function (e) { return new y(this.times, this.values, this.getValueSize() / 3, e) }, E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(E) } } } return new zu(t.name ? t.name : "animation_" + e, void 0, l) }) }, H.prototype.loadNode = function (e) { var t, n = this.json, r = this.extensions, i = this, a = n.nodes[e], o = a.name ? i.createUniqueName(a.name) : ""; return (t = [], void 0 !== a.mesh && t.push(i.getDependency("mesh", a.mesh).then(function (e) { var t = i._getNodeRef(i.meshCache, a.mesh, e); return void 0 !== a.weights && t.traverse(function (e) { if (e.isMesh) for (var t = 0, n = a.weights.length; t < n; t++)e.morphTargetInfluences[t] = a.weights[t] }), t })), void 0 !== a.camera && t.push(i.getDependency("camera", a.camera).then(function (e) { return i._getNodeRef(i.cameraCache, a.camera, e) })), i._invokeAll(function (t) { return t.createNodeAttachment && t.createNodeAttachment(e) }).forEach(function (e) { t.push(e) }), Promise.all(t)).then(function (t) { var n; if ((n = !0 === a.isBone ? new tc : t.length > 1 ? new gl : 1 === t.length ? t[0] : new Ii) !== t[0]) for (var s = 0, l = t.length; s < l; s++)n.add(t[s]); if (a.name && (n.userData.name = a.name, n.name = o), U(n, a), a.extensions && F(r, n, a), void 0 !== a.matrix) { var c = new ci; c.fromArray(a.matrix), n.applyMatrix4(c) } else void 0 !== a.translation && n.position.fromArray(a.translation), void 0 !== a.rotation && n.quaternion.fromArray(a.rotation), void 0 !== a.scale && n.scale.fromArray(a.scale); return i.associations.set(n, { type: "nodes", index: e }), n }) }, H.prototype.loadScene = function () { function e(t, n, r, i) { var a = r.nodes[t]; return i.getDependency("node", t).then(function (e) { return void 0 === a.skin ? e : i.getDependency("skin", a.skin).then(function (e) { for (var n = [], r = 0, a = (t = e).joints.length; r < a; r++)n.push(i.getDependency("node", t.joints[r])); return Promise.all(n) }).then(function (n) { return e.traverse(function (e) { if (e.isMesh) { for (var r = [], i = [], a = 0, o = n.length; a < o; a++) { var s = n[a]; if (s) { r.push(s); var l = new ci; void 0 !== t.inverseBindMatrices && l.fromArray(t.inverseBindMatrices.array, 16 * a), i.push(l) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[a]) } e.bind(new ec(r, i), e.matrixWorld) } }), e }); var t }).then(function (t) { n.add(t); var o = []; if (a.children) for (var s = a.children, l = 0, c = s.length; l < c; l++) { var u = s[l]; o.push(e(u, t, r, i)) } return Promise.all(o) }) } return function (t) { var n = this.json, r = this.extensions, i = this.json.scenes[t], a = new gl; i.name && (a.name = this.createUniqueName(i.name)), U(a, i), i.extensions && F(r, a, i); for (var o = i.nodes || [], s = [], l = 0, c = o.length; l < c; l++)s.push(e(o[l], a, n, this)); return Promise.all(s).then(function () { return a }) } }(), e }(), ap = Symbol("retainerCount"), op = Symbol("recentlyUsed"), sp = Symbol("evict"), lp = Symbol("evictionThreshold"), cp = Symbol("cache"), up = function () { function e(t) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5; _classCallCheck(this, e), this[Qd] = new Map, this[$d] = [], this[cp] = t, this[lp] = n } return _createClass(e, [{ key: "retainerCount", value: function (e) { return this[ap].get(e) || 0 } }, { key: "reset", value: function () { this[ap].clear(), this[op] = [] } }, { key: "retain", value: function (e) { this[ap].has(e) || this[ap].set(e, 0), this[ap].set(e, this[ap].get(e) + 1); var t = this[op].indexOf(e); -1 !== t && this[op].splice(t, 1), this[op].unshift(e), this[sp]() } }, { key: "release", value: function (e) { this[ap].has(e) && this[ap].set(e, Math.max(this[ap].get(e) - 1, 0)), this[sp]() } }, { key: (Qd = ap, $d = op, sp), value: function () { if (!(this[op].length < this[lp])) for (var e = this[op].length - 1; e >= this[lp]; --e) { var t = this[op][e]; 0 === this[ap].get(t) && (this[cp].delete(t), this[op].splice(e, 1)) } } }, { key: "evictionThreshold", set: function (e) { this[lp] = e, this[sp]() }, get: function () { return this[lp] } }, { key: "cache", get: function () { return this[cp] } }]), e }(), hp = function (e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () { }, r = function (e) { var t = e.loaded / e.total; n(Math.max(0, Math.min(1, isFinite(t) ? t : 1))) }; return new Promise(function (n, i) { t.load(e, n, r, i) }) }, dp = new Map, pp = new Map, fp = new Kd, mp = Symbol("loader"), vp = Symbol("evictionPolicy"), gp = Symbol("GLTFInstance"), yp = function (e) { _inherits(n, xr); var t = _createSuper(n); function n(e) { var r; return _classCallCheck(this, n), (r = t.call(this))[tp] = new ip, r[gp] = e, r[mp].setDRACOLoader(fp), r } return _createClass(n, [{ key: "preload", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t, n) { var r, i, a, o, s = arguments; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return r = s.length > 2 && void 0 !== s[2] ? s[2] : function () { }, this.dispatchEvent({ type: "preload", element: n, src: t }), dp.has(t) || (i = hp(t, this[mp], function (e) { r(.8 * e) }), a = this[gp], o = i.then(function (e) { return a.prepare(e) }).then(function (e) { return r(.9), new a(e) }), dp.set(t, o)), e.next = 5, dp.get(t); case 5: pp.set(t, !0), r && r(1); case 7: case "end": return e.stop() } }, e, this) })); return function (t, n) { return e.apply(this, arguments) } }() }, { key: "load", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t, n) { var r, i, a, o = this, s = arguments; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return r = s.length > 2 && void 0 !== s[2] ? s[2] : function () { }, e.next = 3, this.preload(t, n, r); case 3: return e.next = 5, dp.get(t); case 5: return i = e.sent, e.next = 8, i.clone(); case 8: return a = e.sent, this[vp].retain(t), a.dispose = function () { var e = a.dispose, n = !1; return function () { n || (n = !0, e.apply(a), o[vp].release(t)) } }(), e.abrupt("return", a); case 12: case "end": return e.stop() } }, e, this) })); return function (t, n) { return e.apply(this, arguments) } }() }, { key: (ep = vp, tp = mp, vp), get: function () { return this.constructor[vp] } }], [{ key: "setDRACODecoderLocation", value: function (e) { np = e, fp.setDecoderPath(e) } }, { key: "getDRACODecoderLocation", value: function () { return np } }, { key: "clearCache", value: function () { var e = this; dp.forEach(function (t, n) { e.delete(n) }), this[vp].reset() } }, { key: "has", value: function (e) { return dp.has(e) } }, { key: "delete", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { var n; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (this.has(t)) { e.next = 2; break } return e.abrupt("return"); case 2: return n = dp.get(t), pp.delete(t), dp.delete(t), e.next = 7, n; case 7: e.sent.dispose(); case 9: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "hasFinishedLoading", value: function (e) { return !!pp.get(e) } }, { key: "cache", get: function () { return dp } }]), n }(); yp[ep] = new up(yp); var bp = Symbol("velocity"), xp = function () { function e() { _classCallCheck(this, e), this[rp] = 0 } return _createClass(e, [{ key: "update", value: function (e, t, n, r) { if (null == e || 0 === r) return t; if (e === t && 0 === this[bp]) return t; if (n < 0) return e; var i = e - t, a = this[bp] + .02 * i, o = i + n * a, s = Math.exp(-.02 * n), l = (a - .02 * o) * s, c = -.02 * (l + a * s); return Math.abs(l) < 2e-4 * .02 * Math.abs(r) && c * i >= 0 ? (this[bp] = 0, t) : (this[bp] = l, t + o * s) } }]), e }(); rp = bp; var _p = function (e) { Ii.call(this), this.element = e || document.createElement("div"), this.element.style.position = "absolute", this.addEventListener("removed", function () { this.traverse(function (e) { _instanceof(e.element, Element) && null !== e.element.parentNode && e.element.parentNode.removeChild(e.element) }) }) }; _p.prototype = Object.assign(Object.create(Ii.prototype), { constructor: _p, copy: function (e, t) { return Ii.prototype.copy.call(this, e, t), this.element = e.element.cloneNode(!0), this } }); var wp, Mp, Sp, Tp, Ep, Ap, Rp, kp, Lp, Cp, Pp, Op, Ip = function () { var e, t, n, r, i = this, a = new Nr, o = new ci, s = new ci, l = { objects: new WeakMap }, c = document.createElement("div"); c.style.overflow = "hidden", this.domElement = c, this.getSize = function () { return { width: e, height: t } }, this.setSize = function (i, a) { n = (e = i) / 2, r = (t = a) / 2, c.style.width = i + "px", c.style.height = a + "px" }; var u, h, d = (u = new Nr, h = new Nr, function (e, t) { return u.setFromMatrixPosition(e.matrixWorld), h.setFromMatrixPosition(t.matrixWorld), u.distanceToSquared(h) }), p = function (e) { for (var t = function (e) { var t = []; return e.traverse(function (e) { _instanceof(e, _p) && t.push(e) }), t }(e).sort(function (e, t) { return l.objects.get(e).distanceToCameraSquared - l.objects.get(t).distanceToCameraSquared }), n = t.length, r = 0, i = t.length; r < i; r++)t[r].element.style.zIndex = n - r }; this.render = function (e, t) { !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), o.copy(t.matrixWorldInverse), s.multiplyMatrices(t.projectionMatrix, o), function e(t, o, u) { if (_instanceof(t, _p)) { t.onBeforeRender(i, o, u), a.setFromMatrixPosition(t.matrixWorld), a.applyMatrix4(s); var h = t.element, p = "translate(-50%,-50%) translate(" + (a.x * n + n) + "px," + (-a.y * r + r) + "px)"; h.style.WebkitTransform = p, h.style.MozTransform = p, h.style.oTransform = p, h.style.transform = p, h.style.display = t.visible && a.z >= -1 && a.z <= 1 ? "" : "none"; var f = { distanceToCameraSquared: d(u, t) }; l.objects.set(t, f), h.parentNode !== c && c.appendChild(h), t.onAfterRender(i, o, u) } for (var m = 0, v = t.children.length; m < v; m++)e(t.children[m], o, u) }(e, e, t), p(e) } }, Np = function (e, t) { return { type: "number", number: e, unit: t } }, Dp = function () { var e = {}; return function (t) { var n = t; if (n in e) return e[n]; for (var r = [], i = 0; t;) { if (++i > 1e3) { t = ""; break } var a = Fp(t), o = a.nodes[0]; if (null == o || 0 === o.terms.length) break; r.push(o), t = a.remainingInput } return e[n] = r } }(), Fp = (wp = /^(\-\-|[a-z\u0240-\uffff])/i, Mp = /^([\*\+\/]|[\-]\s)/i, Sp = /^[\),]/, function (e) { for (var t = []; e.length && (e = e.trim(), !Sp.test(e));)if ("(" === e[0]) { var n = Hp(e), r = n.nodes; e = n.remainingInput, t.push({ type: "function", name: { type: "ident", value: "calc" }, arguments: r }) } else if (wp.test(e)) { var i = Up(e), a = i.nodes[0]; if ("(" === (e = i.remainingInput)[0]) { var o = Hp(e), s = o.nodes, l = o.remainingInput; t.push({ type: "function", name: a, arguments: s }), e = l } else t.push(a) } else if (Mp.test(e)) t.push({ type: "operator", value: e[0] }), e = e.slice(1); else { var c = "#" === e[0] ? Bp(e) : zp(e), u = c.nodes, h = c.remainingInput; if (0 === u.length) break; t.push(u[0]), e = h } return { nodes: [{ type: "expression", terms: t }], remainingInput: e } }), Up = (Tp = /[^a-z^0-9^_^\-^\u0240-\uffff]/i, function (e) { var t = e.match(Tp); return { nodes: [{ type: "ident", value: null == t ? e : e.substr(0, t.index) }], remainingInput: null == t ? "" : e.substr(t.index) } }), zp = (Ep = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/, Ap = /^[a-z%]+/i, Rp = /^(m|mm|cm|rad|deg|[%])$/, function (e) { var t = e.match(Ep), n = null == t ? "0" : t[0], r = (e = null == n ? e : e.slice(n.length)).match(Ap), i = null != r && "" !== r[0] ? r[0] : null, a = null == r ? e : e.slice(i.length); return null == i || Rp.test(i) || (i = null), { nodes: [{ type: "number", number: parseFloat(n) || 0, unit: i }], remainingInput: a } }), Bp = (kp = /^[a-f0-9]*/i, function (e) { var t = (e = e.slice(1).trim()).match(kp); return { nodes: null == t ? [] : [{ type: "hex", value: t[0] }], remainingInput: null == t ? e : e.slice(t[0].length) } }), Hp = function (e) { var t = []; for (e = e.slice(1).trim(); e.length;) { var n = Fp(e); if (t.push(n.nodes[0]), "," === (e = n.remainingInput.trim())[0]) e = e.slice(1).trim(); else if (")" === e[0]) { e = e.slice(1); break } } return { nodes: t, remainingInput: e } }, Gp = Symbol("visitedTypes"), Vp = function () { function e(t) { _classCallCheck(this, e), this[Gp] = t } return _createClass(e, [{ key: "walk", value: function (e, t) { for (var n = e.slice(); n.length;) { var r = n.shift(); switch (this[Gp].indexOf(r.type) > -1 && t(r), r.type) { case "expression": n.unshift.apply(n, _toConsumableArray(r.terms)); break; case "function": n.unshift.apply(n, [r.name].concat(_toConsumableArray(r.arguments))) } } } }]), e }(), jp = Object.freeze({ type: "number", number: 0, unit: null }), Wp = function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = e.number, r = e.unit; if (isFinite(n)) { if ("rad" === e.unit || null == e.unit) return e } else n = t, r = "rad"; return { type: "number", number: ("deg" === r && null != n ? n : 0) * Math.PI / 180, unit: "rad" } }, qp = function (e) { var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = e.number, i = e.unit; if (isFinite(r)) { if ("m" === e.unit) return e } else r = n, i = "m"; switch (i) { default: t = 1; break; case "cm": t = .01; break; case "mm": t = .001 }return { type: "number", number: t * r, unit: "m" } }, Xp = (Cp = { rad: Lp = function (e) { return e }, deg: Wp, m: Lp, mm: qp, cm: qp }, function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : jp, n = e.number, r = e.unit; if (isFinite(n) || (n = t.number, r = t.unit), null == r) return e; var i = Cp[r]; return null == i ? t : i(e) }), Yp = function (e) { _inherits(n, _p); var t = _createSuper(n); function n(e) { var r; return _classCallCheck(this, n), (r = t.call(this, document.createElement("div"))).normal = new Nr(0, 1, 0), r.initialized = !1, r.referenceCount = 1, r.pivot = document.createElement("div"), r.slot = document.createElement("slot"), r.element.classList.add("annotation-wrapper"), r.slot.name = e.name, r.element.appendChild(r.pivot), r.pivot.appendChild(r.slot), r.updatePosition(e.position), r.updateNormal(e.normal), r } return _createClass(n, [{ key: "show", value: function () { this.facingCamera && this.initialized || this.updateVisibility(!0) } }, { key: "hide", value: function () { !this.facingCamera && this.initialized || this.updateVisibility(!1) } }, { key: "increment", value: function () { this.referenceCount++ } }, { key: "decrement", value: function () { return this.referenceCount > 0 && --this.referenceCount, 0 === this.referenceCount } }, { key: "updatePosition", value: function (e) { if (null != e) for (var t = Dp(e)[0].terms, n = 0; n < 3; ++n)this.position.setComponent(n, Xp(t[n]).number) } }, { key: "updateNormal", value: function (e) { if (null != e) for (var t = Dp(e)[0].terms, n = 0; n < 3; ++n)this.normal.setComponent(n, Xp(t[n]).number) } }, { key: "orient", value: function (e) { this.pivot.style.transform = "rotate(".concat(e, "rad)") } }, { key: "updateVisibility", value: function (e) { e ? this.element.classList.remove("hide") : this.element.classList.add("hide"), this.slot.assignedNodes().forEach(function (t) { if (t.nodeType === Node.ELEMENT_NODE) { var n = t, r = n.dataset.visibilityAttribute; if (null != r) { var i = "data-".concat(r); e ? n.setAttribute(i, "") : n.removeAttribute(i) } n.dispatchEvent(new CustomEvent("hotspot-visibility", { detail: { visible: e } })) } }), this.initialized = !0 } }, { key: "facingCamera", get: function () { return !this.element.classList.contains("hide") } }]), n }(), Jp = function (e, t) { var n = 0, r = new Nr; return e.traverse(function (e) { var i, a; e.updateWorldMatrix(!1, !1); var o = e.geometry; if (void 0 !== o) if (o.isGeometry) { var s = o.vertices; for (i = 0, a = s.length; i < a; i++)r.copy(s[i]), r.applyMatrix4(e.matrixWorld), n = t(n, r) } else if (o.isBufferGeometry) { var l = o.attributes.position; if (void 0 !== l) for (i = 0, a = l.count; i < a; i++)r.fromBufferAttribute(l, i).applyMatrix4(e.matrixWorld), n = t(n, r) } }), n }, Zp = function (e) { _inherits(n, Lh); var t = _createSuper(n); function n(e, r) { var i; return _classCallCheck(this, n), (i = t.call(this)).shadowMaterial = new mu, i.boundingBox = new Ur, i.size = new Nr, i.isAnimated = !1, i.needsUpdate = !1, i.intensity = 0, i.castShadow = !0, i.frustumCulled = !1, i.floor = new qa(new vo, i.shadowMaterial), i.floor.rotateX(-Math.PI / 2), i.floor.receiveShadow = !0, i.floor.castShadow = !1, i.floor.frustumCulled = !1, i.add(i.floor), i.shadow.camera.up.set(0, 0, 1), e.add(_assertThisInitialized(i)), i.target = e, i.setModel(e, r), i } return _createClass(n, [{ key: "setModel", value: function (e, t) { this.isAnimated = e.animationNames.length > 0, this.boundingBox.copy(e.boundingBox), this.size.copy(e.size); var n = this.boundingBox, r = this.size; if (this.isAnimated) { var i = 2 * Math.max(r.x, r.y, r.z); r.y = i, n.expandByVector(r.subScalar(i).multiplyScalar(-.5)), n.max.y = n.min.y + i, r.set(i, i, i) } var a = .001 * r.y; this.position.y = n.max.y + a, n.getCenter(this.floor.position), this.setSoftness(t) } }, { key: "setSoftness", value: function (e) { var t = Math.pow(2, 9 - 3 * e); this.setMapSize(t) } }, { key: "setMapSize", value: function (e) { var t = this.shadow, n = t.camera, r = t.mapSize, i = t.map, a = this.size, o = this.boundingBox; null != i && (i.dispose(), this.shadow.map = null), this.isAnimated && (e *= 2); var s = Math.floor(a.x > a.z ? e : e * a.x / a.z), l = Math.floor(a.x > a.z ? e * a.z / a.x : e); r.set(s, l); var c = 2.5 * a.x / s, u = 2.5 * a.z / l; n.left = -o.max.x - c, n.right = -o.min.x + c, n.bottom = o.min.z - u, n.top = o.max.z + u, this.setScaleAndOffset(n.zoom, 0), this.shadow.updateMatrices(this), this.floor.scale.set(a.x + 2 * c, a.z + 2 * u, 1), this.needsUpdate = !0 } }, { key: "setIntensity", value: function (e) { this.shadowMaterial.opacity = e, e > 0 ? (this.visible = !0, this.floor.visible = !0) : (this.visible = !1, this.floor.visible = !1) } }, { key: "getIntensity", value: function () { return this.shadowMaterial.opacity } }, { key: "setRotation", value: function (e) { this.shadow.camera.up.set(Math.sin(e), 0, Math.cos(e)), this.shadow.updateMatrices(this) } }, { key: "setScaleAndOffset", value: function (e, t) { var n = this.size.y, r = 1 / e, i = .001 * n; this.floor.position.y = 2 * i - n + t * r; var a = this.shadow.camera; a.zoom = e, a.near = 0, a.far = n * e - t, a.projectionMatrix.makeOrthographic(a.left * e, a.right * e, a.top * e, a.bottom * e, a.near, a.far), a.projectionMatrixInverse.getInverse(a.projectionMatrix) } }]), n }(), Kp = 45, Qp = Kp / 2 * Math.PI / 180, $p = Math.sin(Qp), ef = Math.tan(Qp), tf = Symbol("shadow"), nf = Symbol("cancelPendingSourceChange"), rf = Symbol("currentGLTF"), af = new Nr, of = new Nr, sf = new Nr, lf = function (e) { _inherits(n, Ii); var t = _createSuper(n); function n() { var e; return _classCallCheck(this, n), (e = t.call(this))[Pp] = null, e[Op] = null, e.animationsByName = new Map, e.currentAnimationAction = null, e.animations = [], e.modelContainer = new Ii, e.animationNames = [], e.boundingBox = new Ur, e.size = new Nr, e.idealCameraDistance = 0, e.fieldOfViewAspect = 0, e.userData = { url: null }, e.url = null, e.name = "Model", e.modelContainer.name = "ModelContainer", e.add(e.modelContainer), e.mixer = new dd(e.modelContainer), e } return _createClass(n, [{ key: "hasModel", value: function () { return !!this.modelContainer.children.length } }, { key: "setObject", value: function (e) { this.clear(), this.modelContainer.add(e), this.updateFraming(), this.dispatchEvent({ type: "model-load" }) } }, { key: "setSource", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t, n, r) { var i, a, o, s, l, c, u, h = this; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (n && n !== this.url) { e.next = 3; break } return r && r(1), e.abrupt("return"); case 3: return null != this[nf] && (this[nf](), this[nf] = null), this.url = n, e.prev = 5, e.next = 8, new Promise(function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(i, a) { var o; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return h[nf] = function () { return a() }, e.prev = 1, e.next = 4, t[ry].loader.load(n, t, r); case 4: o = e.sent, i(o), e.next = 11; break; case 8: e.prev = 8, e.t0 = e.catch(1), a(e.t0); case 11: case "end": return e.stop() } }, e, null, [[1, 8]]) })); return function (t, n) { return e.apply(this, arguments) } }()); case 8: i = e.sent, e.next = 16; break; case 11: if (e.prev = 11, e.t0 = e.catch(5), null != e.t0) { e.next = 15; break } return e.abrupt("return"); case 15: throw e.t0; case 16: this.clear(), this[rf] = i, null != i && this.modelContainer.add(i.scene), a = i.animations, o = new Map, s = [], l = _createForOfIteratorHelper(a); try { for (l.s(); !(c = l.n()).done;)u = c.value, o.set(u.name, u), s.push(u.name) } catch (e) { l.e(e) } finally { l.f() } this.animations = a, this.animationsByName = o, this.animationNames = s, this.userData.url = n, this.updateFraming(), this.dispatchEvent({ type: "model-load", url: n }); case 30: case "end": return e.stop() } }, e, this, [[5, 11]]) })); return function (t, n, r) { return e.apply(this, arguments) } }() }, { key: "playAnimation", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = this.animations; if (null != n && 0 !== n.length) { var r = null; null != e && (r = this.animationsByName.get(e)), null == r && (r = n[0]); try { var i = this.currentAnimationAction; this.currentAnimationAction = this.mixer.clipAction(r, this).play(), this.currentAnimationAction.enabled = !0, null != i && this.currentAnimationAction !== i && this.currentAnimationAction.crossFadeFrom(i, t, !1) } catch (e) { console.error(e) } } else console.warn("Cannot play animation (model does not have any animations)") } }, { key: "stopAnimation", value: function () { null != this.currentAnimationAction && (this.currentAnimationAction.stop(), this.currentAnimationAction.reset(), this.currentAnimationAction = null), this.mixer.stopAllAction() } }, { key: "updateAnimation", value: function (e) { this.mixer.update(e) } }, { key: "clear", value: function () { this.url = null, this.userData = { url: null }; var e = this[rf]; if (null != e) { var t, n = _createForOfIteratorHelper(this.modelContainer.children); try { for (n.s(); !(t = n.n()).done;) { var r = t.value; this.modelContainer.remove(r) } } catch (e) { n.e(e) } finally { n.f() } e.dispose(), this[rf] = null } null != this.currentAnimationAction && (this.currentAnimationAction.stop(), this.currentAnimationAction = null), this.mixer.stopAllAction(), this.mixer.uncacheRoot(this) } }, { key: "updateFraming", value: function () { var e = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; this.remove(this.modelContainer), null == t && (this.boundingBox.setFromObject(this.modelContainer), this.boundingBox.getSize(this.size), t = this.boundingBox.getCenter(new Nr)); var n = Math.sqrt(Jp(this.modelContainer, function (e, n) { return Math.max(e, t.distanceToSquared(n)) })); this.idealCameraDistance = n / $p; this.fieldOfViewAspect = Jp(this.modelContainer, function (n, r) { r.sub(t); var i = Math.sqrt(r.x * r.x + r.z * r.z); return Math.max(n, i / (e.idealCameraDistance - Math.abs(r.y))) }) / ef, this.add(this.modelContainer) } }, { key: "setShadowIntensity", value: function (e, t) { var n = this[tf]; null != n ? (n.setIntensity(e), n.setModel(this, t)) : e > 0 && ((n = new Zp(this, t)).setIntensity(e), this[tf] = n) } }, { key: "setShadowSoftness", value: function (e) { var t = this[tf]; null != t && t.setSoftness(e) } }, { key: "setShadowRotation", value: function (e) { var t = this[tf]; null != t && t.setRotation(e) } }, { key: "updateShadow", value: function () { var e = this[tf]; if (null == e) return !1; var t = e.needsUpdate; return e.needsUpdate = !1, t } }, { key: "setShadowScaleAndOffset", value: function (e, t) { var n = this[tf]; null != n && n.setScaleAndOffset(e, t) } }, { key: "addHotspot", value: function (e) { this.add(e) } }, { key: "removeHotspot", value: function (e) { this.remove(e) } }, { key: "forHotspots", value: function (e) { for (var t = this.children, n = 0, r = t.length; n < r; n++) { var i = t[n]; _instanceof(i, Yp) && e(i) } } }, { key: "updateHotspots", value: function (e) { var t = this; this.forHotspots(function (n) { af.copy(e), of.setFromMatrixPosition(n.matrixWorld), af.sub(of), sf.copy(n.normal).transformDirection(t.matrixWorld), af.dot(sf) < 0 ? n.hide() : n.show() }) } }, { key: "orientHotspots", value: function (e) { this.forHotspots(function (t) { t.orient(e) }) } }, { key: "setHotspotsVisibility", value: function (e) { this.forHotspots(function (t) { t.visible = e }) } }, { key: "currentGLTF", get: function () { return this[rf] } }, { key: "animationTime", set: function (e) { this.mixer.setTime(e) }, get: function () { return null != this.currentAnimationAction ? this.currentAnimationAction.time : 0 } }, { key: "hasActiveAnimation", get: function () { return null != this.currentAnimationAction } }]), n }(); Pp = tf, Op = rf; var cf, uf = Math.tan(Kp / 2 * Math.PI / 180), hf = new vd, df = new Nr, pf = function (e) { _inherits(n, Ml); var t = _createSuper(n); function n(e) { var r, i = e.canvas, a = e.element, o = e.width, s = e.height; return _classCallCheck(this, n), (r = t.call(this)).aspect = 1, r.shadowIntensity = 0, r.shadowSoftness = 1, r.width = 1, r.height = 1, r.isDirty = !1, r.context = null, r.exposure = 1, r.canScale = !0, r.framedFieldOfView = Kp, r.camera = new ro(45, 1, .1, 100), r.goalTarget = new Nr, r.targetDamperX = new xp, r.targetDamperY = new xp, r.targetDamperZ = new xp, r.name = "ModelScene", r.element = a, r.canvas = i, r.model = new lf, r.camera = new ro(45, 1, .1, 100), r.camera.name = "MainCamera", r.activeCamera = r.camera, r.add(r.model), r.setSize(o, s), r.model.addEventListener("model-load", function (e) { return r.onModelLoad(e) }), r } return _createClass(n, [{ key: "createContext", value: function () { this.context = this.canvas.getContext("2d") } }, { key: "setModelSource", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t, n) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.prev = 0, e.next = 3, this.model.setSource(this.element, t, n); case 3: e.next = 8; break; case 5: throw e.prev = 5, e.t0 = e.catch(0), new Error("Could not set model source to '".concat(t, "': ").concat(e.t0.message)); case 8: case "end": return e.stop() } }, e, this, [[0, 5]]) })); return function (t, n) { return e.apply(this, arguments) } }() }, { key: "setSize", value: function (e, t) { this.width === e && this.height === t || (this.width = Math.max(e, 1), this.height = Math.max(t, 1), this.aspect = this.width / this.height, this.frameModel(), this.isDirty = !0) } }, { key: "frameModel", value: function () { var e = uf * Math.max(1, this.model.fieldOfViewAspect / this.aspect); this.framedFieldOfView = 2 * Math.atan(e) * 180 / Math.PI } }, { key: "getSize", value: function () { return { width: this.width, height: this.height } } }, { key: "getCamera", value: function () { return this.activeCamera } }, { key: "setCamera", value: function (e) { this.activeCamera = e } }, { key: "onModelLoad", value: function (e) { this.frameModel(), this.setShadowIntensity(this.shadowIntensity), this.isDirty = !0, this.dispatchEvent({ type: "model-load", url: e.url }) } }, { key: "setTarget", value: function (e, t, n) { this.goalTarget.set(-e, -t, -n) } }, { key: "getTarget", value: function () { return df.copy(this.goalTarget).multiplyScalar(-1) } }, { key: "jumpToGoal", value: function () { this.updateTarget(1e4) } }, { key: "updateTarget", value: function (e) { var t = this.goalTarget, n = this.model.position; if (!t.equals(n)) { var r = this.model.idealCameraDistance, i = n.x, a = n.y, o = n.z; i = this.targetDamperX.update(i, t.x, e, r), a = this.targetDamperY.update(a, t.y, e, r), o = this.targetDamperZ.update(o, t.z, e, r), this.model.position.set(i, a, o), this.model.updateMatrixWorld(), this.model.setShadowRotation(this.yaw), this.isDirty = !0 } } }, { key: "pointTowards", value: function (e, t) { var n = this.position, r = n.x, i = n.z; this.yaw = Math.atan2(e - r, t - i) } }, { key: "setShadowIntensity", value: function (e) { e = Math.max(e, 0), this.shadowIntensity = e, this.model.hasModel() && this.model.setShadowIntensity(e, this.shadowSoftness) } }, { key: "setShadowSoftness", value: function (e) { this.shadowSoftness = e, this.model.setShadowSoftness(e) } }, { key: "positionAndNormalFromPoint", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this; hf.setFromCamera(e, this.getCamera()); var n = hf.intersectObject(t, !0); if (0 === n.length) return null; var r = n[0]; return null == r.face ? null : (r.face.normal.applyNormalMatrix((new Ar).getNormalMatrix(r.object.matrixWorld)), { position: r.point, normal: r.face.normal }) } }, { key: "yaw", set: function (e) { this.rotation.y = e, this.model.setShadowRotation(e), this.isDirty = !0 }, get: function () { return this.rotation.y } }]), n }(), ff = ((cf = new vu({ uniforms: { roughnessMap: { value: null }, normalMap: { value: null }, texelSize: { value: new Er(1, 1) } }, vertexShader: "\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t", fragmentShader: "\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t", blending: Be, depthTest: !1, depthWrite: !1 })).type = "RoughnessMipmapper", cf), mf = new qa(new vo(2, 2), ff), vf = new Rh(0, 1, 0, 1, 0, 1), gf = null, yf = null; function bf(e) { (yf = e).compile(mf, vf) } bf.prototype = { constructor: bf, generateMipmaps: function (e) { if ("roughnessMap" in e != !1) { var t = e.roughnessMap, n = e.normalMap; if (null !== t && null !== n && t.generateMipmaps && !e.userData.roughnessUpdated) { e.userData.roughnessUpdated = !0; var r = Math.max(t.image.width, n.image.width), i = Math.max(t.image.height, n.image.height); if (Tr.isPowerOfTwo(r) && Tr.isPowerOfTwo(i)) { var a = yf.getRenderTarget(), o = yf.autoClear; if (yf.autoClear = !1, null !== gf && gf.width === r && gf.height === i || (null !== gf && gf.dispose(), (gf = new Pr(r, i, { depthBuffer: !1 })).scissorTest = !0), r !== t.image.width || i !== t.image.height) { var s = new Pr(r, i, { wrapS: t.wrapS, wrapT: t.wrapT, magFilter: t.magFilter, minFilter: t.minFilter, depthBuffer: !1 }); s.texture.generateMipmaps = !0, yf.setRenderTarget(s), e.roughnessMap = s.texture, e.metalnessMap == t && (e.metalnessMap = e.roughnessMap), e.aoMap == t && (e.aoMap = e.roughnessMap) } ff.uniforms.roughnessMap.value = t, ff.uniforms.normalMap.value = n; for (var l = new Er(0, 0), c = ff.uniforms.texelSize.value, u = 0; r >= 1 && i >= 1; ++u, r /= 2, i /= 2)c.set(1 / r, 1 / i), 0 == u && c.set(0, 0), gf.viewport.set(l.x, l.y, r, i), gf.scissor.set(l.x, l.y, r, i), yf.setRenderTarget(gf), yf.render(mf, vf), yf.copyFramebufferToTexture(l, e.roughnessMap, u), ff.uniforms.roughnessMap.value = e.roughnessMap; t !== e.roughnessMap && t.dispose(), yf.setRenderTarget(a), yf.autoClear = o } } } }, dispose: function () { ff.dispose(), mf.geometry.dispose(), null != gf && gf.dispose() } }; var xf, _f, wf, Mf, Sf, Tf, Ef, Af, Rf, kf, Lf, Cf, Pf, Of, If, Nf, Df, Ff, Uf, zf, Bf, Hf, Gf, Vf, jf, Wf, qf, Xf, Yf, Jf, Zf, Kf, Qf, $f, em, tm, nm, rm, im, am, om, sm, lm, cm, um, hm, dm, pm, fm, mm, vm, gm = function (e) { return e && "null" !== e ? bm(e) : null }, ym = function () { if (!xe) { var e = []; throw ve || e.push("WebXR Device API"), ge || e.push("WebXR Hit Test API"), new Error("The following APIs are required for AR, but are missing in this browser: ".concat(e.join(", "))) } }, bm = function (e) { return new URL(e, window.location.toString()).toString() }, xm = function (e, t) { var n = null, r = function () { null == n && (e.apply(void 0, arguments), n = self.setTimeout(function () { return n = null }, t)) }; return r.flush = function () { null != n && (self.clearTimeout(n), n = null) }, r }, _m = function (e, t) { var n = null; return function () { for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++)i[a] = arguments[a]; null != n && self.clearTimeout(n), n = self.setTimeout(function () { n = null, e.apply(void 0, i) }, t) } }, wm = function (e, t, n) { return Math.max(t, Math.min(n, e)) }, Mm = ((xf = function () { var e, t = _createForOfIteratorHelper(null != document.head ? Array.from(document.head.querySelectorAll("meta")) : []); try { for (t.s(); !(e = t.n()).done;) { if ("viewport" === e.value.name) return !0 } } catch (e) { t.e(e) } finally { t.f() } return !1 }()) || console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.'), function () { return xf ? window.devicePixelRatio : 1 }), Sm = (_f = new RegExp("[?&]".concat("model-viewer-debug-mode", "(&|$)")), function () { return self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(_f) }), Tm = function (e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; return new Promise(function (r) { e.addEventListener(t, function i(a) { n && !n(a) || (r(a), e.removeEventListener(t, i)) }) }) }, Em = .2, Am = Math.PI / 24, Rm = new Er, km = function (e, t, n) { for (var r = t > 0 ? n > 0 ? 0 : -Math.PI / 2 : n > 0 ? Math.PI / 2 : Math.PI, i = 0; i <= 12; ++i)e.push(t + (Em - .03) * Math.cos(r), n + (Em - .03) * Math.sin(r), 0, t + Em * Math.cos(r), n + Em * Math.sin(r), 0), r += Am }, Lm = function (e) { _inherits(n, qa); var t = _createSuper(n); function n(e) { var r; _classCallCheck(this, n); var i = new Ra, a = [], o = [], s = e.size, l = e.boundingBox, c = s.x / 2, u = s.z / 2; km(o, c, u), km(o, -c, u), km(o, -c, -u), km(o, c, -u); for (var h = o.length / 3, d = 0; d < h - 2; d += 2)a.push(d, d + 1, d + 3, d, d + 3, d + 2); var p = h - 2; a.push(p, p + 1, 1, p, 1, 0), i.setAttribute("position", new ga(o, 3)), i.setIndex(a); var f = (r = t.call(this, i)).material; return f.side = ze, f.transparent = !0, f.opacity = 0, r.goalOpacity = 0, r.opacityDamper = new xp, r.hitPlane = new qa(new vo(s.x + 2 * Em, s.z + 2 * Em)), r.hitPlane.visible = !1, r.add(r.hitPlane), r.rotateX(-Math.PI / 2), l.getCenter(r.position), r.shadowHeight = l.min.y, r.position.y = r.shadowHeight, e.add(_assertThisInitialized(r)), r } return _createClass(n, [{ key: "getHit", value: function (e, t, n) { Rm.set(t, -n), this.hitPlane.visible = !0; var r = e.positionAndNormalFromPoint(Rm, this.hitPlane); return this.hitPlane.visible = !1, null == r ? null : r.position } }, { key: "updateOpacity", value: function (e) { var t = this.material; t.opacity = this.opacityDamper.update(t.opacity, this.goalOpacity, e, 1), this.visible = t.opacity > 0 } }, { key: "dispose", value: function () { var e = this.hitPlane, t = e.geometry, n = e.material; t.dispose(), n.dispose(), this.geometry.dispose(), this.material.dispose() } }, { key: "offsetHeight", set: function (e) { this.position.y = this.shadowHeight + e }, get: function () { return this.position.y - this.shadowHeight } }, { key: "show", set: function (e) { this.goalOpacity = e ? .75 : 0 } }]), n }(), Cm = { NOT_PRESENTING: "not-presenting", SESSION_STARTED: "session-started", OBJECT_PLACED: "object-placed", FAILED: "failed" }, Pm = Symbol("presentedScene"), Om = Symbol("placementBox"), Im = Symbol("lastTick"), Nm = Symbol("turntableRotation"), Dm = Symbol("oldShadowIntensity"), Fm = Symbol("oldBackground"), Um = Symbol("rafId"), zm = Symbol("currentSession"), Bm = Symbol("tick"), Hm = Symbol("refSpace"), Gm = Symbol("viewerRefSpace"), Vm = Symbol("frame"), jm = Symbol("initialized"), Wm = Symbol("initialModelToWorld"), qm = Symbol("placementComplete"), Xm = Symbol("hitTestSource"), Ym = Symbol("transiertHitTestSource"), Jm = Symbol("inputSource"), Zm = Symbol("isTranslating"), Km = Symbol("isRotating"), Qm = Symbol("isScaling"), $m = Symbol("lastDragPosition"), ev = Symbol("lastScalar"), tv = Symbol("goalPosition"), nv = Symbol("goalYaw"), rv = Symbol("goalScale"), iv = Symbol("xDamper"), av = Symbol("yDamper"), ov = Symbol("zDamper"), sv = Symbol("yawDamper"), lv = Symbol("scaleDamper"), cv = Symbol("damperRate"), uv = Symbol("resolveCleanup"), hv = Symbol("exitWebXRButtonContainer"), dv = Symbol("onWebXRFrame"), pv = Symbol("postSessionCleanup"), fv = Symbol("updateCamera"), mv = Symbol("placeInitially"), vv = Symbol("getHitPoint"), gv = Symbol("onSelectStart"), yv = Symbol("onSelect"), bv = Symbol("onUpdateScene"), xv = Symbol("fingerSeparation"), _v = Symbol("processInput"), wv = Symbol("moveScene"), Mv = Symbol("onExitWebXRButtonContainerClick"), Sv = new Nr, Tv = new ci, Ev = new Nr, Av = function (e) { _inherits(n, xr); var t = _createSuper(n); function n(e) { var r; return _classCallCheck(this, n), (r = t.call(this)).renderer = e, r.camera = new ro, r[wf] = null, r[Mf] = null, r[Sf] = null, r[Tf] = null, r[Ef] = null, r[Af] = null, r[Rf] = null, r[kf] = null, r[Lf] = null, r[Cf] = null, r[Pf] = null, r[Of] = null, r[If] = null, r[Nf] = null, r[Df] = null, r[Ff] = null, r[Uf] = !1, r[zf] = new ci, r[Bf] = !1, r[Hf] = !1, r[Gf] = !1, r[Vf] = !1, r[jf] = new Nr, r[Wf] = 0, r[qf] = new Nr, r[Xf] = 0, r[Yf] = 1, r[Jf] = new xp, r[Zf] = new xp, r[Kf] = new xp, r[Qf] = new xp, r[$f] = new xp, r[em] = 1, r[tm] = function () { return r.stopPresenting() }, r[nm] = function () { null != r[Om] && r.isPresenting && (r[Om].dispose(), r[Om] = new Lm(r[Pm].model)) }, r[rm] = function (e) { var t = r[Ym]; if (null != t) { var n = r[Vm].getHitTestResultsForTransientInput(t), i = r[Pm], a = r[Om]; if (1 === n.length) { r[Jm] = e.inputSource; var o = r[Jm].gamepad.axes, s = a.getHit(r[Pm], o[0], o[1]); a.show = !0, null != s ? (r[Zm] = !0, r[$m].copy(s)) : (r[Km] = !0, r[ev] = o[0]) } else 2 === n.length && i.canScale && (a.show = !0, r[Qm] = !0, r[ev] = r[xv](n) / i.scale.x) } }, r[im] = function () { r[Zm] = !1, r[Km] = !1, r[Qm] = !1, r[Jm] = null, r[tv].y += r[Om].offsetHeight * r[Pm].scale.x, r[Om].show = !1 }, r.threeRenderer = e.threeRenderer, r.camera.matrixAutoUpdate = !1, r } return _createClass(n, [{ key: "resolveARSession", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { var n, r, i, a, o, s, l, c; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return ym(), e.next = 3, navigator.xr.requestSession("immersive-ar", { requiredFeatures: ["hit-test"], optionalFeatures: ["dom-overlay"], domOverlay: { root: t.element.shadowRoot.querySelector("div.default") } }); case 3: return n = e.sent, r = this.threeRenderer.context, e.next = 7, r.makeXRCompatible(); case 7: return n.updateRenderState({ baseLayer: new XRWebGLLayer(n, r, { alpha: !0 }) }), i = new Promise(function (e, t) { n.requestAnimationFrame(function () { return e() }) }), e.next = 11, i; case 11: return t.element[ny](window.screen), a = n.renderState.baseLayer, o = a.framebuffer, s = a.framebufferWidth, l = a.framebufferHeight, this.threeRenderer.setFramebuffer(o), this.threeRenderer.setPixelRatio(1), this.threeRenderer.setSize(s, l, !1), (c = t.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button")).classList.add("enabled"), c.addEventListener("click", this[Mv]), this[hv] = c, e.abrupt("return", n); case 21: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "supportsPresentation", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e() { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.prev = 0, ym(), e.next = 4, navigator.xr.isSessionSupported("immersive-ar"); case 4: return e.abrupt("return", e.sent); case 7: return e.prev = 7, e.t0 = e.catch(0), e.abrupt("return", !1); case 10: case "end": return e.stop() } }, e, null, [[0, 7]]) })); return function () { return e.apply(this, arguments) } }() }, { key: "present", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { var n, r, i, a, o = this; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return this.isPresenting && console.warn("Cannot present while a model is already presenting"), n = new Promise(function (e, t) { requestAnimationFrame(function () { return e() }) }), t.model.setHotspotsVisibility(!1), t.isDirty = !0, e.next = 6, n; case 6: return this[Pm] = t, e.next = 9, this.resolveARSession(t); case 9: return (r = e.sent).addEventListener("end", function () { o[pv]() }, { once: !0 }), e.next = 13, r.requestReferenceSpace("local"); case 13: return this[Hm] = e.sent, e.next = 16, r.requestReferenceSpace("viewer"); case 16: this[Gm] = e.sent, t.setCamera(this.camera), this[jm] = !1, this[cv] = .4, this[Nm] = t.yaw, t.yaw = 0, this[nv] = 0, this[rv] = 1, this[Fm] = t.background, t.background = null, this[Dm] = t.shadowIntensity, t.setShadowIntensity(0), t.addEventListener("model-load", this[bv]), i = 20 * Math.PI / 180, a = new XRRay(new DOMPoint(0, 0, 0), { x: 0, y: -Math.sin(i), z: -Math.cos(i) }), r.requestHitTestSource({ space: this[Gm], offsetRay: a }).then(function (e) { o[Xm] = e }), this[zm] = r, this[Om] = new Lm(t.model), this[qm] = !1, this[Im] = performance.now(), this[Bm](); case 37: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "stopPresenting", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e() { var t, n = this; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (this.isPresenting) { e.next = 2; break } return e.abrupt("return"); case 2: return t = new Promise(function (e) { n[uv] = e }), e.prev = 3, e.next = 6, this[zm].end(); case 6: return e.next = 8, t; case 8: e.next = 15; break; case 10: e.prev = 10, e.t0 = e.catch(3), console.warn("Error while trying to end AR session"), console.warn(e.t0), this[pv](); case 15: case "end": return e.stop() } }, e, this, [[3, 10]]) })); return function () { return e.apply(this, arguments) } }() }, { key: (wf = Om, Mf = Im, Sf = Nm, Tf = Dm, Ef = Fm, Af = Um, Rf = zm, kf = Hm, Lf = Gm, Cf = Vm, Pf = Xm, Of = Ym, If = Jm, Nf = Pm, Df = uv, Ff = hv, Uf = jm, zf = Wm, Bf = qm, Hf = Zm, Gf = Km, Vf = Qm, jf = $m, Wf = ev, qf = tv, Xf = nv, Yf = rv, Jf = iv, Zf = av, Kf = ov, Qf = sv, $f = lv, em = cv, tm = Mv, pv), value: function () { this.threeRenderer.setFramebuffer(null); var e = this[zm]; null != e && (e.removeEventListener("selectstart", this[gv]), e.removeEventListener("selectend", this[yv]), e.cancelAnimationFrame(this[Um]), this[zm] = null); var t = this[Pm]; if (null != t) { var n = t.model, r = t.element; t.setCamera(t.camera), n.remove(this[Om]), t.position.set(0, 0, 0), t.scale.set(1, 1, 1), n.setShadowScaleAndOffset(1, 0); var i = this[Nm]; null != i && (t.yaw = i); var a = this[Dm]; null != a && t.setShadowIntensity(a); var o = this[Fm]; null != o && (t.background = o), t.removeEventListener("model-load", this[bv]), n.orientHotspots(0), r.requestUpdate("cameraTarget"), r[ny](r.getBoundingClientRect()) } this.renderer.height = 0; var s = this[hv]; null != s && (s.classList.remove("enabled"), s.removeEventListener("click", this[Mv]), this[hv] = null); var l = this[Ym]; null != l && (l.cancel(), this[Ym] = null); var c = this[Xm]; null != c && (c.cancel(), this[Xm] = null), null != this[Om] && (this[Om].dispose(), this[Om] = null), this[Im] = null, this[Nm] = null, this[Dm] = null, this[Fm] = null, this[Um] = null, this[Hm] = null, this[Pm] = null, this[Gm] = null, this[Vm] = null, this[Jm] = null, null != this[uv] && this[uv](), this.dispatchEvent({ type: "status", status: Cm.NOT_PRESENTING }) } }, { key: "updateTarget", value: function () { var e = this[Pm]; if (null != e) { var t = e.getTarget(); e.setTarget(t.x, e.model.boundingBox.min.y, t.z) } } }, { key: (nm = bv, fv), value: function (e) { var t = this.camera, n = t.matrix; if (n.fromArray(e.transform.matrix), t.updateMatrixWorld(!0), t.position.setFromMatrixPosition(n), null != this[Xm]) { var r = this[Pm], i = r.position, a = r.model.idealCameraDistance; t.getWorldDirection(i), i.multiplyScalar(a), i.add(t.position) } if (!this[jm]) { t.projectionMatrix.fromArray(e.projectionMatrix), t.projectionMatrixInverse.getInverse(t.projectionMatrix); var o = t.position, s = o.x, l = o.z, c = this[Pm]; c.pointTowards(s, l), c.model.updateMatrixWorld(!0), this[nv] = c.yaw, this[Wm].copy(c.model.matrixWorld), c.model.setHotspotsVisibility(!0), this[jm] = !0, this.dispatchEvent({ type: "status", status: Cm.SESSION_STARTED }) } if (e.requestViewportScale && e.recommendedViewportScale) { var u = e.recommendedViewportScale; e.requestViewportScale(Math.max(u, .25)) } var h = this[zm].renderState.baseLayer.getViewport(e); this.threeRenderer.setViewport(h.x, h.y, h.width, h.height), this[Pm].model.orientHotspots(Math.atan2(n.elements[1], n.elements[5])) } }, { key: mv, value: function (e) { var t = this, n = this[Xm]; if (null != n) { var r = e.getHitTestResults(n); if (0 != r.length) { var i = r[0], a = this[vv](i); if (null != a) { this.placeModel(a), n.cancel(), this[Xm] = null; var o = e.session; o.addEventListener("selectstart", this[gv]), o.addEventListener("selectend", this[yv]), o.requestHitTestSourceForTransientInput({ profile: "generic-touchscreen" }).then(function (e) { t[Ym] = e }) } } } } }, { key: vv, value: function (e) { var t = e.getPose(this[Hm]); if (null == t) return null; var n = Tv.fromArray(t.transform.matrix); return n.elements[5] > .75 ? Ev.setFromMatrixPosition(n) : null } }, { key: "placeModel", value: function (e) { var t = this[Pm], n = t.model, r = n.boundingBox, i = r.min, a = r.max; this[Om].show = !0; var o = this[tv]; o.copy(e); var s = e.y, l = this.camera.position.clone(), c = e.clone().sub(l).normalize(); l.sub(c.multiplyScalar(n.idealCameraDistance)); var u = new li(l, c.normalize()), h = this[Wm], d = (new Nr).setFromMatrixPosition(h).add(e); h.setPosition(d); var p = (new ci).getInverse(h); u.applyMatrix4(p), a.y += 10, u.intersectBox(n.boundingBox, d), a.y -= 10, null != d && (d.applyMatrix4(h), o.add(e).sub(d)); var f = t.getTarget(); t.setTarget(f.x, i.y, f.z), o.y = s, this.dispatchEvent({ type: "status", status: Cm.OBJECT_PLACED }) } }, { key: (rm = gv, im = yv, xv), value: function (e) { var t = e[0].inputSource.gamepad.axes, n = e[1].inputSource.gamepad.axes, r = n[0] - t[0], i = n[1] - t[1]; return Math.sqrt(r * r + i * i) } }, { key: _v, value: function (e) { var t = this, n = this[Ym]; if (null != n && (this[Zm] || this[Qm] || this[Km])) { var r = e.getHitTestResultsForTransientInput(n), i = this[Pm], a = i.scale.x; if (this[Qm]) if (r.length < 2) this[Qm] = !1; else { var o = this[xv](r) / this[ev]; this[rv] = o < 1.2 && o > 1 / 1.2 ? 1 : o } else { if (2 === r.length && i.canScale) return this[Zm] = !1, this[Km] = !1, this[Qm] = !0, void (this[ev] = this[xv](r) / a); if (this[Km]) { var s = this[Jm].gamepad.axes[0]; this[nv] += 1.5 * (s - this[ev]), this[ev] = s } else this[Zm] && r.forEach(function (e) { if (!(e.inputSource !== t[Jm] || e.results.length < 1)) { var n = t[vv](e.results[0]); if (null != n) { t[tv].sub(t[$m]); var r = n.y - t[$m].y; if (r < 0) { t[Om].offsetHeight = r / a, t[Pm].model.setShadowScaleAndOffset(a, r); var i = Sv.copy(t.camera.position), o = -r / (i.y - n.y); i.multiplyScalar(o), n.multiplyScalar(1 - o).add(i) } t[tv].add(n), t[$m].copy(n) } } }) } } } }, { key: wv, value: function (e) { var t = this[Pm], n = t.model, r = t.position, i = t.yaw, a = n.idealCameraDistance, o = this[tv], s = t.scale.x, l = this[Om]; if (null == this[Xm] && (!o.equals(r) || this[rv] !== s)) { var c = r.x, u = r.y, h = r.z; e *= this[cv], c = this[iv].update(c, o.x, e, a), u = this[av].update(u, o.y, e, a), h = this[ov].update(h, o.z, e, a), r.set(c, u, h); var d = this[lv].update(s, this[rv], e, 1); if (t.scale.set(d, d, d), !this[Zm]) { var p = o.y - u; this[qm] ? (l.offsetHeight = p / d, n.setShadowScaleAndOffset(d, p)) : 0 === p && (this[qm] = !0, l.show = !1, t.setShadowIntensity(.3), this[cv] = 1) } } l.updateOpacity(e), t.updateTarget(e), t.updateMatrixWorld(!0), t.yaw = this[sv].update(i, this[nv], e, Math.PI) } }, { key: Bm, value: function () { var e = this; this[Um] = this[zm].requestAnimationFrame(function (t, n) { return e[dv](t, n) }) } }, { key: dv, value: function (e, t) { this[Vm] = t; var n = t.getViewerPose(this[Hm]); this[Bm](); var r = this[Pm]; if (null != n && null != r) { var i, a = !0, o = _createForOfIteratorHelper(n.views); try { for (o.s(); !(i = o.n()).done;) { var s = i.value; if (this[fv](s), a) { this[mv](t), this[_v](t); var l = e - this[Im]; this[wv](l), this.renderer.preRender(r, e, l), this[Im] = e } this.threeRenderer.render(r, this.camera), a = !1 } } catch (e) { o.e(e) } finally { o.f() } } } }, { key: "presentedScene", get: function () { return this[Pm] } }, { key: "isPresenting", get: function () { return null != this[Pm] } }]), n }(), Rv = function () { function e(t) { _classCallCheck(this, e), t.threeRenderer.debug = { checkShaderErrors: !0 }, Promise.resolve().then(function () { self.dispatchEvent(new CustomEvent("model-viewer-renderer-debug", { detail: { renderer: t, THREE: { ShaderMaterial: to, Texture: Lr, Mesh: qa, Scene: Ml, PlaneBufferGeometry: vo, OrthographicCamera: Rh, WebGLRenderTarget: Pr } } })) }) } return _createClass(e, [{ key: "addScene", value: function (e) { self.dispatchEvent(new CustomEvent("model-viewer-scene-added-debug", { detail: { scene: e } })) } }, { key: "removeScene", value: function (e) { self.dispatchEvent(new CustomEvent("model-viewer-scene-removed-debug", { detail: { scene: e } })) } }]), e }(), kv = Symbol("threeGLTF"), Lv = Symbol("gltf"), Cv = Symbol("gltfElementMap"), Pv = Symbol("threeObjectMap"), Ov = Symbol("parallelTraverseThreeScene"), Iv = Symbol("correlateOriginalThreeGLTF"), Nv = Symbol("correlateCloneThreeGLTF"), Dv = function () { function e(t, n, r, i) { _classCallCheck(this, e), this[kv] = t, this[Lv] = n, this[Cv] = i, this[Pv] = r } return _createClass(e, [{ key: "threeGLTF", get: function () { return this[kv] } }, { key: "gltf", get: function () { return this[Lv] } }, { key: "gltfElementMap", get: function () { return this[Cv] } }, { key: "threeObjectMap", get: function () { return this[Pv] } }], [{ key: "from", value: function (e, t) { return null != t ? this[Nv](e, t) : this[Iv](e) } }, { key: Iv, value: function (t) { var n = t.parser.json, r = t.parser.associations, i = new Map; return r.forEach(function (e, t) { if (null != e) { var r = e.type, a = e.index, o = (n[r] || [])[a]; if (null != o) { var s = i.get(o); null == s && (s = new Set, i.set(o, s)), s.add(t) } } }), new e(t, n, r, i) } }, { key: Nv, value: function (t, n) { for (var r = n.threeGLTF, i = n.gltf, a = JSON.parse(JSON.stringify(i)), o = new Map, s = new Map, l = 0; l < r.scenes.length; l++)this[Ov](r.scenes[l], t.scenes[l], function (e, t) { var r = n.threeObjectMap.get(e); if (null != r) { var i = r.type, l = r.index, c = a[i][l]; o.set(t, { type: i, index: l }); var u = s.get(c) || new Set; u.add(t), s.set(c, u) } }); return new e(t, a, o, s) } }, { key: Ov, value: function (e, t, n) { !function e(t, r) { if (n(t, r), t.isObject3D) { if (t.isMesh) if (Array.isArray(t.material)) for (var i = 0; i < t.material.length; ++i)e(t.material[i], r.material[i]); else e(t.material, r.material); for (var a = 0; a < t.children.length; ++a)e(t.children[a], r.children[a]) } }(e, t) } }]), e }(), Fv = (hm = new Nr, dm = new Ir, pm = new Nr, fm = new ci, mm = new ci, vm = new ci, am = new Nr, om = new Nr, sm = new Nr, lm = new Nr, cm = new Er, um = new Er, function (e) { var t = new Map, n = new Map, r = e.clone(); return function e(t, n, r) { r(t, n); for (var i = 0; i < t.children.length; i++)e(t.children[i], n.children[i], r) }(e, r, function (e, r) { t.set(r, e), n.set(e, r) }), r.traverse(function (e) { if (e.isSkinnedMesh) { var r = e, i = t.get(e), a = i.skeleton.bones; r.skeleton = i.skeleton.clone(), r.bindMatrix.copy(i.bindMatrix), r.skeleton.bones = a.map(function (e) { return n.get(e) }), r.bind(r.skeleton, r.bindMatrix) } }), r }); var Uv = Symbol("prepared"), zv = Symbol("prepare"), Bv = Symbol("preparedGLTF"), Hv = Symbol("clone"), Gv = function () { function e(t) { _classCallCheck(this, e), this[Bv] = t } return _createClass(e, [{ key: "clone", value: function () { return new (0, this.constructor)(this[Hv]()) } }, { key: "dispose", value: function () { this.scenes.forEach(function (e) { e.traverse(function (e) { if (e.isMesh) { var t = e; (Array.isArray(t.material) ? t.material : [t.material]).forEach(function (e) { e.dispose() }), t.geometry.dispose() } }) }) } }, { key: Hv, value: function () { var e = this[Bv], t = Fv(this.scene), n = [t], r = e.userData ? Object.assign({}, e.userData) : {}; return Object.assign(Object.assign({}, e), { scene: t, scenes: n, userData: r }) } }, { key: "parser", get: function () { return this[Bv].parser } }, { key: "animations", get: function () { return this[Bv].animations } }, { key: "scene", get: function () { return this[Bv].scene } }, { key: "scenes", get: function () { return this[Bv].scenes } }, { key: "cameras", get: function () { return this[Bv].cameras } }, { key: "asset", get: function () { return this[Bv].asset } }, { key: "userData", get: function () { return this[Bv].userData } }], [{ key: "prepare", value: function (e) { if (null == e.scene) throw new Error("Model does not have a scene"); if (e[Uv]) return e; var t = this[zv](e); return t[Uv] = !0, t } }, { key: zv, value: function (e) { var t = e.scene, n = [t]; return Object.assign(Object.assign({}, e), { scene: t, scenes: n }) } }]), e }(), Vv = "\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n    diffuseColor.a = 1.0;\n\n#endif\n", jv = Symbol("cloneAndPatchMaterial"), Wv = Symbol("correlatedSceneGraph"), qv = function (e) { _inherits(n, Gv); var t = _createSuper(n); function n() { return _classCallCheck(this, n), t.apply(this, arguments) } return _createClass(n, [{ key: Hv, value: function () { var e = this, t = _get(_getPrototypeOf(n.prototype), Hv, this).call(this), r = new Map; return t.scene.traverse(function (t) { if (t.isMesh) { var n = t; Array.isArray(n.material) ? n.material = n.material.map(function (t) { return e[jv](t, r) }) : null != n.material && (n.material = e[jv](n.material, r)) } }), t[Wv] = Dv.from(t, this.correlatedSceneGraph), t } }, { key: jv, value: function (e, t) { if (t.has(e.uuid)) return t.get(e.uuid); var n = e.clone(), r = e.onBeforeCompile; return n.onBeforeCompile = e.isGLTFSpecularGlossinessMaterial ? function (e) { r(e, void 0), e.fragmentShader = e.fragmentShader.replace("#include <alphatest_fragment>", Vv) } : function (e) { e.fragmentShader = e.fragmentShader.replace("#include <alphatest_fragment>", Vv), r(e, void 0) }, n.shadowSide = Fe, n.transparent && (n.depthWrite = !1), n.alphaTest || n.transparent || (n.alphaTest = -.5), t.set(e.uuid, n), n } }, { key: "correlatedSceneGraph", get: function () { return this[Bv][Wv] } }], [{ key: zv, value: function (e) { var t = _get(_getPrototypeOf(n), zv, this).call(this, e); null == t[Wv] && (t[Wv] = Dv.from(t)); var r = t.scene, i = []; r.traverse(function (e) { if (e.renderOrder = 1e3, e.frustumCulled = !1, e.name || (e.name = e.uuid), e.isMesh) { e.castShadow = !0; var t = e, n = !1; (Array.isArray(t.material) ? t.material : [t.material]).forEach(function (e) { e.isMeshStandardMaterial && (e.transparent && e.side === ze && (n = !0, e.side = Fe), lg.singleton.roughnessMipmapper.generateMipmaps(e)) }), n && i.push(t) } }); for (var a = 0, o = i; a < o.length; a++) { var s = o[a], l = (Array.isArray(s.material) ? s.material : [s.material]).map(function (e) { var t = e.clone(); return t.side = Ue, t }), c = Array.isArray(s.material) ? l : l[0], u = new qa(s.geometry, c); u.renderOrder = -1, s.add(u) } return t } }]), n }(), Xv = function (e) { Zu.call(this, e), this.type = Bt }; Xv.prototype = Object.assign(Object.create(Zu.prototype), { constructor: Xv, parse: function (e) { var t = function (e, t) { switch (e) { case 1: console.error("RGBELoader Read Error: " + (t || "")); break; case 2: console.error("RGBELoader Write Error: " + (t || "")); break; case 3: console.error("RGBELoader Bad File Format: " + (t || "")); break; default: case 4: console.error("RGBELoader: Error: " + (t || "")) }return -1 }, n = function (e, t, n) { t = t || 1024; for (var r = e.pos, i = -1, a = 0, o = "", s = String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128))); 0 > (i = s.indexOf("\n")) && a < t && r < e.byteLength;)o += s, a += s.length, r += 128, s += String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128))); return -1 < i && (!1 !== n && (e.pos += a + i + 1), o + s.slice(0, i)) }, r = function () { var e = new Float32Array(1), t = new Int32Array(e.buffer); function n(n) { e[0] = n; var r = t[0], i = r >> 16 & 32768, a = r >> 12 & 2047, o = r >> 23 & 255; return o < 103 ? i : o > 142 ? (i |= 31744, i |= (255 == o ? 0 : 1) && 8388607 & r) : o < 113 ? i |= ((a |= 2048) >> 114 - o) + (a >> 113 - o & 1) : (i |= o - 112 << 10 | a >> 1, i += 1 & a) } return function (e, t, r, i) { var a = e[t + 3], o = Math.pow(2, a - 128) / 255; r[i + 0] = n(e[t + 0] * o), r[i + 1] = n(e[t + 1] * o), r[i + 2] = n(e[t + 2] * o) } }(), i = new Uint8Array(e); i.pos = 0; var a, o, s, l, c, u, h = function (e) { var r, i, a = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, o = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, s = /^\s*FORMAT=(\S+)\s*$/, l = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, c = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 }; if (e.pos >= e.byteLength || !(r = n(e))) return t(1, "no header found"); if (!(i = r.match(/^#\?(\S+)$/))) return t(3, "bad initial token"); for (c.valid |= 1, c.programtype = i[1], c.string += r + "\n"; !1 !== (r = n(e));)if (c.string += r + "\n", "#" !== r.charAt(0)) { if ((i = r.match(a)) && (c.gamma = parseFloat(i[1], 10)), (i = r.match(o)) && (c.exposure = parseFloat(i[1], 10)), (i = r.match(s)) && (c.valid |= 2, c.format = i[1]), (i = r.match(l)) && (c.valid |= 4, c.height = parseInt(i[1], 10), c.width = parseInt(i[2], 10)), 2 & c.valid && 4 & c.valid) break } else c.comments += r + "\n"; return 2 & c.valid ? 4 & c.valid ? c : t(3, "missing image size specifier") : t(3, "missing format specifier") }(i); if (-1 !== h) { var d = h.width, p = h.height, f = function (e, n, r) { var i, a, o, s, l, c, u, h, d, p, f, m, v, g = n, y = r; if (g < 8 || g > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e); if (g !== (e[2] << 8 | e[3])) return t(3, "wrong scanline width"); if (!(i = new Uint8Array(4 * n * r)).length) return t(4, "unable to allocate buffer space"); for (a = 0, o = 0, h = 4 * g, v = new Uint8Array(4), c = new Uint8Array(h); y > 0 && o < e.byteLength;) { if (o + 4 > e.byteLength) return t(1); if (v[0] = e[o++], v[1] = e[o++], v[2] = e[o++], v[3] = e[o++], 2 != v[0] || 2 != v[1] || (v[2] << 8 | v[3]) != g) return t(3, "bad rgbe scanline format"); for (u = 0; u < h && o < e.byteLength;) { if ((m = (s = e[o++]) > 128) && (s -= 128), 0 === s || u + s > h) return t(3, "bad scanline data"); if (m) for (l = e[o++], d = 0; d < s; d++)c[u++] = l; else c.set(e.subarray(o, o + s), u), u += s, o += s } for (p = g, d = 0; d < p; d++)f = 0, i[a] = c[d + f], f += g, i[a + 1] = c[d + f], f += g, i[a + 2] = c[d + f], f += g, i[a + 3] = c[d + f], a += 4; y-- } return i }(i.subarray(i.pos), d, p); if (-1 !== f) { switch (this.type) { case Bt: var m = f, v = rn, g = Bt; break; case qt: for (var y = f.length / 4 * 3, b = new Float32Array(y), x = 0; x < y; x++)s = b, l = 3 * x, c = void 0, u = void 0, c = (a = f)[(o = 4 * x) + 3], u = Math.pow(2, c - 128) / 255, s[l + 0] = a[o + 0] * u, s[l + 1] = a[o + 1] * u, s[l + 2] = a[o + 2] * u; m = b, v = $t, g = qt; break; case Xt: y = f.length / 4 * 3; var _ = new Uint16Array(y); for (x = 0; x < y; x++)r(f, 4 * x, _, 3 * x); m = _, v = $t, g = Xt; break; default: console.error("THREE.RGBELoader: unsupported type: ", this.type) }return { width: d, height: p, data: m, header: h.string, gamma: h.gamma, exposure: h.exposure, format: v, type: g } } } return null }, setDataType: function (e) { return this.type = e, this }, load: function (e, t, n, r) { return Zu.prototype.load.call(this, e, function (e, n) { switch (e.type) { case Bt: e.encoding = sr, e.minFilter = It, e.magFilter = It, e.generateMipmaps = !1, e.flipY = !0; break; case qt: case Xt: e.encoding = ir, e.minFilter = Ft, e.magFilter = Ft, e.generateMipmaps = !1, e.flipY = !0 }t && t(e, n) }, n, r) } }); var Yv = function (e) { _inherits(n, Ml); var t = _createSuper(n); function n() { var e; _classCallCheck(this, n), (e = t.call(this)).position.y = -3.5; var r = new Ja; r.deleteAttribute("uv"); var i = new gu({ metalness: 0, side: Ue }), a = new gu({ metalness: 0 }), o = new Ah(16777215, 500, 28, 2); o.position.set(.418, 16.199, .3), e.add(o); var s = new qa(r, i); s.position.set(-.757, 13.219, .717), s.scale.set(31.713, 28.305, 28.591), e.add(s); var l = new qa(r, a); l.position.set(-10.906, 2.009, 1.846), l.rotation.set(0, -.195, 0), l.scale.set(2.328, 7.905, 4.651), e.add(l); var c = new qa(r, a); c.position.set(-5.607, -.754, -.758), c.rotation.set(0, .994, 0), c.scale.set(1.97, 1.534, 3.955), e.add(c); var u = new qa(r, a); u.position.set(6.167, .857, 7.803), u.rotation.set(0, .561, 0), u.scale.set(3.927, 6.285, 3.687), e.add(u); var h = new qa(r, a); h.position.set(-2.017, .018, 6.124), h.rotation.set(0, .333, 0), h.scale.set(2.002, 4.566, 2.064), e.add(h); var d = new qa(r, a); d.position.set(2.291, -.756, -2.621), d.rotation.set(0, -.286, 0), d.scale.set(1.546, 1.552, 1.496), e.add(d); var p = new qa(r, a); p.position.set(-2.193, -.369, -5.547), p.rotation.set(0, .516, 0), p.scale.set(3.875, 3.487, 2.986), e.add(p); var f = new qa(r, e.createAreaLightMaterial(50)); f.position.set(-16.116, 14.37, 8.208), f.scale.set(.1, 2.428, 2.739), e.add(f); var m = new qa(r, e.createAreaLightMaterial(50)); m.position.set(-16.109, 18.021, -8.207), m.scale.set(.1, 2.425, 2.751), e.add(m); var v = new qa(r, e.createAreaLightMaterial(17)); v.position.set(14.904, 12.198, -1.832), v.scale.set(.15, 4.265, 6.331), e.add(v); var g = new qa(r, e.createAreaLightMaterial(43)); g.position.set(-.462, 8.89, 14.52), g.scale.set(4.38, 5.441, .088), e.add(g); var y = new qa(r, e.createAreaLightMaterial(20)); y.position.set(3.235, 11.486, -12.541), y.scale.set(2.5, 2, .1), e.add(y); var b = new qa(r, e.createAreaLightMaterial(100)); return b.position.set(0, 20, 0), b.scale.set(1, .1, 1), e.add(b), e } return _createClass(n, [{ key: "createAreaLightMaterial", value: function (e) { var t = new oa; return t.color.setScalar(e), t } }]), n }(); Hu.enabled = !0; var Jv, Zv, Kv = /\.hdr(\.js)?$/, Qv = new Ku, $v = new Xv, eg = { url: null }, tg = function (e) { _inherits(n, xr); var t = _createSuper(n); function n(e) { var r; return _classCallCheck(this, n), (r = t.call(this)).generatedEnvironmentMap = null, r.skyboxCache = new Map, r.environmentMapCache = new Map, r.PMREMGenerator = new Vd(e), r } return _createClass(n, [{ key: "load", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { var n, r, i, a, o = arguments; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return n = o.length > 1 && void 0 !== o[1] ? o[1] : function () { }, e.prev = 1, r = Kv.test(t), i = r ? $v : Qv, e.next = 6, new Promise(function (e, r) { return i.load(t, e, function (e) { n(e.loaded / e.total * .9) }, r) }); case 6: return a = e.sent, n(1), this.addMetadata(a, t), a.mapping = At, r ? (a.encoding = sr, a.minFilter = It, a.magFilter = It, a.flipY = !0) : a.encoding = or, e.abrupt("return", a); case 12: return e.prev = 12, n && n(1), e.finish(12); case 15: case "end": return e.stop() } }, e, this, [[1, , 12, 15]]) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "generateEnvironmentMapAndSkybox", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e() { var t, n, r, i, a, o, s, l, c, u, h, d = arguments; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return t = d.length > 0 && void 0 !== d[0] ? d[0] : null, n = d.length > 1 && void 0 !== d[1] ? d[1] : null, r = d.length > 2 && void 0 !== d[2] ? d[2] : {}, i = r.progressTracker, a = null != i ? i.beginActivity() : function () { }, e.prev = 5, o = Promise.resolve(null), t && (o = this.loadSkyboxFromUrl(t, i)), s = n ? this.loadEnvironmentMapFromUrl(n, i) : t ? this.loadEnvironmentMapFromUrl(t, i) : this.loadGeneratedEnvironmentMap(), e.next = 11, Promise.all([s, o]); case 11: if (l = e.sent, c = _slicedToArray(l, 2), u = c[0], h = c[1], null != u) { e.next = 17; break } throw new Error("Failed to load environment map."); case 17: return e.abrupt("return", { environmentMap: u, skybox: h }); case 18: return e.prev = 18, a(1), e.finish(18); case 21: case "end": return e.stop() } }, e, this, [[5, , 18, 21]]) })); return function () { return e.apply(this, arguments) } }() }, { key: "addMetadata", value: function (e, t) { null != e && (e.userData = Object.assign(Object.assign({}, eg), { url: t })) } }, { key: "loadSkyboxFromUrl", value: function (e, t) { if (!this.skyboxCache.has(e)) { var n = t ? t.beginActivity() : function () { }, r = this.load(e, n); this.skyboxCache.set(e, r) } return this.skyboxCache.get(e) } }, { key: "loadEnvironmentMapFromUrl", value: function (e, t) { var n = this; if (!this.environmentMapCache.has(e)) { var r = this.loadSkyboxFromUrl(e, t).then(function (t) { var r = n.PMREMGenerator.fromEquirectangular(t); return n.addMetadata(r.texture, e), r }); this.PMREMGenerator.compileEquirectangularShader(), this.environmentMapCache.set(e, r) } return this.environmentMapCache.get(e) } }, { key: "loadGeneratedEnvironmentMap", value: function () { if (null == this.generatedEnvironmentMap) { var e = new Yv; this.generatedEnvironmentMap = this.PMREMGenerator.fromScene(e, .04), this.addMetadata(this.generatedEnvironmentMap.texture, null) } return Promise.resolve(this.generatedEnvironmentMap) } }, { key: "dispose", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e() { var t, n, r, i; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: t = [], this.environmentMapCache.forEach(function (e) { t.push(e) }), this.environmentMapCache.clear(), n = 0, r = t; case 4: if (!(n < r.length)) { e.next = 18; break } return i = r[n], e.prev = 6, e.next = 9, i; case 9: e.sent.dispose(), e.next = 15; break; case 13: e.prev = 13, e.t0 = e.catch(6); case 15: n++, e.next = 4; break; case 18: null != this.generatedEnvironmentMap && (this.generatedEnvironmentMap.dispose(), this.generatedEnvironmentMap = null); case 19: case "end": return e.stop() } }, e, this, [[6, 13]]) })); return function () { return e.apply(this, arguments) } }() }]), n }(), ng = 18, rg = 26, ig = .5, ag = Symbol("onWebGLContextLost"), og = Symbol("webGLContextLostHandler"), sg = Symbol("singleton"), lg = function (e) { _inherits(n, xr); var t = _createSuper(n); function n(e) { var r; _classCallCheck(this, n), (r = t.call(this)).loader = new yp(qv), r.width = 0, r.height = 0, r.dpr = 1, r.minScale = ig, r.debugger = null, r.scenes = new Set, r.multipleScenesVisible = !1, r.scale = 1, r.avgFrameDuration = (rg + ng) / 2, r[Zv] = function (e) { return r[ag](e) }, r.dpr = Mm(), r.canvasElement = document.createElement("canvas"), r.canvasElement.id = "webgl-canvas", r.canvas3D = r.canvasElement, r.canvas3D.addEventListener("webglcontextlost", r[og]); try { r.threeRenderer = new wl({ canvas: r.canvas3D, alpha: !0, antialias: !0, powerPreference: "high-performance", preserveDrawingBuffer: !0 }), r.threeRenderer.autoClear = !0, r.threeRenderer.outputEncoding = or, r.threeRenderer.gammaFactor = 2.2, r.threeRenderer.physicallyCorrectLights = !0, r.threeRenderer.setPixelRatio(1), r.threeRenderer.shadowMap.enabled = !0, r.threeRenderer.shadowMap.type = Ne, r.threeRenderer.shadowMap.autoUpdate = !1, r.debugger = null != e && e.debug ? new Rv(_assertThisInitialized(r)) : null, r.threeRenderer.debug = { checkShaderErrors: !!r.debugger }, r.threeRenderer.toneMapping = Mt } catch (e) { console.warn(e) } return r.arRenderer = new Av(_assertThisInitialized(r)), r.textureUtils = r.canRender ? new tg(r.threeRenderer) : null, r.roughnessMipmapper = new bf(r.threeRenderer), r.updateRendererSize(), r.lastTick = performance.now(), r.avgFrameDuration = 0, r } return _createClass(n, [{ key: "updateRendererSize", value: function () { var e = Mm(); if (e !== this.dpr) { var t, n = _createForOfIteratorHelper(this.scenes); try { for (n.s(); !(t = n.n()).done;) { var r = t.value.element; r[Gg](r.getBoundingClientRect()) } } catch (e) { n.e(e) } finally { n.f() } } var i, a = 0, o = 0, s = _createForOfIteratorHelper(this.scenes); try { for (s.s(); !(i = s.n()).done;) { var l = i.value; a = Math.max(a, l.width), o = Math.max(o, l.height) } } catch (e) { s.e(e) } finally { s.f() } if (a !== this.width || o !== this.height || e !== this.dpr) { this.width = a, this.height = o, this.dpr = e, this.canRender && this.threeRenderer.setSize(a * e, o * e, !1); var c = a / this.scale, u = o / this.scale; this.canvasElement.style.width = "".concat(c, "px"), this.canvasElement.style.height = "".concat(u, "px"); var h, d = _createForOfIteratorHelper(this.scenes); try { for (d.s(); !(h = d.n()).done;) { var p = h.value, f = p.canvas; f.width = Math.round(a * e), f.height = Math.round(o * e), f.style.width = "".concat(c, "px"), f.style.height = "".concat(u, "px"), p.isDirty = !0 } } catch (e) { d.e(e) } finally { d.f() } } } }, { key: "updateRendererScale", value: function () { var e = this.scale; if (this.avgFrameDuration > rg && e > this.minScale ? e *= .79 : this.avgFrameDuration < ng && e < 1 && (e /= .79, e = Math.min(e, 1)), (e = Math.max(e, this.minScale)) != this.scale) { this.scale = e, this.avgFrameDuration = (rg + ng) / 2; var t = this.width / e, n = this.height / e; this.canvasElement.style.width = "".concat(t, "px"), this.canvasElement.style.height = "".concat(n, "px"); var r, i = _createForOfIteratorHelper(this.scenes); try { for (i.s(); !(r = i.n()).done;) { var a = r.value, o = a.canvas.style; o.width = "".concat(t, "px"), o.height = "".concat(n, "px"), a.isDirty = !0 } } catch (e) { i.e(e) } finally { i.f() } } } }, { key: "registerScene", value: function (e) { var t = this; this.scenes.add(e); var n = e.canvas; n.width = Math.round(this.width * this.dpr), n.height = Math.round(this.height * this.dpr), n.style.width = "".concat(this.width / this.scale, "px"), n.style.height = "".concat(this.height / this.scale, "px"), this.multipleScenesVisible && n.classList.add("show"), e.isDirty = !0, this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop(function (e) { return t.render(e) }), null != this.debugger && this.debugger.addScene(e) } }, { key: "unregisterScene", value: function (e) { this.scenes.delete(e), this.canRender && 0 === this.scenes.size && this.threeRenderer.setAnimationLoop(null), null != this.debugger && this.debugger.removeScene(e) } }, { key: "displayCanvas", value: function (e) { return this.multipleScenesVisible ? e.element[Kg] : this.canvasElement } }, { key: "selectCanvas", value: function () { var e, t = 0, n = null, r = _createForOfIteratorHelper(this.scenes); try { for (r.s(); !(e = r.n()).done;) { var i = e.value.element; i.modelIsVisible && (++t, n = i[Zg]) } } catch (e) { r.e(e) } finally { r.f() } var a = t > 1 || !1, o = this.canvasElement; if (a !== this.multipleScenesVisible || !a && o.parentElement !== n) { this.multipleScenesVisible = a, a && o.classList.remove("show"); var s, l = _createForOfIteratorHelper(this.scenes); try { for (l.s(); !(s = l.n()).done;) { var c = s.value, u = c.element[Zg], h = c.element[Kg]; a ? (h.classList.add("show"), c.isDirty = !0) : u === n && (u.appendChild(o), o.classList.add("show"), h.classList.remove("show"), c.isDirty = !0) } } catch (e) { l.e(e) } finally { l.f() } } } }, { key: "orderedScenes", value: function () { for (var e = [], t = 0, n = [!1, !0]; t < n.length; t++) { var r, i = n[t], a = _createForOfIteratorHelper(this.scenes); try { for (a.s(); !(r = a.n()).done;) { var o = r.value; o.element.modelIsVisible === i && e.push(o) } } catch (e) { a.e(e) } finally { a.f() } } return e } }, { key: "preRender", value: function (e, t, n) { var r = e.element, i = e.exposure, a = e.model; r[ey](t, n); var o = "number" == typeof i && !self.isNaN(i); this.threeRenderer.toneMappingExposure = o ? i : 1, a.updateShadow() && (this.threeRenderer.shadowMap.needsUpdate = !0) } }, { key: "render", value: function (e) { var t = e - this.lastTick; if (this.lastTick = e, this.canRender && !this.isPresenting) { this.avgFrameDuration += wm(.2 * (t - this.avgFrameDuration), -2, 2), this.selectCanvas(), this.updateRendererSize(), this.updateRendererScale(); var n, r = this.dpr, i = this.scale, a = _createForOfIteratorHelper(this.orderedScenes()); try { for (a.s(); !(n = a.n()).done;) { var o = n.value; if (o.element[ly]() && (this.preRender(o, e, t), o.isDirty)) { if (o.isDirty = !1, !o.element.modelIsVisible && !this.multipleScenesVisible) { var s, l = _createForOfIteratorHelper(this.scenes); try { for (l.s(); !(s = l.n()).done;) { var c = s.value; c.element.modelIsVisible && (c.isDirty = !0) } } catch (e) { l.e(e) } finally { l.f() } } var u = Math.min(Math.ceil(o.width * i * r), this.canvas3D.width), h = Math.min(Math.ceil(o.height * i * r), this.canvas3D.height); if (this.threeRenderer.setRenderTarget(null), this.threeRenderer.setViewport(0, Math.floor(this.height * r) - h, u, h), this.threeRenderer.render(o, o.getCamera()), this.multipleScenesVisible) { null == o.context && o.createContext(); var d = o.context; d.clearRect(0, 0, u, h), d.drawImage(this.canvas3D, 0, 0, u, h, 0, 0, u, h) } } } } catch (e) { a.e(e) } finally { a.f() } } } }, { key: "dispose", value: function () { null != this.textureUtils && this.textureUtils.dispose(), null != this.threeRenderer && this.threeRenderer.dispose(), this.textureUtils = null, this.threeRenderer = null, this.scenes.clear(), this.canvas3D.removeEventListener("webglcontextlost", this[og]) } }, { key: (Jv = sg, Zv = og, ag), value: function (e) { this.dispatchEvent({ type: "contextlost", sourceEvent: e }) } }, { key: "canRender", get: function () { return null != this.threeRenderer } }, { key: "scaleFactor", get: function () { return this.scale } }, { key: "isPresenting", get: function () { return this.arRenderer.isPresenting } }], [{ key: "resetSingleton", value: function () { this[sg].dispose(), this[sg] = new n({ debug: Sm() }) } }, { key: "singleton", get: function () { return this[sg] } }]), n }(); lg[Jv] = new lg({ debug: Sm() }); var cg, ug, hg, dg, pg, fg, mg, vg, gg, yg, bg, xg, _g = function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.abrupt("return", new Promise(function (e, n) { var r = t.match(/data:(.*);/); if (!r) return n(new Error("".concat(t, " is not a valid data Url"))); for (var i = r[1], a = t.replace(/data:image\/\w+;base64,/, ""), o = atob(a), s = [], l = 0; l < o.length; l += 512) { for (var c = o.slice(l, l + 512), u = new Array(c.length), h = 0; h < c.length; h++)u[h] = c.charCodeAt(h); var d = new Uint8Array(u); s.push(d) } e(new Blob(s, { type: i })) })); case 1: case "end": return e.stop() } }, e) })); return function (t) { return e.apply(this, arguments) } }(), wg = Symbol("ongoingActivities"), Mg = Symbol("announceTotalProgress"), Sg = Symbol("eventDelegate"), Tg = function () { function e() { var t = this; _classCallCheck(this, e), this[cg] = document.createDocumentFragment(), this.addEventListener = function () { var e; return (e = t[Sg]).addEventListener.apply(e, arguments) }, this.removeEventListener = function () { var e; return (e = t[Sg]).removeEventListener.apply(e, arguments) }, this.dispatchEvent = function () { var e; return (e = t[Sg]).dispatchEvent.apply(e, arguments) }, this[ug] = new Set } return _createClass(e, [{ key: "beginActivity", value: function () { var e = this, t = { progress: 0 }; return this[wg].add(t), 1 === this.ongoingActivityCount && this[Mg](), function (n) { var r; return (r = Math.max(wm(n, 0, 1), t.progress)) !== t.progress && (t.progress = r, e[Mg]()), t.progress } } }, { key: (cg = Sg, ug = wg, Mg), value: function () { var e, t = 0, n = 0, r = 0, i = _createForOfIteratorHelper(this[wg]); try { for (i.s(); !(e = i.n()).done;) { var a = e.value.progress; t += a * (.5 / Math.pow(2, n++)), 1 === a && r++ } } catch (e) { i.e(e) } finally { i.f() } r === this.ongoingActivityCount && (t = 1, this[wg].clear()), this.dispatchEvent(new CustomEvent("progress", { detail: { totalProgress: t } })) } }, { key: "ongoingActivityCount", get: function () { return this[wg].size } }]), e }(), Eg = function (e, t, n, r) { var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r; "undefined" == typeof Reflect || _typeof(Reflect); for (var s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o); return a > 3 && o && Object.defineProperty(t, n, o), o }, Ag = 50, Rg = 0, kg = 300, Lg = 150, Cg = document.createElement("canvas"), Pg = null, Og = Symbol("template"), Ig = Symbol("fallbackResizeHandler"), Ng = Symbol("defaultAriaLabel"), Dg = Symbol("resizeObserver"), Fg = Symbol("intersectionObserver"), Ug = Symbol("clearModelTimeout"), zg = Symbol("onContextLost"), Bg = Symbol("contextLostHandler"), Hg = Symbol("loaded"), Gg = Symbol("updateSize"), Vg = Symbol("isElementInViewport"), jg = Symbol("announceModelVisibility"), Wg = Symbol("ariaLabel"), qg = Symbol("loadedTime"), Xg = Symbol("updateSource"), Yg = Symbol("markLoaded"), Jg = Symbol("container"), Zg = Symbol("input"), Kg = Symbol("canvas"), Qg = Symbol("scene"), $g = Symbol("needsRender"), ey = Symbol("tick"), ty = Symbol("onModelLoad"), ny = Symbol("onResize"), ry = Symbol("renderer"), iy = Symbol("progressTracker"), ay = Symbol("getLoaded"), oy = Symbol("getModelIsVisible"), sy = Symbol("shouldAttemptPreload"), ly = Symbol("sceneIsReady"), cy = Symbol("hasTransitioned"), uy = function (e) { return { x: e.x, y: e.y, z: e.z, toString: function () { return "".concat(this.x, "m ").concat(this.y, "m ").concat(this.z, "m") } } }, hy = function (e) { _inherits(n, ce); var t = _createSuper(n); function n() { var e; _classCallCheck(this, n), (e = t.call(this)).alt = null, e.src = null, e[hg] = !1, e[dg] = !1, e[pg] = 0, e[fg] = null, e[mg] = _m(function () { var t = e.getBoundingClientRect(); e[Gg](t) }, Ag), e[vg] = _m(function (t) { var n = e.modelIsVisible; n !== t && e.dispatchEvent(new CustomEvent("model-visibility", { detail: { visible: n } })) }, Rg), e[gg] = null, e[yg] = null, e[bg] = new Tg, e[xg] = function (t) { return e[zg](t) }; var r = e.constructor.template; window.ShadyCSS && window.ShadyCSS.styleElement(_assertThisInitialized(e), {}), e.attachShadow({ mode: "open" }); var i, a, o = e.shadowRoot; if (o.appendChild(r.content.cloneNode(!0)), e[Jg] = o.querySelector(".container"), e[Zg] = o.querySelector(".userInput"), e[Kg] = o.querySelector("canvas"), e[Ng] = e[Zg].getAttribute("aria-label"), e.isConnected) { var s = e.getBoundingClientRect(); i = s.width, a = s.height } else i = kg, a = Lg; return e[Qg] = new pf({ canvas: e[Kg], element: _assertThisInitialized(e), width: i, height: a }), e[Qg].addEventListener("model-load", function (t) { e[Yg](), e[ty](), e.dispatchEvent(new CustomEvent("load", { detail: { url: t.url } })) }), Promise.resolve().then(function () { e[Gg](e.getBoundingClientRect()) }), ye && (e[Dg] = new ResizeObserver(function (t) { if (!e[ry].isPresenting) { var n, r = _createForOfIteratorHelper(t); try { for (r.s(); !(n = r.n()).done;) { var i = n.value; i.target === _assertThisInitialized(e) && e[Gg](i.contentRect) } } catch (e) { r.e(e) } finally { r.f() } } })), be ? e[Fg] = new IntersectionObserver(function (t) { var n, r = _createForOfIteratorHelper(t); try { for (r.s(); !(n = r.n()).done;) { var i = n.value; if (i.target === _assertThisInitialized(e)) { var a = e.modelIsVisible; e[Vg] = i.isIntersecting, e[jg](a), e[Vg] && !e[ly]() && e[Xg]() } } } catch (e) { r.e(e) } finally { r.f() } }, { root: null, rootMargin: "0px", threshold: 0 }) : e[Vg] = !0, e } return _createClass(n, [{ key: "connectedCallback", value: function () { _get(_getPrototypeOf(n.prototype), "connectedCallback", this) && _get(_getPrototypeOf(n.prototype), "connectedCallback", this).call(this), ye ? this[Dg].observe(this) : self.addEventListener("resize", this[Ig]), be && this[Fg].observe(this); var e = this[ry]; e.addEventListener("contextlost", this[Bg]), e.registerScene(this[Qg]), null != this[Ug] && (self.clearTimeout(this[Ug]), this[Ug] = null, this.requestUpdate("src", null)) } }, { key: "disconnectedCallback", value: function () { var e = this; _get(_getPrototypeOf(n.prototype), "disconnectedCallback", this) && _get(_getPrototypeOf(n.prototype), "disconnectedCallback", this).call(this), ye ? this[Dg].unobserve(this) : self.removeEventListener("resize", this[Ig]), be && this[Fg].unobserve(this); var t = this[ry]; t.removeEventListener("contextlost", this[Bg]), t.unregisterScene(this[Qg]), this[Ug] = self.setTimeout(function () { e[Qg].model.clear() }, 1e3) } }, { key: "updated", value: function (e) { if (_get(_getPrototypeOf(n.prototype), "updated", this).call(this, e), !e.has("src") || null != this.src && this.src === this[Qg].model.url || (this[Hg] = !1, this[qg] = 0, this[Xg]()), e.has("alt")) { var t = null == this.alt ? this[Ng] : this.alt; this[Zg].setAttribute("aria-label", t) } } }, { key: "toDataURL", value: function (e, t) { return this[ry].displayCanvas(this[Qg]).toDataURL(e, t) } }, { key: "toBlob", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { var n, r, i, a, o, s, l, c, u, h, d, p, f, m, v, g, y, b = this; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return n = t ? t.mimeType : void 0, r = t ? t.qualityArgument : void 0, i = t ? t.idealAspect : void 0, a = this[Qg], o = a.width, s = a.height, l = a.model, c = a.aspect, u = this[ry], h = u.dpr, d = u.scaleFactor, p = o * d * h, f = s * d * h, m = 0, v = 0, !0 === i && (l.fieldOfViewAspect > c ? (g = f, f = Math.round(p / l.fieldOfViewAspect), v = (g - f) / 2) : (y = p, p = Math.round(f * l.fieldOfViewAspect), m = (y - p) / 2)), Cg.width = p, Cg.height = f, e.prev = 12, e.abrupt("return", new Promise(function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t, i) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (null == Pg && (Pg = Cg.getContext("2d")), Pg.drawImage(b[ry].displayCanvas(b[Qg]), m, v, p, f, 0, 0, p, f), !Cg.msToBlob) { e.next = 5; break } if (n && "image/png" !== n) { e.next = 5; break } return e.abrupt("return", t(Cg.msToBlob())); case 5: if (Cg.toBlob) { e.next = 11; break } return e.t0 = t, e.next = 9, _g(Cg.toDataURL(n, r)); case 9: return e.t1 = e.sent, e.abrupt("return", (0, e.t0)(e.t1)); case 11: Cg.toBlob(function (e) { if (!e) return i(new Error("Unable to retrieve canvas blob")); t(e) }, n, r); case 12: case "end": return e.stop() } }, e) })); return function (t, n) { return e.apply(this, arguments) } }())); case 14: return e.prev = 14, this[Gg]({ width: o, height: s }), e.finish(14); case 17: case "end": return e.stop() } }, e, this, [[12, , 14, 17]]) })); return function (t) { return e.apply(this, arguments) } }() }, { key: ay, value: function () { return this[Hg] } }, { key: oy, value: function () { return this.loaded && this[Vg] } }, { key: cy, value: function () { return this.modelIsVisible } }, { key: sy, value: function () { return !!this.src && this[Vg] } }, { key: ly, value: function () { return this[Hg] } }, { key: Gg, value: function (e) { var t = e.width, n = e.height; this[Jg].style.width = "".concat(t, "px"), this[Jg].style.height = "".concat(n, "px"), this[ny]({ width: parseFloat(t), height: parseFloat(n) }) } }, { key: ey, value: function (e, t) { } }, { key: Yg, value: function () { this[Hg] || (this[Hg] = !0, this[qg] = performance.now()) } }, { key: $g, value: function () { this[Qg].isDirty = !0 } }, { key: ty, value: function () { } }, { key: ny, value: function (e) { this[Qg].setSize(e.width, e.height) } }, { key: zg, value: function (e) { this.dispatchEvent(new CustomEvent("error", { detail: { type: "webglcontextlost", sourceError: e.sourceEvent } })) } }, { key: Xg, value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e() { var t, n, r; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (!this.loaded && this[sy]()) { e.next = 2; break } return e.abrupt("return"); case 2: return t = this[iy].beginActivity(), n = this.src, e.prev = 4, e.next = 7, this[Qg].setModelSource(n, function (e) { return t(.8 * e) }); case 7: r = { url: n }, this.dispatchEvent(new CustomEvent("preload", { detail: r })), e.next = 14; break; case 11: e.prev = 11, e.t0 = e.catch(4), this.dispatchEvent(new CustomEvent("error", { detail: e.t0 })); case 14: return e.prev = 14, t(.9), requestAnimationFrame(function () { requestAnimationFrame(function () { t(1) }) }), e.finish(14); case 18: case "end": return e.stop() } }, e, this, [[4, 11, 14, 18]]) })); return function () { return e.apply(this, arguments) } }() }, { key: "loaded", get: function () { return this[ay]() } }, { key: (hg = Vg, dg = Hg, pg = qg, fg = Ug, mg = Ig, vg = jg, gg = Dg, yg = Fg, bg = iy, xg = Bg, ry), get: function () { return lg.singleton } }, { key: "modelIsVisible", get: function () { return this[oy]() } }, { key: Wg, get: function () { return null == this.alt || "null" === this.alt ? this[Ng] : this.alt } }], [{ key: "is", get: function () { return "model-viewer" } }, { key: "template", get: function () { var e, t; return this.hasOwnProperty(Og) || (this[Og] = (e = this.is, (t = document.createElement("template")).innerHTML = Le.innerHTML, window.ShadyCSS && window.ShadyCSS.prepareTemplate(t, e), t)), this[Og] } }, { key: "modelCacheSize", set: function (e) { yp[vp].evictionThreshold = e }, get: function () { return yp[vp].evictionThreshold } }, { key: "minimumRenderScale", set: function (e) { e > 1 && console.warn("<model-viewer> minimumRenderScale has been clamped to a maximum value of 1."), e <= 0 && console.warn("<model-viewer> minimumRenderScale has been clamped to a minimum value of 0. This could result in single-pixel renders on some devices; consider increasing."), lg.singleton.minScale = Math.max(0, Math.min(1, e)) }, get: function () { return lg.singleton.minScale } }]), n }(); Eg([de({ type: String })], hy.prototype, "alt", void 0), Eg([de({ type: String })], hy.prototype, "src", void 0); var dy, py, fy, my = function (e, t, n, r) { var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r; "undefined" == typeof Reflect || _typeof(Reflect); for (var s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o); return a > 3 && o && Object.defineProperty(t, n, o), o }, vy = Symbol("changeAnimation"), gy = Symbol("paused"), yy = Symbol("annotationRenderer"), by = Symbol("hotspotMap"), xy = Symbol("mutationCallback"), _y = Symbol("observer"), wy = Symbol("addHotspot"), My = Symbol("removeHotspot"), Sy = new Er, Ty = new ci, Ey = new Ar, Ay = function (e) { return function (t) { try { var n, r = Dp(t), i = (r.length ? r[0].terms : []).filter(function (e) { return e && "ident" === e.type }).map(function (e) { return e.value }).filter(function (t) { return e.indexOf(t) > -1 }), a = new Set, o = _createForOfIteratorHelper(i); try { for (o.s(); !(n = o.n()).done;) { var s = n.value; a.add(s) } } catch (e) { o.e(e) } finally { o.f() } return a } catch (e) { } return new Set } }, Ry = function (e, t, n, r) { var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r; "undefined" == typeof Reflect || _typeof(Reflect); for (var s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o); return a > 3 && o && Object.defineProperty(t, n, o), o }, ky = !1, Ly = !1, Cy = Ay(["safari", "chrome"]), Py = Ay(["quick-look", "scene-viewer", "webxr", "none"]), Oy = "webxr scene-viewer quick-look", Iy = { QUICK_LOOK: "quick-look", SCENE_VIEWER: "scene-viewer", WEBXR: "webxr", NONE: "none" }, Ny = Symbol("arButtonContainer"), Dy = Symbol("enterARWithWebXR"), Fy = Symbol("openSceneViewer"), Uy = Symbol("openIOSARQuickLook"), zy = Symbol("canActivateAR"), By = Symbol("arMode"), Hy = Symbol("arModes"), Gy = Symbol("canLaunchQuickLook"), Vy = Symbol("quickLookBrowsers"), jy = Symbol("arAnchor"), Wy = Symbol("preload"), qy = Symbol("onARButtonContainerClick"), Xy = Symbol("onARStatus"), Yy = Symbol("onARTap"), Jy = Symbol("selectARMode"), Zy = Symbol("evaluate"), Ky = Symbol("lastValue"), Qy = function () { function e() { _classCallCheck(this, e), this[dy] = null } return _createClass(e, [{ key: "evaluate", value: function () { return this.isConstant && null != this[Ky] || (this[Ky] = this[Zy]()), this[Ky] } }, { key: "isConstant", get: function () { return !1 } }], [{ key: "evaluatableFor", value: function (t) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : jp; if (_instanceof(t, e)) return t; if ("number" === t.type) return "%" === t.unit ? new ab(t, n) : t; switch (t.name.value) { case "calc": return new ub(t, n); case "env": return new sb(t) }return jp } }, { key: "evaluate", value: function (t) { return _instanceof(t, e) ? t.evaluate() : t } }, { key: "isConstant", value: function (t) { return !_instanceof(t, e) || t.isConstant } }, { key: "applyIntrinsics", value: function (e, t) { var n = t.basis, r = t.keywords, i = r.auto; return n.map(function (t, n) { var a = null == i[n] ? t : i[n], o = e[n] ? e[n] : a; if ("ident" === o.type) { var s = o.value; s in r && (o = r[s][n]) } return null != o && "ident" !== o.type || (o = a), "%" === o.unit ? Np(o.number / 100 * t.number, t.unit) : (o = Xp(o, t)).unit !== t.unit ? t : o }) } }]), e }(); dy = Ky; var $y, eb, tb, nb, rb = Symbol("percentage"), ib = Symbol("basis"), ab = function (e) { _inherits(n, Qy); var t = _createSuper(n); function n(e, r) { var i; return _classCallCheck(this, n), (i = t.call(this))[rb] = e, i[ib] = r, i } return _createClass(n, [{ key: Zy, value: function () { return Np(this[rb].number / 100 * this[ib].number, this[ib].unit) } }, { key: "isConstant", get: function () { return !0 } }]), n }(), ob = Symbol("identNode"), sb = function (e) { _inherits(n, Qy); var t = _createSuper(n); function n(e) { var r; _classCallCheck(this, n), (r = t.call(this))[py] = null; var i = e.arguments.length ? e.arguments[0].terms[0] : null; return null != i && "ident" === i.type && (r[ob] = i), r } return _createClass(n, [{ key: (py = ob, Zy), value: function () { if (null != this[ob]) switch (this[ob].value) { case "window-scroll-y": return { type: "number", number: window.pageYOffset / (Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) - window.innerHeight) || 0, unit: null } }return jp } }, { key: "isConstant", get: function () { return !1 } }]), n }(), lb = /[\*\/]/, cb = Symbol("evalutor"), ub = function (e) { _inherits(n, Qy); var t = _createSuper(n); function n(e) { var r, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : jp; if (_classCallCheck(this, n), (r = t.call(this))[fy] = null, 1 !== e.arguments.length) return _possibleConstructorReturn(r); for (var a = e.arguments[0].terms.slice(), o = []; a.length;) { var s = a.shift(); if (o.length > 0) { var l = o[o.length - 1]; if ("operator" === l.type && lb.test(l.value)) { var c = o.pop(), u = o.pop(); if (null == u) return _possibleConstructorReturn(r); o.push(new fb(c, Qy.evaluatableFor(u, i), Qy.evaluatableFor(s, i))); continue } } o.push("operator" === s.type ? s : Qy.evaluatableFor(s, i)) } for (; o.length > 2;) { var h = _slicedToArray(o.splice(0, 3), 3), d = h[0], p = h[1], f = h[2]; if ("operator" !== p.type) return _possibleConstructorReturn(r); o.unshift(new fb(p, Qy.evaluatableFor(d, i), Qy.evaluatableFor(f, i))) } return 1 === o.length && (r[cb] = o[0]), r } return _createClass(n, [{ key: (fy = cb, Zy), value: function () { return null != this[cb] ? Qy.evaluate(this[cb]) : jp } }, { key: "isConstant", get: function () { return null == this[cb] || Qy.isConstant(this[cb]) } }]), n }(), hb = Symbol("operator"), db = Symbol("left"), pb = Symbol("right"), fb = function (e) { _inherits(n, Qy); var t = _createSuper(n); function n(e, r, i) { var a; return _classCallCheck(this, n), (a = t.call(this))[hb] = e, a[db] = r, a[pb] = i, a } return _createClass(n, [{ key: Zy, value: function () { var e = Xp(Qy.evaluate(this[db])), t = Xp(Qy.evaluate(this[pb])), n = e.number, r = e.unit, i = t.number, a = t.unit; if (null != a && null != r && a != r) return jp; var o, s = r || a; switch (this[hb].value) { case "+": o = n + i; break; case "-": o = n - i; break; case "/": o = n / i; break; case "*": o = n * i; break; default: return jp }return { type: "number", number: o, unit: s } } }, { key: "isConstant", get: function () { return Qy.isConstant(this[db]) && Qy.isConstant(this[pb]) } }]), n }(), mb = Symbol("evaluatables"), vb = Symbol("intrinsics"), gb = function (e) { _inherits(n, Qy); var t = _createSuper(n); function n(e, r) { var i; _classCallCheck(this, n), (i = t.call(this))[vb] = r; var a = e[0], o = null != a ? a.terms : []; return i[mb] = r.basis.map(function (e, t) { var n = o[t]; return null == n ? { type: "ident", value: "auto" } : "ident" === n.type ? n : Qy.evaluatableFor(n, e) }), i } return _createClass(n, [{ key: Zy, value: function () { var e = this[mb].map(function (e) { return Qy.evaluate(e) }); return Qy.applyIntrinsics(e, this[vb]).map(function (e) { return e.number }) } }, { key: "isConstant", get: function () { var e, t = _createForOfIteratorHelper(this[mb]); try { for (t.s(); !(e = t.n()).done;) { var n = e.value; if (!Qy.isConstant(n)) return !1 } } catch (e) { t.e(e) } finally { t.f() } return !0 } }]), n }(), yb = Symbol("instances"), bb = Symbol("activateListener"), xb = Symbol("deactivateListener"), _b = Symbol("notifyInstances"), wb = Symbol("notify"), Mb = Symbol("callback"), Sb = function () { function e(t) { _classCallCheck(this, e), this[Mb] = t } return _createClass(e, [{ key: "observe", value: function () { 0 === e[yb].size && e[bb](), e[yb].add(this) } }, { key: "disconnect", value: function () { e[yb].delete(this), 0 === e[yb].size && e[xb]() } }, { key: wb, value: function () { this[Mb]() } }], [{ key: _b, value: function () { var t, n = _createForOfIteratorHelper(e[yb]); try { for (n.s(); !(t = n.n()).done;) { t.value[wb]() } } catch (e) { n.e(e) } finally { n.f() } } }, { key: ($y = yb, bb), value: function () { window.addEventListener("scroll", this[_b], { passive: !0 }) } }, { key: xb, value: function () { window.removeEventListener("scroll", this[_b]) } }]), e }(); Sb[$y] = new Set; var Tb, Eb, Ab, Rb, kb, Lb = Symbol("computeStyleCallback"), Cb = Symbol("astWalker"), Pb = Symbol("dependencies"), Ob = Symbol("scrollHandler"), Ib = Symbol("onScroll"), Nb = function () { function e(t) { var n = this; _classCallCheck(this, e), this[eb] = {}, this[tb] = new Vp(["function"]), this[nb] = function () { return n[Ib]() }, this[Lb] = t } return _createClass(e, [{ key: "observeEffectsFor", value: function (e) { var t = this, n = {}, r = this[Pb]; for (var i in this[Cb].walk(e, function (e) { var i = e.name, a = e.arguments[0].terms[0]; if ("env" === i.value && null != a && "ident" === a.type) switch (a.value) { case "window-scroll-y": if (null == n["window-scroll"]) { var o = "window-scroll" in r ? r["window-scroll"] : new Sb(t[Ob]); o.observe(), delete r["window-scroll"], n["window-scroll"] = o } } }), r) { r[i].disconnect() } this[Pb] = n } }, { key: "dispose", value: function () { for (var e in this[Pb]) { this[Pb][e].disconnect() } } }, { key: (eb = Pb, tb = Cb, nb = Ob, Ib), value: function () { this[Lb]({ relatedState: "window-scroll" }) } }]), e }(), Db = function (e) { var t = e.observeEffects || !1, n = _instanceof(e.intrinsics, Function) ? e.intrinsics : function () { return e.intrinsics }; return function (r, i) { var a, o = r.updated, s = r.connectedCallback, l = r.disconnectedCallback, c = Symbol("".concat(i, "StyleEffector")), u = Symbol("".concat(i, "StyleEvaluator")), h = Symbol("".concat(i, "UpdateEvaluator")), d = Symbol("".concat(i, "EvaluateAndSync")); Object.defineProperties(r, (_defineProperty(a = {}, c, { value: null, writable: !0 }), _defineProperty(a, u, { value: null, writable: !0 }), _defineProperty(a, h, { value: function () { var e = this, r = Dp(this[i]); this[u] = new gb(r, n(this)), null == this[c] && t && (this[c] = new Nb(function () { return e[d]() })), null != this[c] && this[c].observeEffectsFor(r) } }), _defineProperty(a, d, { value: function () { if (null != this[u]) { var t = this[u].evaluate(); this[e.updateHandler](t) } } }), _defineProperty(a, "updated", { value: function (e) { e.has(i) && (this[h](), this[d]()), o.call(this, e) } }), _defineProperty(a, "connectedCallback", { value: function () { s.call(this), this.requestUpdate(i, this[i]) } }), _defineProperty(a, "disconnectedCallback", { value: function () { l.call(this), null != this[c] && (this[c].dispose(), this[c] = null) } }), a)) } }, Fb = Object.freeze({ minimumRadius: 0, maximumRadius: 1 / 0, minimumPolarAngle: Math.PI / 8, maximumPolarAngle: Math.PI - Math.PI / 8, minimumAzimuthalAngle: -1 / 0, maximumAzimuthalAngle: 1 / 0, minimumFieldOfView: 10, maximumFieldOfView: 45, interactionPolicy: "always-allow", touchAction: "pan-y" }), Ub = /^touch(start|end|move)$/, zb = Math.PI / 8, Bb = .04, Hb = { PAGE_UP: 33, PAGE_DOWN: 34, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40 }, Gb = "user-interaction", Vb = "none", jb = function (e) { _inherits(n, xr); var t = _createSuper(n); function n(e, r) { var i; return _classCallCheck(this, n), (i = t.call(this)).camera = e, i.element = r, i.sensitivity = 1, i._interactionEnabled = !1, i.isUserChange = !1, i.isUserPointing = !1, i.spherical = new bd, i.goalSpherical = new bd, i.thetaDamper = new xp, i.phiDamper = new xp, i.radiusDamper = new xp, i.logFov = Math.log(Fb.maximumFieldOfView), i.goalLogFov = i.logFov, i.fovDamper = new xp, i.pointerIsDown = !1, i.lastPointerPosition = { clientX: 0, clientY: 0 }, i.touchMode = "rotate", i.touchDecided = !1, i.onPointerMove = function (e) { if (i.pointerIsDown && i.canInteract) { if (Ub.test(e.type)) { var t = e.touches; switch (i.touchMode) { case "zoom": if (i.lastTouches.length > 1 && t.length > 1) { var n = i.twoTouchDistance(i.lastTouches[0], i.lastTouches[1]), r = i.twoTouchDistance(t[0], t[1]), a = Bb * (n - r) / 10; i.userAdjustOrbit(0, 0, a) } break; case "rotate": var o = i._options.touchAction; if (!i.touchDecided && "none" !== o) { i.touchDecided = !0; var s = t[0], l = s.clientX, c = s.clientY, u = Math.abs(l - i.lastPointerPosition.clientX), h = Math.abs(c - i.lastPointerPosition.clientY); if ("pan-y" === o && h > u && document.body.scrollHeight > window.innerHeight || "pan-x" === o && u > h) return void (i.touchMode = "scroll") } i.handleSinglePointerMove(t[0]); break; case "scroll": return }i.lastTouches = t } else i.handleSinglePointerMove(e); e.cancelable && e.preventDefault() } }, i.onPointerDown = function (e) { if (i.pointerIsDown = !0, i.isUserPointing = !1, Ub.test(e.type)) { var t = e.touches; switch (i.touchDecided = !1, t.length) { default: case 1: i.touchMode = "rotate", i.handleSinglePointerDown(t[0]); break; case 2: i.touchMode = "zoom" }i.lastTouches = t } else i.handleSinglePointerDown(e) }, i.onPointerUp = function (e) { i.element.style.cursor = "grab", i.pointerIsDown = !1, i.isUserPointing && i.dispatchEvent({ type: "pointer-change-end", pointer: Object.assign({}, i.lastPointerPosition) }) }, i.onWheel = function (e) { if (i.canInteract) { var t = e.deltaY * (1 == e.deltaMode ? 18 : 1) * Bb / 30; i.userAdjustOrbit(0, 0, t), e.cancelable && e.preventDefault() } }, i.onKeyDown = function (e) { var t = !1; switch (e.keyCode) { case Hb.PAGE_UP: t = !0, i.userAdjustOrbit(0, 0, Bb); break; case Hb.PAGE_DOWN: t = !0, i.userAdjustOrbit(0, 0, -1 * Bb); break; case Hb.UP: t = !0, i.userAdjustOrbit(0, -zb, 0); break; case Hb.DOWN: t = !0, i.userAdjustOrbit(0, zb, 0); break; case Hb.LEFT: t = !0, i.userAdjustOrbit(-zb, 0, 0); break; case Hb.RIGHT: t = !0, i.userAdjustOrbit(zb, 0, 0) }t && e.cancelable && e.preventDefault() }, i._options = Object.assign({}, Fb), i.setOrbit(0, Math.PI / 2, 1), i.setFieldOfView(100), i.jumpToGoal(), i } return _createClass(n, [{ key: "enableInteraction", value: function () { if (!1 === this._interactionEnabled) { var e = this.element; e.addEventListener("mousemove", this.onPointerMove), e.addEventListener("mousedown", this.onPointerDown), e.addEventListener("wheel", this.onWheel), e.addEventListener("keydown", this.onKeyDown), e.addEventListener("touchstart", this.onPointerDown, { passive: !0 }), e.addEventListener("touchmove", this.onPointerMove), self.addEventListener("mouseup", this.onPointerUp), self.addEventListener("touchend", this.onPointerUp), this.element.style.cursor = "grab", this._interactionEnabled = !0 } } }, { key: "disableInteraction", value: function () { if (!0 === this._interactionEnabled) { var e = this.element; e.removeEventListener("mousemove", this.onPointerMove), e.removeEventListener("mousedown", this.onPointerDown), e.removeEventListener("wheel", this.onWheel), e.removeEventListener("keydown", this.onKeyDown), e.removeEventListener("touchstart", this.onPointerDown), e.removeEventListener("touchmove", this.onPointerMove), self.removeEventListener("mouseup", this.onPointerUp), self.removeEventListener("touchend", this.onPointerUp), e.style.cursor = "", this._interactionEnabled = !1 } } }, { key: "getCameraSpherical", value: function () { return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new bd).copy(this.spherical) } }, { key: "getFieldOfView", value: function () { return this.camera.fov } }, { key: "applyOptions", value: function (e) { Object.assign(this._options, e), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov)) } }, { key: "updateNearFar", value: function (e, t) { this.camera.near = Math.max(e, t / 1e3), this.camera.far = t, this.camera.updateProjectionMatrix() } }, { key: "updateAspect", value: function (e) { this.camera.aspect = e, this.camera.updateProjectionMatrix() } }, { key: "setOrbit", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.goalSpherical.theta, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.goalSpherical.phi, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.goalSpherical.radius, r = this._options, i = r.minimumAzimuthalAngle, a = r.maximumAzimuthalAngle, o = r.minimumPolarAngle, s = r.maximumPolarAngle, l = r.minimumRadius, c = r.maximumRadius, u = this.goalSpherical, h = u.theta, d = u.phi, p = u.radius, f = wm(e, i, a); isFinite(i) || isFinite(a) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - f) + f); var m = wm(t, o, s), v = wm(n, l, c); return (f !== h || m !== d || v !== p) && (this.goalSpherical.theta = f, this.goalSpherical.phi = m, this.goalSpherical.radius = v, this.goalSpherical.makeSafe(), this.isUserChange = !1, !0) } }, { key: "setRadius", value: function (e) { this.goalSpherical.radius = e, this.setOrbit() } }, { key: "setFieldOfView", value: function (e) { var t = this._options, n = t.minimumFieldOfView, r = t.maximumFieldOfView; e = wm(e, n, r), this.goalLogFov = Math.log(e) } }, { key: "adjustOrbit", value: function (e, t, n) { var r = this.goalSpherical, i = r.theta, a = r.phi, o = r.radius, s = this._options, l = s.minimumRadius, c = s.maximumRadius, u = s.minimumFieldOfView, h = s.maximumFieldOfView, d = this.spherical.theta - i, p = Math.PI - .001, f = i - wm(e, -p - d, p - d), m = a - t, v = 0 === n ? 0 : n > 0 ? (c - o) / (Math.log(h) - this.goalLogFov) : (o - l) / (this.goalLogFov - Math.log(u)), g = o + n * Math.min(isFinite(v) ? v : 1 / 0, c - l); if (this.setOrbit(f, m, g), 0 !== n) { var y = this.goalLogFov + n; this.setFieldOfView(Math.exp(y)) } } }, { key: "jumpToGoal", value: function () { this.update(0, 1e4) } }, { key: "update", value: function (e, t) { if (!this.isStationary()) { var n = this._options, r = n.maximumPolarAngle, i = n.maximumRadius, a = this.spherical.theta - this.goalSpherical.theta; Math.abs(a) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle) && (this.spherical.theta -= 2 * Math.sign(a) * Math.PI), this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, t, Math.PI), this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, t, r), this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, t, i), this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, t, 1), this.moveCamera() } } }, { key: "isStationary", value: function () { return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov } }, { key: "moveCamera", value: function () { this.spherical.makeSafe(), this.camera.position.setFromSpherical(this.spherical), this.camera.setRotationFromEuler(new gi(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, "YXZ")), this.camera.fov !== Math.exp(this.logFov) && (this.camera.fov = Math.exp(this.logFov), this.camera.updateProjectionMatrix()); var e = this.isUserChange ? Gb : Vb; this.dispatchEvent({ type: "change", source: e }) } }, { key: "userAdjustOrbit", value: function (e, t, n) { this.adjustOrbit(e * this.sensitivity, t * this.sensitivity, n), this.isUserChange = !0, this.dispatchEvent({ type: "change", source: Gb }) } }, { key: "wrapAngle", value: function (e) { var t = (e + Math.PI) / (2 * Math.PI); return 2 * (t - Math.floor(t)) * Math.PI - Math.PI } }, { key: "pixelLengthToSphericalAngle", value: function (e) { return 2 * Math.PI * e / this.element.clientHeight } }, { key: "twoTouchDistance", value: function (e, t) { var n = e.clientX, r = e.clientY, i = t.clientX - n, a = t.clientY - r; return Math.sqrt(i * i + a * a) } }, { key: "handleSinglePointerMove", value: function (e) { var t = e.clientX, n = e.clientY, r = this.pixelLengthToSphericalAngle(t - this.lastPointerPosition.clientX), i = this.pixelLengthToSphericalAngle(n - this.lastPointerPosition.clientY); this.lastPointerPosition.clientX = t, this.lastPointerPosition.clientY = n, !1 === this.isUserPointing && (this.isUserPointing = !0, this.dispatchEvent({ type: "pointer-change-start", pointer: Object.assign({}, e) })), this.userAdjustOrbit(r, i, 0) } }, { key: "handleSinglePointerDown", value: function (e) { this.lastPointerPosition.clientX = e.clientX, this.lastPointerPosition.clientY = e.clientY, this.element.style.cursor = "grabbing" } }, { key: "interactionEnabled", get: function () { return this._interactionEnabled } }, { key: "options", get: function () { return this._options } }, { key: "canInteract", get: function () { return "allow-when-focused" == this._options.interactionPolicy ? this.element.getRootNode().activeElement === this.element : "always-allow" === this._options.interactionPolicy } }]), n }(), Wb = function (e) { return e < .5 ? 2 * e * e : (4 - 2 * e) * e - 1 }, qb = function (e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Wb; return function (r) { return e + (t - e) * n(r) } }, Xb = function (e, t) { for (var n = [], r = [], i = e, a = 0; a < t.length; ++a) { var o = t[a], s = o.value, l = o.frames, c = o.ease || Wb, u = qb(i, s, c); n.push(u), r.push(l), i = s } return function (e, t) { var n = t.reduce(function (e, t) { return e + t }, 0), r = t.map(function (e) { return e / n }); return function (t) { for (var n = 0, i = 1 / 0, a = function () { return 0 }, o = 0; o < r.length && (i = r[o], a = e[o], !(t <= n + i)); ++o)n += i; return a((t - n) / i) } }(n, r) }, Yb = function (e, t, n, r) { var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r; "undefined" == typeof Reflect || _typeof(Reflect); for (var s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o); return a > 3 && o && Object.defineProperty(t, n, o), o }, Jb = Xb(0, [{ frames: 5, value: -1 }, { frames: 1, value: -1 }, { frames: 8, value: 1 }, { frames: 1, value: 1 }, { frames: 5, value: 0 }, { frames: 18, value: 0 }]), Zb = Xb(0, [{ frames: 1, value: 1 }, { frames: 5, value: 1 }, { frames: 1, value: 0 }, { frames: 6, value: 0 }]), Kb = "0deg 75deg 105%", Qb = "auto auto auto", $b = "auto", ex = 1.1 * $p, tx = ["front", "right", "back", "left"], nx = ["upper-", "", "lower-"], rx = 3e3, ix = { AUTO: "auto", WHEN_FOCUSED: "when-focused", NONE: "none" }, ax = { BASIC: "basic", WIGGLE: "wiggle" }, ox = { ALWAYS_ALLOW: "always-allow", WHEN_FOCUSED: "allow-when-focused" }, sx = { PAN_Y: "pan-y", PAN_X: "pan-x", NONE: "none" }, lx = function (e) { return { basis: [Np(e[Ux] * Math.PI / 180, "rad")], keywords: { auto: [null] } } }, cx = { basis: [Wp(Np(25, "deg"))], keywords: { auto: [null] } }, ux = function (e) { var t = e[Qg]; return { basis: [Wp(Np(45, "deg"))], keywords: { auto: [Np(t.framedFieldOfView, "deg")] } } }, hx = (Tb = Dp(Kb)[0].terms, Eb = Xp(Tb[0]), Ab = Xp(Tb[1]), function (e) { var t = e[Qg].model.idealCameraDistance; return { basis: [Eb, Ab, Np(t, "m")], keywords: { auto: [null, null, Np(105, "%")] } } }), dx = function (e) { var t = ex * e[Qg].model.idealCameraDistance; return { basis: [Np(-1 / 0, "rad"), Np(Math.PI / 8, "rad"), Np(t, "m")], keywords: { auto: [null, null, null] } } }, px = function (e) { var t = hx(e), n = new gb([], t).evaluate()[2]; return { basis: [Np(1 / 0, "rad"), Np(Math.PI - Math.PI / 8, "rad"), Np(n, "m")], keywords: { auto: [null, null, null] } } }, fx = function (e) { var t = e[Qg].model.boundingBox.getCenter(new Nr); return { basis: [Np(t.x, "m"), Np(t.y, "m"), Np(t.z, "m")], keywords: { auto: [null, null, null] } } }, mx = Math.PI / 2, vx = Math.PI / 3, gx = mx / 2, yx = 2 * Math.PI, bx = Symbol("controls"), xx = Symbol("promptElement"), _x = Symbol("promptAnimatedContainer"), wx = Symbol("deferInteractionPrompt"), Mx = Symbol("updateAria"), Sx = Symbol("updateCameraForRadius"), Tx = Symbol("blurHandler"), Ex = Symbol("focusHandler"), Ax = Symbol("changeHandler"), Rx = Symbol("pointerChangeHandler"), kx = Symbol("onBlur"), Lx = Symbol("onFocus"), Cx = Symbol("onChange"), Px = Symbol("onPointerChange"), Ox = Symbol("waitingToPromptUser"), Ix = Symbol("userHasInteracted"), Nx = Symbol("promptElementVisibleTime"), Dx = Symbol("lastPromptOffset"), Fx = Symbol("focusedTime"), Ux = Symbol("zoomAdjustedFieldOfView"), zx = Symbol("lastSpherical"), Bx = Symbol("jumpCamera"), Hx = Symbol("initialized"), Gx = Symbol("maintainThetaPhi"), Vx = Symbol("syncCameraOrbit"), jx = Symbol("syncFieldOfView"), Wx = Symbol("syncCameraTarget"), qx = Symbol("syncMinCameraOrbit"), Xx = Symbol("syncMaxCameraOrbit"), Yx = Symbol("syncMinFieldOfView"), Jx = Symbol("syncMaxFieldOfView"), Zx = function (e, t, n, r) { var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r; "undefined" == typeof Reflect || _typeof(Reflect); for (var s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o); return a > 3 && o && Object.defineProperty(t, n, o), o }, Kx = 0, Qx = 1, $x = 1, e_ = Symbol("currentEnvironmentMap"), t_ = Symbol("applyEnvironmentMap"), n_ = Symbol("updateEnvironment"), r_ = Symbol("cancelEnvironmentUpdate"), i_ = Symbol("onPreload"), a_ = 100, o_ = Symbol("modelViewerStatusInstance"), s_ = Symbol("updateStatus"), l_ = function (e) { _inherits(n, xr); var t = _createSuper(n); function n() { var e; _classCallCheck(this, n), (e = t.call(this))[Rb] = null, e.registeredInstanceStatuses = new Map, e.loadingPromises = [], e.statusElement = document.createElement("p"), e.statusUpdateInProgress = !1, e[kb] = _m(function () { return e.updateStatus() }, a_); var r = _assertThisInitialized(e).statusElement, i = r.style; return r.setAttribute("role", "status"), r.classList.add("screen-reader-only"), i.top = i.left = "0", i.pointerEvents = "none", e } return _createClass(n, [{ key: "registerInstance", value: function (e) { if (!this.registeredInstanceStatuses.has(e)) { var t = function () { }, n = !1 === e.loaded && !!e.src, r = new Promise(function (r) { if (n) { var i = function t() { r(), e.removeEventListener("load", t), e.removeEventListener("error", t) }; e.addEventListener("load", i), e.addEventListener("error", i), t = i } else r() }); this.registeredInstanceStatuses.set(e, { onUnregistered: t }), this.loadingPromises.push(r), null == this.modelViewerStatusInstance && (this.modelViewerStatusInstance = e) } } }, { key: "unregisterInstance", value: function (e) { if (this.registeredInstanceStatuses.has(e)) { var t = this.registeredInstanceStatuses, n = t.get(e); t.delete(e), n.onUnregistered(), this.modelViewerStatusInstance === e && (this.modelViewerStatusInstance = t.size > 0 ? function (e) { if (null != e.keys) return e.keys().next().value || null; var t = null; try { e.forEach(function (e, n, r) { throw t = n, new Error }) } catch (e) { } return t }(t) : null) } } }, { key: "updateStatus", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e() { var t; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (!this.statusUpdateInProgress && 0 !== this.loadingPromises.length) { e.next = 2; break } return e.abrupt("return"); case 2: this.statusElement.textContent = "This page includes one or more 3D models that are loading", this.statusUpdateInProgress = !0, this.dispatchEvent({ type: "initial-status-announced" }); case 5: if (!this.loadingPromises.length) { e.next = 12; break } return t = this.loadingPromises, this.loadingPromises = [], e.next = 10, Promise.all(t); case 10: e.next = 5; break; case 12: this.statusElement.textContent = "All 3D models in the page have loaded", this.statusUpdateInProgress = !1, this.dispatchEvent({ type: "finished-loading-announced" }); case 15: case "end": return e.stop() } }, e, this) })); return function () { return e.apply(this, arguments) } }() }, { key: "modelViewerStatusInstance", get: function () { return this[o_] }, set: function (e) { if (this[o_] !== e) { var t = this.statusElement; null != e && null != e.shadowRoot ? e.shadowRoot.appendChild(t) : null != t.parentNode && t.parentNode.removeChild(t), this[o_] = e, this[s_]() } } }]), n }(); Rb = o_, kb = s_; var c_, u_, h_, d_, p_ = function (e, t, n, r) { var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r; "undefined" == typeof Reflect || _typeof(Reflect); for (var s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o); return a > 3 && o && Object.defineProperty(t, n, o), o }, f_ = 100, m_ = .2, v_ = "https://www.gstatic.com/draco/versioned/decoders/1.3.6/", g_ = { AUTO: "auto", INTERACTION: "interaction", MANUAL: "manual" }, y_ = { AUTO: "auto", LAZY: "lazy", EAGER: "eager" }, b_ = "interaction", x_ = new l_, __ = Symbol("defaultProgressBarElement"), w_ = Symbol("defaultProgressMaskElement"), M_ = Symbol("posterContainerElement"), S_ = Symbol("defaultPosterElement"), T_ = Symbol("posterDismissalSource"), E_ = Symbol("showPoster"), A_ = Symbol("hidePoster"), R_ = Symbol("modelIsRevealed"), k_ = Symbol("updateProgressBar"), L_ = Symbol("lastReportedProgress"), C_ = Symbol("transitioned"), P_ = Symbol("ariaLabelCallToAction"), O_ = Symbol("clickHandler"), I_ = Symbol("keydownHandler"), N_ = Symbol("processHandler"), D_ = Symbol("onClick"), F_ = Symbol("onKeydown"), U_ = Symbol("onProgress"), z_ = { HANDSHAKE: 1, IMPORT_SCRIPT: 2, MODEL_CHANGE: 3, MUTATION_RESULT: 4, CONTEXT_INITIALIZED: 5, MUTATE: 6 }, B_ = Symbol("ownerModel"), H_ = function () { function e(t) { if (_classCallCheck(this, e), null == t) throw new Error("Illegal constructor"); this[B_] = t.model } return _createClass(e, [{ key: "ownerModel", get: function () { return this[B_] } }]), e }(), G_ = Symbol("kernel"), V_ = Symbol("uri"), j_ = Symbol("name"), W_ = function (e) { _inherits(n, H_); var t = _createSuper(n); function n(e, r) { var i; return _classCallCheck(this, n), (i = t.call(this, e))[G_] = e, i[V_] = r.uri || null, null != r.name && (i[j_] = r.name), i } return _createClass(n, [{ key: "setURI", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, this[G_].mutate(this, "uri", t); case 2: this[V_] = t; case 3: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "name", get: function () { return this[j_] } }, { key: "type", get: function () { return null != this.uri ? "external" : "embedded" } }, { key: "uri", get: function () { return this[V_] } }]), n }(), q_ = Symbol("pbrMetallicRoughness"), X_ = Symbol("normalTexture"), Y_ = Symbol("occlusionTexture"), J_ = Symbol("emissiveTexture"), Z_ = Symbol("kernel"), K_ = Symbol("name"), Q_ = function (e) { _inherits(n, H_); var t = _createSuper(n); function n(e, r) { var i; _classCallCheck(this, n), (i = t.call(this, e))[c_] = null, i[u_] = null, i[h_] = null, i[Z_] = e, null != r.name && (i[K_] = r.name); var a = r.pbrMetallicRoughness, o = r.normalTexture, s = r.occlusionTexture, l = r.emissiveTexture; return i[q_] = e.deserialize("pbr-metallic-roughness", a), null != o && (i[X_] = e.deserialize("texture-info", o)), null != s && (i[Y_] = e.deserialize("texture-info", s)), null != l && (i[J_] = e.deserialize("texture-info", l)), i } return _createClass(n, [{ key: "pbrMetallicRoughness", get: function () { return this[q_] } }, { key: "normalTexture", get: function () { return this[X_] } }, { key: "occlusionTexture", get: function () { return this[Y_] } }, { key: "emissiveTexture", get: function () { return this[J_] } }, { key: "name", get: function () { return this[K_] } }]), n }(); c_ = X_, u_ = Y_, h_ = J_; var $_, ew, tw = Symbol("material"), nw = Symbol("kernel"), rw = function (e) { _inherits(n, H_); var t = _createSuper(n); function n(e, r) { var i; _classCallCheck(this, n), (i = t.call(this, e))[d_] = Object.freeze([]), i[nw] = e; var a, o = _createForOfIteratorHelper(r.materials); try { for (o.s(); !(a = o.n()).done;) { var s = a.value; i[nw].deserialize("material", s) } } catch (e) { o.e(e) } finally { o.f() } return i } return _createClass(n, [{ key: "materials", get: function () { return this[nw].getElementsByType("material") } }, { key: "ownerModel", get: function () { return this } }]), n }(); d_ = tw; var iw, aw, ow = Symbol("kernel"), sw = Symbol("baseColorFactor"), lw = Symbol("baseColorTexture"), cw = Symbol("metallicRoughnessTexture"), uw = Symbol("metallicFactor"), hw = Symbol("roughnessFactor"), dw = function (e) { _inherits(n, H_); var t = _createSuper(n); function n(e, r) { var i; _classCallCheck(this, n), (i = t.call(this, e))[$_] = null, i[ew] = null, i[ow] = e, i[sw] = Object.freeze(r.baseColorFactor), i[uw] = r.metallicFactor, i[hw] = r.roughnessFactor; var a = r.baseColorTexture, o = r.metallicRoughnessTexture; return null != a && (i[lw] = e.deserialize("texture-info", a)), null != o && (i[cw] = e.deserialize("texture-info", o)), i } return _createClass(n, [{ key: "setBaseColorFactor", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, this[ow].mutate(this, "baseColorFactor", t); case 2: this[sw] = Object.freeze(t); case 3: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "setMetallicFactor", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, this[ow].mutate(this, "metallicFactor", t); case 2: this[uw] = t; case 3: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "setRoughnessFactor", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, this[ow].mutate(this, "roughnessFactor", t); case 2: this[hw] = t; case 3: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "baseColorFactor", get: function () { return this[sw] } }, { key: "metallicFactor", get: function () { return this[uw] } }, { key: "roughnessFactor", get: function () { return this[hw] } }, { key: "baseColorTexture", get: function () { return this[lw] } }, { key: "metallicRoughnessTexture", get: function () { return this[cw] } }]), n }(); $_ = lw, ew = cw; var pw, fw = Symbol("kernel"), mw = Symbol("minFilter"), vw = Symbol("magFilter"), gw = Symbol("wrapS"), yw = Symbol("wrapT"), bw = Symbol("name"), xw = function (e) { _inherits(n, H_); var t = _createSuper(n); function n(e, r) { var i; return _classCallCheck(this, n), (i = t.call(this, e))[iw] = null, i[aw] = null, i[fw] = e, null != r.name && (i[bw] = r.name), i[mw] = r.minFilter || null, i[vw] = r.magFilter || null, i[gw] = r.wrapS || 10497, i[yw] = r.wrapT || 10497, i } return _createClass(n, [{ key: "setMinFilter", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, this[fw].mutate(this, "minFilter", t); case 2: this[mw] = t; case 3: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "setMagFilter", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, this[fw].mutate(this, "magFilter", t); case 2: this[vw] = t; case 3: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "setWrapS", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, this[fw].mutate(this, "wrapS", t); case 2: this[gw] = t; case 3: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "setWrapT", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, this[fw].mutate(this, "wrapT", t); case 2: this[yw] = t; case 3: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "name", get: function () { return this[bw] } }, { key: "minFilter", get: function () { return this[mw] } }, { key: "magFilter", get: function () { return this[vw] } }, { key: "wrapS", get: function () { return this[gw] } }, { key: "wrapT", get: function () { return this[yw] } }]), n }(); iw = mw, aw = vw; var _w, ww, Mw = Symbol("kernel"), Sw = Symbol("texture"), Tw = function (e) { _inherits(n, H_); var t = _createSuper(n); function n(e, r) { var i; _classCallCheck(this, n), (i = t.call(this, e))[pw] = null, i[Mw] = e; var a = r.texture; return null != a && (i[Sw] = e.deserialize("texture", a)), i } return _createClass(n, [{ key: "setTexture", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, this[Mw].mutate(this, "texture", t); case 2: this[Sw] = t; case 3: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "texture", get: function () { return this[Sw] } }]), n }(); pw = Sw; var Ew, Aw, Rw, kw, Lw, Cw, Pw = Symbol("kernel"), Ow = Symbol("source"), Iw = Symbol("sampler"), Nw = Symbol("name"), Dw = function (e) { _inherits(n, H_); var t = _createSuper(n); function n(e, r) { var i; _classCallCheck(this, n), (i = t.call(this, e))[_w] = null, i[ww] = null, i[Pw] = e; var a = r.sampler, o = r.source, s = r.name; return null != s && (i[Nw] = s), null != a && (i[Iw] = e.deserialize("sampler", a)), null != o && (i[Ow] = e.deserialize("image", o)), i } return _createClass(n, [{ key: "setSampler", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, this[Pw].mutate(this, "sampler", t); case 2: this[Iw] = t; case 3: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "setSource", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return e.next = 2, this[Pw].mutate(this, "source", t); case 2: this[Ow] = t; case 3: case "end": return e.stop() } }, e, this) })); return function (t) { return e.apply(this, arguments) } }() }, { key: "name", get: function () { return this[Nw] } }, { key: "sampler", get: function () { return this[Iw] } }, { key: "source", get: function () { return this[Ow] } }]), n }(); _w = Ow, ww = Iw; var Fw, Uw = { model: rw, material: Q_, "pbr-metallic-roughness": dw, image: W_, sampler: xw, texture: Dw, "texture-info": Tw }, zw = Symbol("onMessageEvent"), Bw = Symbol("port"), Hw = Symbol("model"), Gw = Symbol("elementsByLocalId"), Vw = Symbol("localIdsByElement"), jw = Symbol("elementsByType"), Ww = Symbol("pendingMutations"), qw = Symbol("nextMutationId"), Xw = function () { function e(t, n) { var r = this; _classCallCheck(this, e), this[Ew] = new Map, this[Aw] = new Map, this[Rw] = new Map, this[kw] = new Map, this[Lw] = 0, this[Cw] = function (e) { var t = e.data; switch (t && t.type) { case z_.MUTATION_RESULT: var n = t, i = n.applied, a = n.mutationId, o = r[Ww].get(a); r[Ww].delete(a), null != o && (i ? o.resolve() : o.reject()) } }; for (var i = 0, a = new Array("model", "material", "pbr-metallic-roughness", "sampler", "image", "texture", "texture-info"); i < a.length; i++) { var o = a[i]; this[jw].set(o, new Set) } this[Bw] = t, this[Bw].addEventListener("message", this[zw]), this[Bw].start(), this[Hw] = this.deserialize("model", n) } return _createClass(e, [{ key: "mutate", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t, n, r) { var i, a = this; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (this[Vw].has(t)) { e.next = 2; break } throw new Error("Cannot mutate unknown element"); case 2: return i = this[Vw].get(t), _instanceof(r, H_) && (r = this[Vw].get(r)), e.abrupt("return", new Promise(function (e, t) { var o = a[qw]++; a[Bw].postMessage({ type: z_.MUTATE, id: i, property: n, value: r, mutationId: o }), a[Ww].set(o, { resolve: e, reject: t }) })); case 5: case "end": return e.stop() } }, e, this) })); return function (t, n, r) { return e.apply(this, arguments) } }() }, { key: "deserialize", value: function (e, t) { var n = t.id; if (this[Gw].has(n)) return this[Gw].get(n); var r = Uw[e]; if (null == r) throw new Error("Cannot deserialize unknown type: ".concat(e)); var i = new r(this, t); return this[Gw].set(n, i), this[Vw].set(i, n), this[jw].get(e).add(i), i } }, { key: "getElementsByType", value: function (e) { return this[jw].has(e) ? Array.from(this[jw].get(e)) : [] } }, { key: "deactivate", value: function () { this[Bw].close(), this[Bw].removeEventListener("message", this[zw]) } }, { key: "model", get: function () { return this[Hw] } }]), e }(); Ew = Gw, Aw = Vw, Rw = jw, kw = Ww, Lw = qw, Cw = zw; var Yw = Symbol("modelGraft"), Jw = Symbol("port"), Zw = Symbol("onMessageEvent"), Kw = function () { function e(t, n) { var r = this; _classCallCheck(this, e), this[Fw] = function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { var n, i, a; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (!(n = t.data) || !n.type) { e.next = 12; break } if (n.type !== z_.MUTATE) { e.next = 12; break } return i = !1, a = n.mutationId, e.prev = 5, e.next = 8, r[Yw].mutate(n.id, n.property, n.value); case 8: i = !0; case 9: return e.prev = 9, r[Jw].postMessage({ type: z_.MUTATION_RESULT, applied: i, mutationId: a }), e.finish(9); case 12: case "end": return e.stop() } }, e, null, [[5, , 9, 12]]) })); return function (t) { return e.apply(this, arguments) } }(), this[Yw] = t, this[Jw] = n, this[Jw].addEventListener("message", this[Zw]), this[Jw].start() } return _createClass(e, [{ key: "dispose", value: function () { this[Jw].removeEventListener("message", this[Zw]), this[Jw].close() } }]), e }(); Fw = Zw; var Qw, $w, eM, tM = (Qw = 0, function () { return Qw++ }), nM = Symbol("callbacks"), rM = Symbol("visitMesh"), iM = Symbol("visitElement"), aM = Symbol("visitNode"), oM = Symbol("visitScene"), sM = Symbol("visitMaterial"), lM = function () { function e(t) { _classCallCheck(this, e), this[nM] = t } return _createClass(e, [{ key: "visit", value: function (e) { var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = !!n.allScenes, i = !!n.sparse, a = r ? e.scenes || [] : e.scenes && null != e.scene ? [e.scenes[e.scene]] : [], o = { hierarchy: [], visited: new Set, sparse: i, gltf: e }, s = _createForOfIteratorHelper(a); try { for (s.s(); !(t = s.n()).done;) { var l = t.value; this[oM](e.scenes.indexOf(l), o) } } catch (e) { s.e(e) } finally { s.f() } } }, { key: iM, value: function (e, t, n, r, i) { if (null != t) { var a = t[e], o = n.sparse, s = n.hierarchy, l = n.visited; null != a && (o && l.has(a) || (l.add(a), s.push(a), null != r && r(a, e, s), null != i && i(a), s.pop())) } } }, { key: oM, value: function (e, t) { var n = this, r = t.gltf, i = this[nM].scene; this[iM](e, r.scenes, t, i, function (e) { if (null != e.nodes) { var r, i = _createForOfIteratorHelper(e.nodes); try { for (i.s(); !(r = i.n()).done;) { var a = r.value; n[aM](a, t) } } catch (e) { i.e(e) } finally { i.f() } } }) } }, { key: aM, value: function (e, t) { var n = this, r = t.gltf, i = this[nM].node; this[iM](e, r.nodes, t, i, function (e) { if (null != e.mesh && n[rM](e.mesh, t), null != e.children) { var r, i = _createForOfIteratorHelper(e.children); try { for (i.s(); !(r = i.n()).done;) { var a = r.value; n[aM](a, t) } } catch (e) { i.e(e) } finally { i.f() } } }) } }, { key: rM, value: function (e, t) { var n = this, r = t.gltf, i = this[nM].mesh; this[iM](e, r.meshes, t, i, function (e) { var r, i = _createForOfIteratorHelper(e.primitives); try { for (i.s(); !(r = i.n()).done;) { var a = r.value; null != a.material && n[sM](a.material, t) } } catch (e) { i.e(e) } finally { i.f() } }) } }, { key: sM, value: function (e, t) { var n = t.gltf, r = this[nM].material; this[iM](e, n.materials, t, r) } }]), e }(), cM = Symbol("correlatedObjects"), uM = Symbol("sourceObject"), hM = Symbol("graft"), dM = Symbol("id"), pM = function () { function e(t, n) { var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; _classCallCheck(this, e), this[$w] = tM(), this[hM] = t, this[uM] = n, this[cM] = r, t.adopt(this) } return _createClass(e, [{ key: "mutate", value: function (e, t) { throw new Error("Mutation not implemented for this element") } }, { key: "toJSON", value: function () { var e = { id: this[dM] }, t = this.name; return null != t && (e.name = t), e } }, { key: "ownerModel", get: function () { return this[hM].model } }, { key: "internalID", get: function () { return this[dM] } }, { key: "name", get: function () { return this[uM].name || null } }, { key: "correlatedObjects", get: function () { return this[cM] } }, { key: "sourceObject", get: function () { return this[uM] } }]), e }(); $w = dM; var fM = new Yu, mM = Symbol("threeTextures"), vM = Symbol("bufferViewImages"), gM = function (e) { _inherits(n, pM); var t = _createSuper(n); function n(e, r, i) { var a; if (_classCallCheck(this, n), (a = t.call(this, e, r, i))[eM] = new WeakMap, null != r.bufferView) { var o, s = _createForOfIteratorHelper(i); try { for (s.s(); !(o = s.n()).done;) { var l = o.value; a[vM].set(l, l.image) } } catch (e) { s.e(e) } finally { s.f() } } return a } return _createClass(n, [{ key: "mutate", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t, n) { var r, i, a, o; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (r = null, "uri" === t) { e.next = 3; break } throw new Error('Cannot configure property "'.concat(t, '" on Image')); case 3: if (null == n) { e.next = 7; break } return e.next = 6, new Promise(function (e, t) { fM.load(n, e, void 0, t) }); case 6: r = e.sent; case 7: i = _createForOfIteratorHelper(this[mM]); try { for (i.s(); !(a = i.n()).done;)o = a.value, null == r && null != this.sourceObject.bufferView ? o.image = this[vM].get(o) : o.image = r, o.needsUpdate = !0 } catch (e) { i.e(e) } finally { i.f() } case 9: case "end": return e.stop() } }, e, this) })); return function (t, n) { return e.apply(this, arguments) } }() }, { key: "toJSON", value: function () { var e = _get(_getPrototypeOf(n.prototype), "toJSON", this).call(this), t = this.sourceObject.uri; return null != t && (e.uri = t), e } }, { key: mM, get: function () { return this[cM] } }]), n }(); eM = vM; var yM, bM, xM, _M, wM, MM, SM = (yM = [9728, 9729, 9984, 9985, 9986, 9987], function (e) { return yM.indexOf(e) > -1 }), TM = (bM = [9728, 9729], function (e) { return bM.indexOf(e) > -1 }), EM = (xM = [33071, 33648, 10497], function (e) { return xM.indexOf(e) > -1 }), AM = function (e, t) { switch (e) { case "minFilter": return SM(t); case "magFilter": return TM(t); case "wrapS": case "wrapT": return EM(t); default: throw new Error('Cannot configure property "'.concat(e, '" on Sampler')) } }, RM = { minFilter: 9987, magFilter: 9729, wrapS: 10497, wrapT: 10497 }, kM = Symbol("threeTextures"), LM = function (e) { _inherits(n, pM); var t = _createSuper(n); function n(e, r, i) { return _classCallCheck(this, n), t.call(this, e, r, i) } return _createClass(n, [{ key: kM, get: function () { return this[cM] } }]), _createClass(n, [{ key: "mutate", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t, n) { var r, i, a, o, s, l, c; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (r = this.sourceObject, null != n) { if (AM(t, n)) { r[t] = n, i = _createForOfIteratorHelper(this[kM]); try { for (i.s(); !(a = i.n()).done;)(o = a.value)[t] = n, o.needsUpdate = !0 } catch (e) { i.e(e) } finally { i.f() } } } else if (t in r) { delete r[t], s = _createForOfIteratorHelper(this[kM]); try { for (s.s(); !(l = s.n()).done;)(c = l.value)[t] = RM[t], c.needsUpdate = !0 } catch (e) { s.e(e) } finally { s.f() } } case 2: case "end": return e.stop() } }, e, this) })); return function (t, n) { return e.apply(this, arguments) } }() }, { key: "toJSON", value: function () { var e = _get(_getPrototypeOf(n.prototype), "toJSON", this).call(this), t = this.sourceObject, r = t.minFilter, i = t.magFilter, a = t.wrapS, o = t.wrapT; return null != r && (e.minFilter = r), null != i && (e.magFilter = i), 10497 !== a && (e.wrapS = a), 10497 !== o && (e.wrapT = o), e } }]), n }(), CM = Symbol("source"), PM = Symbol("sampler"), OM = function (e) { _inherits(n, pM); var t = _createSuper(n); function n(e, r, i) { var a; _classCallCheck(this, n), (a = t.call(this, e, r, i))[_M] = null, a[wM] = null; var o = e.correlatedSceneGraph.gltf, s = r.sampler, l = r.source; if (null != s) { var c = o.samplers && o.samplers[s]; null != c && (a[PM] = new LM(e, c, i)) } if (null != l) { var u = o.images && o.images[l]; null != u && (a[CM] = new gM(e, u, i)) } return a } return _createClass(n, [{ key: "toJSON", value: function () { var e = _get(_getPrototypeOf(n.prototype), "toJSON", this).call(this), t = this.sampler, r = this.source; return null != t && (e.sampler = t.toJSON()), null != r && (e.source = r.toJSON()), e } }, { key: "sampler", get: function () { return this[PM] } }, { key: "source", get: function () { return this[CM] } }]), n }(); _M = CM, wM = PM; var IM, NM, DM = Symbol("texture"), FM = function (e) { _inherits(n, pM); var t = _createSuper(n); function n(e, r, i) { var a; _classCallCheck(this, n), (a = t.call(this, e, r, i))[MM] = null; var o = e.correlatedSceneGraph.gltf, s = r.index, l = null != s && null != o.textures ? o.textures[s] : null; return null != l && (a[DM] = new OM(e, l, i)), a } return _createClass(n, [{ key: "toJSON", value: function () { var e = _get(_getPrototypeOf(n.prototype), "toJSON", this).call(this), t = this.texture; return null != t && (e.texture = t.toJSON()), e } }, { key: "texture", get: function () { return this[DM] } }]), n }(); MM = DM; var UM, zM, BM, HM, GM, VM, jM = Symbol("threeMaterials"), WM = Symbol("baseColorTexture"), qM = Symbol("metallicRoughnessTexture"), XM = function (e) { _inherits(n, pM); var t = _createSuper(n); function n(e, r, i) { var a; _classCallCheck(this, n), (a = t.call(this, e, r, i))[IM] = null, a[NM] = null; var o, s = r.baseColorTexture, l = r.metallicRoughnessTexture, c = new Set, u = new Set, h = _createForOfIteratorHelper(i); try { for (h.s(); !(o = h.n()).done;) { var d = o.value; null != s && null != d.map && c.add(d.map), null != l && null != d.metalnessMap && u.add(d.metalnessMap) } } catch (e) { h.e(e) } finally { h.f() } return c.size > 0 && (a[WM] = new FM(e, s, c)), u.size > 0 && (a[qM] = new FM(e, l, u)), a } return _createClass(n, [{ key: "mutate", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t, n) { var r, i, a, o, s, l, c, u; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (["baseColorFactor", "metallicFactor", "roughnessFactor"].includes(t)) { e.next = 2; break } throw new Error("Cannot mutate ".concat(t, " on PBRMetallicRoughness")); case 2: e.t0 = t, e.next = "baseColorFactor" === e.t0 ? 5 : "metallicFactor" === e.t0 ? 8 : "roughnessFactor" === e.t0 ? 11 : 14; break; case 5: r = _createForOfIteratorHelper(this[jM]); try { for (r.s(); !(i = r.n()).done;)(a = i.value).color.fromArray(n), a.opacity = n[3], o = this[uM], 1 === n && 1 === n && 1 === n && 1 === n ? delete o.baseColorFactor : o.baseColorFactor = n } catch (e) { r.e(e) } finally { r.f() } return e.abrupt("break", 14); case 8: s = _createForOfIteratorHelper(this[jM]); try { for (s.s(); !(l = s.n()).done;)l.value.metalness = n, this[uM].metallicFactor = n } catch (e) { s.e(e) } finally { s.f() } return e.abrupt("break", 14); case 11: c = _createForOfIteratorHelper(this[jM]); try { for (c.s(); !(u = c.n()).done;)u.value.roughness = n, this[uM].roughnessFactor = n } catch (e) { c.e(e) } finally { c.f() } return e.abrupt("break", 14); case 14: case "end": return e.stop() } }, e, this) })); return function (t, n) { return e.apply(this, arguments) } }() }, { key: "toJSON", value: function () { var e = _get(_getPrototypeOf(n.prototype), "toJSON", this).call(this), t = this.baseColorTexture, r = this.metallicRoughnessTexture, i = this.baseColorFactor, a = this.roughnessFactor, o = this.metallicFactor; return null != t && (e.baseColorTexture = t.toJSON()), null != i && (e.baseColorFactor = i), null != o && (e.metallicFactor = o), null != a && (e.roughnessFactor = a), null != r && (e.metallicRoughnessTexture = r.toJSON()), e } }, { key: (IM = WM, NM = qM, jM), get: function () { return this[cM] } }, { key: "baseColorFactor", get: function () { return this.sourceObject.baseColorFactor || [1, 1, 1, 1] } }, { key: "metallicFactor", get: function () { return this.sourceObject.metallicFactor || 0 } }, { key: "roughnessFactor", get: function () { return this.sourceObject.roughnessFactor || 0 } }, { key: "baseColorTexture", get: function () { return this[WM] } }, { key: "metallicRoughnessTexture", get: function () { return this[qM] } }]), n }(), YM = Symbol("pbrMetallicRoughness"), JM = Symbol("normalTexture"), ZM = Symbol("occlusionTexture"), KM = Symbol("emissiveTexture"), QM = function (e) { _inherits(n, pM); var t = _createSuper(n); function n(e, r, i) { var a; _classCallCheck(this, n), (a = t.call(this, e, r, i))[UM] = null, a[zM] = null, a[BM] = null, a[HM] = null; var o = r.pbrMetallicRoughness, s = r.normalTexture, l = r.occlusionTexture, c = r.emissiveTexture; null != o && (a[YM] = new XM(e, o, i)); var u, h = new Set, d = new Set, p = new Set, f = _createForOfIteratorHelper(i); try { for (f.s(); !(u = f.n()).done;) { var m = u.value, v = m.normalMap, g = m.aoMap, y = m.emissiveMap; null != s && null != v && h.add(v), null != l && null != g && d.add(g), null != c && null != y && p.add(y) } } catch (e) { f.e(e) } finally { f.f() } return h.size > 0 && (a[JM] = new FM(e, s, h)), d.size > 0 && (a[ZM] = new FM(e, l, d)), p.size > 0 && (a[KM] = new FM(e, c, p)), a } return _createClass(n, [{ key: "toJSON", value: function () { var e = _get(_getPrototypeOf(n.prototype), "toJSON", this).call(this), t = this.pbrMetallicRoughness, r = this.normalTexture, i = this.occlusionTexture, a = this.emissiveTexture; return null != t && (e.pbrMetallicRoughness = t.toJSON()), null != r && (e.normalTexture = r.toJSON()), null != i && (e.occlusionTexture = i.toJSON()), null != a && (e.emissiveTexture = a.toJSON()), e } }, { key: "pbrMetallicRoughness", get: function () { return this[YM] } }, { key: "normalTexture", get: function () { return this[JM] } }, { key: "occlusionTexture", get: function () { return this[ZM] } }, { key: "emissiveTexture", get: function () { return this[KM] } }]), n }(); UM = YM, zM = JM, BM = ZM, HM = KM; var $M, eS, tS = Symbol("modelUri"), nS = Symbol("materials"), rS = function (e) { _inherits(n, pM); var t = _createSuper(n); function n(e, r, i) { var a; return _classCallCheck(this, n), (a = t.call(this, e, i.gltf))[GM] = "", a[VM] = [], a[tS] = r, new lM({ material: function (t) { a[nS].push(new QM(e, t, i.gltfElementMap.get(t))) } }).visit(i.gltf, { sparse: !0 }), a } return _createClass(n, [{ key: "toJSON", value: function () { var e = _get(_getPrototypeOf(n.prototype), "toJSON", this).call(this); return e.modelUri = this[tS], e.materials = this[nS].map(function (e) { return e.toJSON() }), e } }, { key: "materials", get: function () { return this[nS] } }]), n }(); GM = tS, VM = nS; var iS = Symbol("model"), aS = Symbol("correlatedSceneGraph"), oS = Symbol("elementsByInternalId"), sS = Symbol("eventDelegate"), lS = function () { function e(t, n) { var r = this; _classCallCheck(this, e), this[$M] = document.createDocumentFragment(), this.addEventListener = function () { var e; return (e = r[sS]).addEventListener.apply(e, arguments) }, this.removeEventListener = function () { var e; return (e = r[sS]).removeEventListener.apply(e, arguments) }, this.dispatchEvent = function () { var e; return (e = r[sS]).dispatchEvent.apply(e, arguments) }, this[eS] = new Map, this[aS] = n, this[iS] = new rS(this, t, n) } return _createClass(e, [{ key: "getElementByInternalId", value: function (e) { var t = this[oS].get(e); return null == t ? null : t } }, { key: "adopt", value: function (e) { this[oS].set(e.internalID, e) } }, { key: "mutate", value: function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(t, n, r) { var i; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return i = this.getElementByInternalId(t), e.next = 3, i.mutate(n, r); case 3: this.dispatchEvent(new CustomEvent("mutation", { detail: { element: i } })); case 4: case "end": return e.stop() } }, e, this) })); return function (t, n, r) { return e.apply(this, arguments) } }() }, { key: "correlatedSceneGraph", get: function () { return this[aS] } }, { key: "model", get: function () { return this[iS] } }]), e }(); $M = sS, eS = oS; var cS = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123, FLOAT: 5126, UNSIGNED_INT: 5125, ARRAY_BUFFER: 34962, ELEMENT_ARRAY_BUFFER: 34963, NEAREST: 9728, LINEAR: 9729, NEAREST_MIPMAP_NEAREST: 9984, LINEAR_MIPMAP_NEAREST: 9985, NEAREST_MIPMAP_LINEAR: 9986, LINEAR_MIPMAP_LINEAR: 9987, CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648, REPEAT: 10497 }, uS = {}; uS[It] = cS.NEAREST, uS[Nt] = cS.NEAREST_MIPMAP_NEAREST, uS[Dt] = cS.NEAREST_MIPMAP_LINEAR, uS[Ft] = cS.LINEAR, uS[Ut] = cS.LINEAR_MIPMAP_NEAREST, uS[zt] = cS.LINEAR_MIPMAP_LINEAR, uS[Pt] = cS.CLAMP_TO_EDGE, uS[Ct] = cS.REPEAT, uS[Ot] = cS.MIRRORED_REPEAT; var hS = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" }, dS = function () { }; dS.prototype = { constructor: dS, parse: function (e, t, n) { var r = { binary: !1, trs: !1, onlyVisible: !0, truncateDrawRange: !0, embedImages: !0, maxTextureSize: 1 / 0, animations: [], forcePowerOfTwoTextures: !1, includeCustomExtensions: !1 }; (n = Object.assign({}, r, n)).animations.length > 0 && (n.trs = !0); var i, a = { asset: { version: "2.0", generator: "GLTFExporter" } }, o = 0, s = [], l = [], c = new Map, u = [], h = {}, d = { meshes: new Map, attributes: new Map, attributesNormalized: new Map, materials: new Map, textures: new Map, images: new Map }, p = new Map, f = 0; function m(e) { return p.has(e) || p.set(e, f++), p.get(e) } function v(e, t) { return e.length === t.length && e.every(function (e, n) { return e === t[n] }) } function g(e) { return 4 * Math.ceil(e / 4) } function y(e, t) { t = t || 0; var n = g(e.byteLength); if (n !== e.byteLength) { var r = new Uint8Array(n); if (r.set(new Uint8Array(e)), 0 !== t) for (var i = e.byteLength; i < n; i++)r[i] = t; return r.buffer } return e } function b(e, t) { if (0 !== Object.keys(e.userData).length) try { var r = JSON.parse(JSON.stringify(e.userData)); if (n.includeCustomExtensions && r.gltfExtensions) { for (var i in void 0 === t.extensions && (t.extensions = {}), r.gltfExtensions) t.extensions[i] = r.gltfExtensions[i], h[i] = !0; delete r.gltfExtensions } Object.keys(r).length > 0 && (t.extras = r) } catch (t) { console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + t.message) } } function x(e, t) { var n = !1, r = {}; 0 === t.offset.x && 0 === t.offset.y || (r.offset = t.offset.toArray(), n = !0), 0 !== t.rotation && (r.rotation = t.rotation, n = !0), 1 === t.repeat.x && 1 === t.repeat.y || (r.scale = t.repeat.toArray(), n = !0), n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = r, h.KHR_texture_transform = !0) } function _(e) { return a.buffers || (a.buffers = [{ byteLength: 0 }]), s.push(e), 0 } function w(e, t, r, i) { var s; if (e.array.constructor === Float32Array) s = cS.FLOAT; else if (e.array.constructor === Uint32Array) s = cS.UNSIGNED_INT; else if (e.array.constructor === Uint16Array) s = cS.UNSIGNED_SHORT; else { if (e.array.constructor !== Uint8Array) throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type."); s = cS.UNSIGNED_BYTE } if (void 0 === r && (r = 0), void 0 === i && (i = e.count), n.truncateDrawRange && void 0 !== t && null === t.index) { var l = r + i, c = t.drawRange.count === 1 / 0 ? e.count : t.drawRange.start + t.drawRange.count; r = Math.max(r, t.drawRange.start), (i = Math.min(l, c) - r) < 0 && (i = 0) } if (0 === i) return null; var u, h = function (e, t, n) { for (var r = { min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY) }, i = t; i < t + n; i++)for (var a = 0; a < e.itemSize; a++) { var o = e.array[i * e.itemSize + a]; r.min[a] = Math.min(r.min[a], o), r.max[a] = Math.max(r.max[a], o) } return r }(e, r, i); void 0 !== t && (u = e === t.index ? cS.ELEMENT_ARRAY_BUFFER : cS.ARRAY_BUFFER); var d = function (e, t, n, r, i) { var s; a.bufferViews || (a.bufferViews = []), s = t === cS.UNSIGNED_BYTE ? 1 : t === cS.UNSIGNED_SHORT ? 2 : 4; for (var l = g(r * e.itemSize * s), c = new DataView(new ArrayBuffer(l)), u = 0, h = n; h < n + r; h++)for (var d = 0; d < e.itemSize; d++) { var p; e.itemSize > 4 ? p = e.array[h * e.itemSize + d] : 0 === d ? p = e.getX(h) : 1 === d ? p = e.getY(h) : 2 === d ? p = e.getZ(h) : 3 === d && (p = e.getW(h)), t === cS.FLOAT ? c.setFloat32(u, p, !0) : t === cS.UNSIGNED_INT ? c.setUint32(u, p, !0) : t === cS.UNSIGNED_SHORT ? c.setUint16(u, p, !0) : t === cS.UNSIGNED_BYTE && c.setUint8(u, p), u += s } var f = { buffer: _(c.buffer), byteOffset: o, byteLength: l }; return void 0 !== i && (f.target = i), i === cS.ARRAY_BUFFER && (f.byteStride = e.itemSize * s), o += l, a.bufferViews.push(f), { id: a.bufferViews.length - 1, byteLength: 0 } }(e, s, r, i, u), p = { bufferView: d.id, byteOffset: d.byteOffset, componentType: s, count: i, max: h.max, min: h.min, type: { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 16: "MAT4" }[e.itemSize] }; return !0 === e.normalized && (p.normalized = !0), a.accessors || (a.accessors = []), a.accessors.push(p), a.accessors.length - 1 } function M(e, t, r) { d.images.has(e) || d.images.set(e, {}); var s = d.images.get(e), c = t === en ? "image/png" : "image/jpeg", u = c + ":flipY/" + r.toString(); if (void 0 !== s[u]) return s[u]; a.images || (a.images = []); var h = { mimeType: c }; if (n.embedImages) { var p = i = i || document.createElement("canvas"); p.width = Math.min(e.width, n.maxTextureSize), p.height = Math.min(e.height, n.maxTextureSize), n.forcePowerOfTwoTextures && !function (e) { return Tr.isPowerOfTwo(e.width) && Tr.isPowerOfTwo(e.height) }(p) && (console.warn("GLTFExporter: Resized non-power-of-two image.", e), p.width = Tr.floorPowerOfTwo(p.width), p.height = Tr.floorPowerOfTwo(p.height)); var f = p.getContext("2d"); !0 === r && (f.translate(0, p.height), f.scale(1, -1)), f.drawImage(e, 0, 0, p.width, p.height), !0 === n.binary ? l.push(new Promise(function (e) { p.toBlob(function (t) { (function (e) { return a.bufferViews || (a.bufferViews = []), new Promise(function (t) { var n = new window.FileReader; n.readAsArrayBuffer(e), n.onloadend = function () { var e = y(n.result), r = { buffer: _(e), byteOffset: o, byteLength: e.byteLength }; o += e.byteLength, a.bufferViews.push(r), t(a.bufferViews.length - 1) } }) })(t).then(function (t) { h.bufferView = t, e() }) }, c) })) : h.uri = p.toDataURL(c) } else h.uri = e.src; a.images.push(h); var m = a.images.length - 1; return s[u] = m, m } function S(e) { a.samplers || (a.samplers = []); var t = { magFilter: uS[e.magFilter], minFilter: uS[e.minFilter], wrapS: uS[e.wrapS], wrapT: uS[e.wrapT] }; return a.samplers.push(t), a.samplers.length - 1 } function T(e) { if (d.textures.has(e)) return d.textures.get(e); a.textures || (a.textures = []); var t = { sampler: S(e), source: M(e.image, e.format, e.flipY) }; e.name && (t.name = e.name), a.textures.push(t); var n = a.textures.length - 1; return d.textures.set(e, n), n } function E(e) { if (d.materials.has(e)) return d.materials.get(e); if (e.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null; a.materials || (a.materials = []); var t = { pbrMetallicRoughness: {} }; e.isMeshBasicMaterial ? (t.extensions = { KHR_materials_unlit: {} }, h.KHR_materials_unlit = !0) : e.isGLTFSpecularGlossinessMaterial ? (t.extensions = { KHR_materials_pbrSpecularGlossiness: {} }, h.KHR_materials_pbrSpecularGlossiness = !0) : e.isMeshStandardMaterial || console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results."); var n = e.color.toArray().concat([e.opacity]); if (v(n, [1, 1, 1, 1]) || (t.pbrMetallicRoughness.baseColorFactor = n), e.isMeshStandardMaterial ? (t.pbrMetallicRoughness.metallicFactor = e.metalness, t.pbrMetallicRoughness.roughnessFactor = e.roughness) : e.isMeshBasicMaterial ? (t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9) : (t.pbrMetallicRoughness.metallicFactor = .5, t.pbrMetallicRoughness.roughnessFactor = .5), e.isGLTFSpecularGlossinessMaterial) { t.pbrMetallicRoughness.baseColorFactor && (t.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor); var r = [1, 1, 1]; e.specular.toArray(r, 0), t.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor = r, t.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor = e.glossiness } if (e.metalnessMap || e.roughnessMap) if (e.metalnessMap === e.roughnessMap) { var i = { index: T(e.metalnessMap) }; x(i, e.metalnessMap), t.pbrMetallicRoughness.metallicRoughnessTexture = i } else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture."); if (e.map) { var o = { index: T(e.map) }; x(o, e.map), e.isGLTFSpecularGlossinessMaterial && (t.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture = o), t.pbrMetallicRoughness.baseColorTexture = o } if (e.isGLTFSpecularGlossinessMaterial && e.specularMap) { var s = { index: T(e.specularMap) }; x(s, e.specularMap), t.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture = s } if (e.emissive) { var l = e.emissive.clone().multiplyScalar(e.emissiveIntensity).toArray(); if (v(l, [0, 0, 0]) || (t.emissiveFactor = l), e.emissiveMap) { var c = { index: T(e.emissiveMap) }; x(c, e.emissiveMap), t.emissiveTexture = c } } if (e.normalMap) { var u = { index: T(e.normalMap) }; e.normalScale && -1 !== e.normalScale.x && (e.normalScale.x !== e.normalScale.y && console.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."), u.scale = e.normalScale.x), x(u, e.normalMap), t.normalTexture = u } if (e.aoMap) { var p = { index: T(e.aoMap), texCoord: 1 }; 1 !== e.aoMapIntensity && (p.strength = e.aoMapIntensity), x(p, e.aoMap), t.occlusionTexture = p } e.transparent ? t.alphaMode = "BLEND" : e.alphaTest > 0 && (t.alphaMode = "MASK", t.alphaCutoff = e.alphaTest), e.side === ze && (t.doubleSided = !0), "" !== e.name && (t.name = e.name), b(e, t), a.materials.push(t); var f = a.materials.length - 1; return d.materials.set(e, f), f } function A(e) { var t = [e.geometry.uuid]; if (Array.isArray(e.material)) for (var n = 0, r = e.material.length; n < r; n++)t.push(e.material[n].uuid); else t.push(e.material.uuid); var i = t.join(":"); if (d.meshes.has(i)) return d.meshes.get(i); var o, s = e.geometry; o = e.isLineSegments ? cS.LINES : e.isLineLoop ? cS.LINE_LOOP : e.isLine ? cS.LINE_STRIP : e.isPoints ? cS.POINTS : e.material.wireframe ? cS.LINES : cS.TRIANGLES, s.isBufferGeometry || (console.warn("GLTFExporter: Exporting THREE.Geometry will increase file size. Use BufferGeometry instead."), s = (new Ra).setFromObject(e)); var l = {}, c = {}, u = [], h = [], p = { uv: "TEXCOORD_0", uv2: "TEXCOORD_1", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" }, f = s.getAttribute("normal"); void 0 === f || function (e) { if (d.attributesNormalized.has(e)) return !1; for (var t = new Nr, n = 0, r = e.count; n < r; n++)if (Math.abs(t.fromArray(e.array, 3 * n).length() - 1) > 5e-4) return !1; return !0 }(f) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), s.setAttribute("normal", function (e) { if (d.attributesNormalized.has(e)) return d.attributesNormalized.get(e); for (var t = e.clone(), n = new Nr, r = 0, i = t.count; r < i; r++)n.fromArray(t.array, 3 * r), 0 === n.x && 0 === n.y && 0 === n.z ? n.setX(1) : n.normalize(), n.toArray(t.array, 3 * r); return d.attributesNormalized.set(e, t), t }(f))); var v = null; for (var g in s.attributes) if ("morph" !== g.substr(0, 5)) { var y = s.attributes[g]; g = p[g] || g.toUpperCase(); if (/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(g) || (g = "_" + g), d.attributes.has(m(y))) c[g] = d.attributes.get(m(y)); else { v = null; var x = y.array; "JOINTS_0" !== g || _instanceof(x, Uint16Array) || _instanceof(x, Uint8Array) || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), v = new ca(new Uint16Array(x), y.itemSize, y.normalized)); var _ = w(v || y, s); null !== _ && (c[g] = _, d.attributes.set(m(y), _)) } } if (void 0 !== f && s.setAttribute("normal", f), 0 === Object.keys(c).length) return null; if (void 0 !== e.morphTargetInfluences && e.morphTargetInfluences.length > 0) { var M = [], S = [], T = {}; if (void 0 !== e.morphTargetDictionary) for (var A in e.morphTargetDictionary) T[e.morphTargetDictionary[A]] = A; for (n = 0; n < e.morphTargetInfluences.length; ++n) { var R = {}, k = !1; for (var g in s.morphAttributes) if ("position" === g || "normal" === g) { y = s.morphAttributes[g][n]; var L = g.toUpperCase(), C = s.attributes[g]; if (d.attributes.has(m(y))) R[L] = d.attributes.get(m(y)); else { var P = y.clone(); if (!s.morphTargetsRelative) for (var O = 0, I = y.count; O < I; O++)P.setXYZ(O, y.getX(O) - C.getX(O), y.getY(O) - C.getY(O), y.getZ(O) - C.getZ(O)); R[L] = w(P, s), d.attributes.set(m(C), R[L]) } } else k || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), k = !0); h.push(R), M.push(e.morphTargetInfluences[n]), void 0 !== e.morphTargetDictionary && S.push(T[n]) } l.weights = M, S.length > 0 && (l.extras = {}, l.extras.targetNames = S) } var N = Array.isArray(e.material); if (N && 0 === s.groups.length) return null; for (var D = N ? e.material : [e.material], F = N ? s.groups : [{ materialIndex: 0, start: void 0, count: void 0 }], U = (n = 0, F.length); n < U; n++) { var z = { mode: o, attributes: c }; if (b(s, z), h.length > 0 && (z.targets = h), null !== s.index) { var B = m(s.index); void 0 === F[n].start && void 0 === F[n].count || (B += ":" + F[n].start + ":" + F[n].count), d.attributes.has(B) ? z.indices = d.attributes.get(B) : (z.indices = w(s.index, s, F[n].start, F[n].count), d.attributes.set(B, z.indices)), null === z.indices && delete z.indices } var H = E(D[F[n].materialIndex]); null !== H && (z.material = H), u.push(z) } l.primitives = u, a.meshes || (a.meshes = []), a.meshes.push(l); var G = a.meshes.length - 1; return d.meshes.set(i, G), G } function R(e, t) { a.animations || (a.animations = []); for (var n = (e = dS.Utils.mergeMorphTargetTracks(e.clone(), t)).tracks, r = [], i = [], o = 0; o < n.length; ++o) { var s = n[o], l = ud.parseTrackName(s.name), u = ud.findNode(t, l.nodeName), h = hS[l.propertyName]; if ("bones" === l.objectName && (u = !0 === u.isSkinnedMesh ? u.skeleton.getBoneByName(l.objectIndex) : void 0), !u || !h) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', s.name), null; var d, p = s.values.length / s.times.length; h === hS.morphTargetInfluences && (p /= u.morphTargetInfluences.length), !0 === s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (d = "CUBICSPLINE", p /= 3) : d = s.getInterpolation() === er ? "STEP" : "LINEAR", i.push({ input: w(new ca(s.times, 1)), output: w(new ca(s.values, p)), interpolation: d }), r.push({ sampler: i.length - 1, target: { node: c.get(u), path: h } }) } return a.animations.push({ name: e.name || "clip_" + a.animations.length, samplers: i, channels: r }), a.animations.length - 1 } function k(e) { var t = a.nodes[c.get(e)], n = e.skeleton; if (void 0 === n) return null; var r = e.skeleton.bones[0]; if (void 0 === r) return null; for (var i = [], o = new Float32Array(16 * n.bones.length), s = 0; s < n.bones.length; ++s)i.push(c.get(n.bones[s])), n.boneInverses[s].toArray(o, 16 * s); return void 0 === a.skins && (a.skins = []), a.skins.push({ inverseBindMatrices: w(new ca(o, 16)), joints: i, skeleton: c.get(r) }), t.skin = a.skins.length - 1 } function L(e) { var t = {}; e.name && (t.name = e.name), t.color = e.color.toArray(), t.intensity = e.intensity, e.isDirectionalLight ? t.type = "directional" : e.isPointLight ? (t.type = "point", e.distance > 0 && (t.range = e.distance)) : e.isSpotLight && (t.type = "spot", e.distance > 0 && (t.range = e.distance), t.spot = {}, t.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, t.spot.outerConeAngle = e.angle), void 0 !== e.decay && 2 !== e.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !e.target || e.target.parent === e && 0 === e.target.position.x && 0 === e.target.position.y && -1 === e.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."); var n = a.extensions.KHR_lights_punctual.lights; return n.push(t), n.length - 1 } function C(e) { a.nodes || (a.nodes = []); var t = {}; if (n.trs) { var r = e.quaternion.toArray(), i = e.position.toArray(), o = e.scale.toArray(); v(r, [0, 0, 0, 1]) || (t.rotation = r), v(i, [0, 0, 0]) || (t.translation = i), v(o, [1, 1, 1]) || (t.scale = o) } else e.matrixAutoUpdate && e.updateMatrix(), v(e.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) || (t.matrix = e.matrix.elements); if ("" !== e.name && (t.name = String(e.name)), b(e, t), e.isMesh || e.isLine || e.isPoints) { var s = A(e); null !== s && (t.mesh = s) } else if (e.isCamera) t.camera = function (e) { a.cameras || (a.cameras = []); var t = e.isOrthographicCamera, n = { type: t ? "orthographic" : "perspective" }; return t ? n.orthographic = { xmag: 2 * e.right, ymag: 2 * e.top, zfar: e.far <= 0 ? .001 : e.far, znear: e.near < 0 ? 0 : e.near } : n.perspective = { aspectRatio: e.aspect, yfov: Tr.degToRad(e.fov), zfar: e.far <= 0 ? .001 : e.far, znear: e.near < 0 ? 0 : e.near }, "" !== e.name && (n.name = e.type), a.cameras.push(n), a.cameras.length - 1 }(e); else if (e.isDirectionalLight || e.isPointLight || e.isSpotLight) h.KHR_lights_punctual || (a.extensions = a.extensions || {}, a.extensions.KHR_lights_punctual = { lights: [] }, h.KHR_lights_punctual = !0), t.extensions = t.extensions || {}, t.extensions.KHR_lights_punctual = { light: L(e) }; else if (e.isLight) return console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e), null; if (e.isSkinnedMesh && u.push(e), e.children.length > 0) { for (var l = [], d = 0, p = e.children.length; d < p; d++) { var f = e.children[d]; if (f.visible || !1 === n.onlyVisible) { var m = C(f); null !== m && l.push(m) } } l.length > 0 && (t.children = l) } a.nodes.push(t); var g = a.nodes.length - 1; return c.set(e, g), g } function P(e) { a.scenes || (a.scenes = [], a.scene = 0); var t = {}; "" !== e.name && (t.name = e.name), a.scenes.push(t); for (var r = [], i = 0, o = e.children.length; i < o; i++) { var s = e.children[i]; if (s.visible || !1 === n.onlyVisible) { var l = C(s); null !== l && r.push(l) } } r.length > 0 && (t.nodes = r), b(e, t) } !function (e) { e = _instanceof(e, Array) ? e : [e]; for (var t = [], r = 0; r < e.length; r++)_instanceof(e[r], Ml) ? P(e[r]) : t.push(e[r]); for (t.length > 0 && function (e) { var t = new Ml; t.name = "AuxScene"; for (var n = 0; n < e.length; n++)t.children.push(e[n]); P(t) }(t), r = 0; r < u.length; ++r)k(u[r]); for (r = 0; r < n.animations.length; ++r)R(n.animations[r], e[0]) }(e), Promise.all(l).then(function () { var e = new Blob(s, { type: "application/octet-stream" }), r = Object.keys(h); if (r.length > 0 && (a.extensionsUsed = r), a.buffers && a.buffers.length > 0 && (a.buffers[0].byteLength = e.size), !0 === n.binary) { (i = new window.FileReader).readAsArrayBuffer(e), i.onloadend = function () { var e = y(i.result), n = new DataView(new ArrayBuffer(8)); n.setUint32(0, e.byteLength, !0), n.setUint32(4, 5130562, !0); var r = y(function (e) { if (void 0 !== window.TextEncoder) return (new TextEncoder).encode(e).buffer; for (var t = new Uint8Array(new ArrayBuffer(e.length)), n = 0, r = e.length; n < r; n++) { var i = e.charCodeAt(n); t[n] = i > 255 ? 32 : i } return t.buffer }(JSON.stringify(a)), 32), o = new DataView(new ArrayBuffer(8)); o.setUint32(0, r.byteLength, !0), o.setUint32(4, 1313821514, !0); var s = new ArrayBuffer(12), l = new DataView(s); l.setUint32(0, 1179937895, !0), l.setUint32(4, 2, !0); var c = 12 + o.byteLength + r.byteLength + n.byteLength + e.byteLength; l.setUint32(8, c, !0); var u = new Blob([s, o, r, n, e], { type: "application/octet-stream" }), h = new window.FileReader; h.readAsArrayBuffer(u), h.onloadend = function () { t(h.result) } } } else { var i; if (a.buffers && a.buffers.length > 0) (i = new window.FileReader).readAsDataURL(e), i.onloadend = function () { var e = i.result; a.buffers[0].uri = e, t(a) }; else t(a) } }) } }, dS.Utils = { insertKeyframe: function (e, t) { var n, r = e.getValueSize(), i = new e.TimeBufferType(e.times.length + 1), a = new e.ValueBufferType(e.values.length + r), o = e.createInterpolant(new e.ValueBufferType(r)); if (0 === e.times.length) { i[0] = t; for (var s = 0; s < r; s++)a[s] = 0; n = 0 } else if (t < e.times[0]) { if (Math.abs(e.times[0] - t) < .001) return 0; i[0] = t, i.set(e.times, 1), a.set(o.evaluate(t), 0), a.set(e.values, r), n = 0 } else if (t > e.times[e.times.length - 1]) { if (Math.abs(e.times[e.times.length - 1] - t) < .001) return e.times.length - 1; i[i.length - 1] = t, i.set(e.times, 0), a.set(e.values, 0), a.set(o.evaluate(t), e.values.length), n = i.length - 1 } else for (s = 0; s < e.times.length; s++) { if (Math.abs(e.times[s] - t) < .001) return s; if (e.times[s] < t && e.times[s + 1] > t) { i.set(e.times.slice(0, s + 1), 0), i[s + 1] = t, i.set(e.times.slice(s + 1), s + 2), a.set(e.values.slice(0, (s + 1) * r), 0), a.set(o.evaluate(t), (s + 1) * r), a.set(e.values.slice((s + 1) * r), (s + 2) * r), n = s + 1; break } } return e.times = i, e.values = a, n }, mergeMorphTargetTracks: function (e, t) { for (var n = [], r = {}, i = e.tracks, a = 0; a < i.length; ++a) { var o = i[a], s = ud.parseTrackName(o.name), l = ud.findNode(t, s.nodeName); if ("morphTargetInfluences" === s.propertyName && void 0 !== s.propertyIndex) { if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) { if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation."); console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), (o = o.clone()).setInterpolation(2301) } var c, u = l.morphTargetInfluences.length, h = l.morphTargetDictionary[s.propertyIndex]; if (void 0 === h) throw new Error("THREE.GLTFExporter: Morph target name not found: " + s.propertyIndex); if (void 0 !== r[l.uuid]) { var d = o.createInterpolant(new o.ValueBufferType(1)); c = r[l.uuid]; for (m = 0; m < c.times.length; m++)c.values[m * u + h] = d.evaluate(c.times[m]); for (m = 0; m < o.times.length; m++) { var p = this.insertKeyframe(c, o.times[m]); c.values[p * u + h] = o.values[m] } } else { for (var f = new ((c = o.clone()).ValueBufferType)(u * c.times.length), m = 0; m < c.times.length; m++)f[m * u + h] = c.values[m]; c.name = s.nodeName + ".morphTargetInfluences", c.values = f, r[l.uuid] = c, n.push(c) } } else n.push(o) } return e.tracks = n, e } }; var pS = function (e, t, n, r) { var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r; "undefined" == typeof Reflect || _typeof(Reflect); for (var s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o); return a > 3 && o && Object.defineProperty(t, n, o), o }, fS = Symbol("updateThreeSide"), mS = Symbol("currentGLTF"), vS = Symbol("modelGraft"), gS = Symbol("mainPort"), yS = Symbol("threePort"), bS = Symbol("manipulator"), xS = Symbol("modelKernel"), _S = Symbol("onModelChange"), wS = Symbol("onModelGraftMutation"), MS = function (e, t, n, r) { var i, a = arguments.length, o = a < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r; "undefined" == typeof Reflect || _typeof(Reflect); for (var s = e.length - 1; s >= 0; s--)(i = e[s]) && (o = (a < 3 ? i(o) : a > 3 ? i(t, n, o) : i(t, n)) || o); return a > 3 && o && Object.defineProperty(t, n, o), o }, SS = Math.PI / 32, TS = 3e3, ES = { basis: [Wp(Np(SS, "rad"))], keywords: { auto: [null] } }, AS = Symbol("autoRotateStartTime"), RS = Symbol("radiansPerSecond"), kS = Symbol("syncRotationRate"), LS = Symbol("cameraChangeHandler"), CS = Symbol("onCameraChange"), PS = function (e) { var t, n, r, i; return function (a) { _inherits(s, e); var o = _createSuper(s); function s() { var e; _classCallCheck(this, s); for (var a = arguments.length, l = new Array(a), c = 0; c < a; c++)l[c] = arguments[c]; (e = o.call.apply(o, [this].concat(l)))[t] = new Ip, e[n] = new Map, e[r] = function (t) { t.forEach(function (t) { _instanceof(t, MutationRecord) && "childList" !== t.type || (t.addedNodes.forEach(function (t) { e[wy](t) }), t.removedNodes.forEach(function (t) { e[My](t) }), e[$g]()) }) }, e[i] = new MutationObserver(e[xy]); var u = e[yy].domElement, h = u.style; return h.display = "none", h.pointerEvents = "none", h.position = "absolute", h.top = "0", e.shadowRoot.querySelector(".default").appendChild(u), e } return _createClass(s, [{ key: "connectedCallback", value: function () { _get(_getPrototypeOf(s.prototype), "connectedCallback", this).call(this); for (var e = 0; e < this.children.length; ++e)this[wy](this.children[e]); var t = self.ShadyDOM; null == t ? this[_y].observe(this, { childList: !0 }) : this[_y] = t.observeChildren(this, this[xy]) } }, { key: "disconnectedCallback", value: function () { _get(_getPrototypeOf(s.prototype), "disconnectedCallback", this).call(this); var e = self.ShadyDOM; null == e ? this[_y].disconnect() : e.unobserveChildren(this[_y]) } }, { key: "updateHotspot", value: function (e) { var t = this[by].get(e.name); null != t && (t.updatePosition(e.position), t.updateNormal(e.normal)) } }, { key: "positionAndNormalFromPoint", value: function (e, t) { var n = this[Qg], r = n.width, i = n.height, a = n.model; Sy.set(e / r, t / i).multiplyScalar(2).subScalar(1), Sy.y *= -1; var o = n.positionAndNormalFromPoint(Sy); if (null == o) return null; Ty.getInverse(a.matrixWorld); var s = uy(o.position.applyMatrix4(Ty)); return Ey.getNormalMatrix(Ty), { position: s, normal: uy(o.normal.applyNormalMatrix(Ey)) } } }, { key: (t = yy, n = by, r = xy, i = _y, ey), value: function (e, t) { _get(_getPrototypeOf(s.prototype), ey, this).call(this, e, t); var n = this[Qg], r = n.getCamera(); n.isDirty && (n.model.updateHotspots(r.position), this[yy].domElement.style.display = "", this[yy].render(n, r)) } }, { key: ny, value: function (e) { _get(_getPrototypeOf(s.prototype), ny, this).call(this, e), this[yy].setSize(e.width, e.height) } }, { key: wy, value: function (e) { if (_instanceof(e, HTMLElement) && 0 === e.slot.indexOf("hotspot")) { var t = this[by].get(e.slot); null != t ? t.increment() : (t = new Yp({ name: e.slot, position: e.dataset.position, normal: e.dataset.normal }), this[by].set(e.slot, t), this[Qg].model.addHotspot(t), this[yy].domElement.appendChild(t.element)), this[Qg].isDirty = !0 } } }, { key: My, value: function (e) { if (_instanceof(e, HTMLElement)) { var t = this[by].get(e.slot); t && (t.decrement() && (this[Qg].model.removeHotspot(t), this[by].delete(e.slot)), this[Qg].isDirty = !0) } } }]), s }() }(function (e) { var t, n, r, i, a, o, s, l, c = function (c) { _inherits(d, e); var u, h = _createSuper(d); function d() { var e; return _classCallCheck(this, d), (e = h.apply(this, arguments))[l] = null, e[t] = null, e[n] = null, e[r] = null, e[i] = null, e[a] = null, e[o] = function (t) { var n = t.data; if (n && n.type === z_.MODEL_CHANGE) { var r = n.model, i = e[xS]; if (null != i) i.deactivate(); else if (null == r) return; e[xS] = null != r ? new Xw(n.port, r) : null, e.dispatchEvent(new CustomEvent("scene-graph-ready", { detail: { url: r ? r.modelUri : null } })) } }, e[s] = function (t) { e[$g]() }, e } return _createClass(d, [{ key: "connectedCallback", value: function () { _get(_getPrototypeOf(d.prototype), "connectedCallback", this).call(this); var e = new MessageChannel, t = e.port1, n = e.port2; t.start(), n.start(), this[gS] = t, this[yS] = n, this[gS].onmessage = this[_S] } }, { key: "disconnectedCallback", value: function () { _get(_getPrototypeOf(d.prototype), "disconnectedCallback", this).call(this), this[gS].close(), this[yS].close(), this[gS] = null, this[yS] = null, null != this[bS] && this[bS].dispose(), null != this[xS] && this[xS].deactivate() } }, { key: "updated", value: function (e) { if (_get(_getPrototypeOf(d.prototype), "updated", this).call(this, e), e.has(vS)) { var t = e.get(vS); null != t && t.removeEventListener("mutation", this[wS]); var n = this[vS]; null != n && n.addEventListener("mutation", this[wS]) } } }, { key: (l = vS, t = mS, n = gS, r = yS, i = bS, a = xS, ty), value: function () { _get(_getPrototypeOf(d.prototype), ty, this).call(this), this[fS]() } }, { key: fS, value: function () { var e = this[Qg].model, t = e.currentGLTF, n = null, r = null; if (null != t) { var i = t.correlatedSceneGraph, a = this[vS], o = this[bS]; if (null != i) { if (null != o && o.dispose(), null != a && t === this[mS]) return; var s = null; null != (n = new lS(e.url || "", i)) && null != n.model ? (s = new MessageChannel, r = new Kw(n, s.port1), this[yS].postMessage({ type: z_.MODEL_CHANGE, model: n.model.toJSON(), port: s.port2 }, [s.port2])) : this[yS].postMessage({ type: z_.MODEL_CHANGE, model: null, port: null }) } } this[vS] = n, this[bS] = r, this[mS] = t } }, { key: "exportScene", value: (u = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { var n; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return n = this[Qg].model, e.abrupt("return", new Promise(function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(r, i) { var a, o, s; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (null != n) { e.next = 2; break } return e.abrupt("return", i("Model missing or not yet loaded")); case 2: a = { binary: !0, onlyVisible: !0, maxTextureSize: 1 / 0, forcePowerOfTwoTextures: !1, includeCustomExtensions: !1, embedImages: !0 }, Object.assign(a, t), a.animations = n.animations, a.truncateDrawRange = !0, o = n[tf], s = !1, null != o && (s = o.visible, o.visible = !1), (new dS).parse(n.modelContainer, function (e) { return r(new Blob([a.binary ? e : JSON.stringify(e)], { type: a.binary ? "application/octet-stream" : "application/json" })) }, a), null != o && (o.visible = s); case 12: case "end": return e.stop() } }, e) })); return function (t, n) { return e.apply(this, arguments) } }())); case 2: case "end": return e.stop() } }, e, this) })), function (e) { return u.apply(this, arguments) }) }, { key: "model", get: function () { var e = this[xS]; return e ? e.model : void 0 } }]), d }(); return o = _S, s = wS, pS([de({ type: Object })], c.prototype, l, void 0), c }(function (e) { var t, n, r, i = function (i) { _inherits(o, e); var a = _createSuper(o); function o() { var e; return _classCallCheck(this, o), (e = a.apply(this, arguments)).autoRotate = !1, e.autoRotateDelay = TS, e.rotationPerSecond = "auto", e[t] = performance.now(), e[n] = 0, e[r] = function (t) { return e[CS](t) }, e } return _createClass(o, [{ key: "connectedCallback", value: function () { _get(_getPrototypeOf(o.prototype), "connectedCallback", this).call(this), this.addEventListener("camera-change", this[LS]), this[AS] = performance.now() } }, { key: "disconnectedCallback", value: function () { _get(_getPrototypeOf(o.prototype), "disconnectedCallback", this).call(this), this.removeEventListener("camera-change", this[LS]), this[AS] = performance.now() } }, { key: "updated", value: function (e) { _get(_getPrototypeOf(o.prototype), "updated", this).call(this, e), e.has("autoRotate") && (this[AS] = performance.now()) } }, { key: (t = AS, n = RS, r = LS, kS), value: function (e) { this[RS] = e[0] } }, { key: ey, value: function (e, t) { if (_get(_getPrototypeOf(o.prototype), ey, this).call(this, e, t), this.autoRotate && this[cy]() && !this[ry].isPresenting) { var n = Math.min(t, e - this[AS] - this.autoRotateDelay); n > 0 && (this[Qg].yaw = this.turntableRotation + this[RS] * n * .001) } } }, { key: CS, value: function (e) { this.autoRotate && "user-interaction" === e.detail.source && (this[AS] = performance.now()) } }, { key: "resetTurntableRotation", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; this[Qg].yaw = e } }, { key: "turntableRotation", get: function () { return this[Qg].yaw } }]), o }(); return MS([de({ type: Boolean, attribute: "auto-rotate" })], i.prototype, "autoRotate", void 0), MS([de({ type: Number, attribute: "auto-rotate-delay" })], i.prototype, "autoRotateDelay", void 0), MS([Db({ intrinsics: ES, updateHandler: kS }), de({ type: String, attribute: "rotation-per-second" })], i.prototype, "rotationPerSecond", void 0), i }(function (e) { var t, n, r, i = function (i) { _inherits(s, e); var a, o = _createSuper(s); function s() { var e; return _classCallCheck(this, s), (e = o.apply(this, arguments)).environmentImage = null, e.skyboxImage = null, e.shadowIntensity = Kx, e.shadowSoftness = Qx, e.exposure = $x, e[t] = null, e[n] = null, e[r] = function (t) { t.element === _assertThisInitialized(e) && e[n_]() }, e } return _createClass(s, [{ key: "connectedCallback", value: function () { _get(_getPrototypeOf(s.prototype), "connectedCallback", this).call(this), this[ry].loader.addEventListener("preload", this[i_]) } }, { key: "disconnectedCallback", value: function () { _get(_getPrototypeOf(s.prototype), "disconnectedCallback", this).call(this), this[ry].loader.removeEventListener("preload", this[i_]) } }, { key: "updated", value: function (e) { _get(_getPrototypeOf(s.prototype), "updated", this).call(this, e), e.has("shadowIntensity") && (this[Qg].setShadowIntensity(.1 * this.shadowIntensity), this[$g]()), e.has("shadowSoftness") && (this[Qg].setShadowSoftness(this.shadowSoftness), this[$g]()), e.has("exposure") && (this[Qg].exposure = this.exposure, this[$g]()), (e.has("environmentImage") || e.has("skyboxImage")) && this[sy]() && this[n_]() } }, { key: (t = e_, n = r_, r = i_, ty), value: function () { _get(_getPrototypeOf(s.prototype), ty, this).call(this), null != this[e_] && this[t_](this[e_]) } }, { key: n_, value: (a = _asyncToGenerator(regeneratorRuntime.mark(function e() { var t, n, r, i, a, o, s, l = this; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (t = this.skyboxImage, n = this.environmentImage, null != this[r_] && (this[r_](), this[r_] = null), null != (r = this[ry].textureUtils)) { e.next = 5; break } return e.abrupt("return"); case 5: return e.prev = 5, e.next = 8, new Promise(function () { var e = _asyncToGenerator(regeneratorRuntime.mark(function e(i, a) { var o; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return o = r.generateEnvironmentMapAndSkybox(gm(t), gm(n), { progressTracker: l[iy] }), l[r_] = function () { return a(o) }, e.t0 = i, e.next = 5, o; case 5: e.t1 = e.sent, (0, e.t0)(e.t1); case 7: case "end": return e.stop() } }, e) })); return function (t, n) { return e.apply(this, arguments) } }()); case 8: i = e.sent, a = i.environmentMap, o = i.skybox, s = a.texture, this[Qg].background = null != o ? o.userData.url === s.userData.url ? s : o : null, this[t_](a.texture), this[Qg].model.dispatchEvent({ type: "envmap-update" }), e.next = 22; break; case 17: if (e.prev = 17, e.t0 = e.catch(5), !_instanceof(e.t0, Error)) { e.next = 22; break } throw this[t_](null), e.t0; case 22: case "end": return e.stop() } }, e, this, [[5, 17]]) })), function () { return a.apply(this, arguments) }) }, { key: t_, value: function (e) { this[e_] = e, this[Qg].environment = this[e_], this.dispatchEvent(new CustomEvent("environment-change")), this[$g]() } }]), s }(); return Zx([de({ type: String, attribute: "environment-image" })], i.prototype, "environmentImage", void 0), Zx([de({ type: String, attribute: "skybox-image" })], i.prototype, "skyboxImage", void 0), Zx([de({ type: Number, attribute: "shadow-intensity" })], i.prototype, "shadowIntensity", void 0), Zx([de({ type: Number, attribute: "shadow-softness" })], i.prototype, "shadowSoftness", void 0), Zx([de({ type: Number })], i.prototype, "exposure", void 0), i }(function (e) { var t, n, r, i, a, o, s, l, c, u, h, d, p, f, m, v, g, y = function (y) { _inherits(x, e); var b = _createSuper(x); function x() { var e; return _classCallCheck(this, x), (e = b.apply(this, arguments)).cameraControls = !1, e.cameraOrbit = Kb, e.cameraTarget = Qb, e.fieldOfView = $b, e.minCameraOrbit = "auto", e.maxCameraOrbit = "auto", e.minFieldOfView = "auto", e.maxFieldOfView = "auto", e.interactionPromptThreshold = rx, e.interactionPromptStyle = ax.WIGGLE, e.interactionPrompt = ix.AUTO, e.interactionPolicy = ox.ALWAYS_ALLOW, e.orbitSensitivity = 1, e.touchAction = sx.PAN_Y, e[t] = e.shadowRoot.querySelector(".interaction-prompt"), e[n] = e.shadowRoot.querySelector(".interaction-prompt > .animated-container"), e[r] = 1 / 0, e[i] = 0, e[a] = 1 / 0, e[o] = !1, e[s] = !1, e[l] = new jb(e[Qg].camera, e[Zg]), e[c] = 0, e[u] = new bd, e[h] = !1, e[d] = !1, e[p] = !1, e[f] = function (t) { return e[Cx](t) }, e[m] = function (t) { return e[Px](t) }, e[v] = function () { return e[Lx]() }, e[g] = function () { return e[kx]() }, e } return _createClass(x, [{ key: "getCameraOrbit", value: function () { var e = this[zx]; return { theta: e.theta, phi: e.phi, radius: e.radius } } }, { key: "getCameraTarget", value: function () { return uy(this[Qg].getTarget()) } }, { key: "getFieldOfView", value: function () { return this[bx].getFieldOfView() } }, { key: "getMinimumFieldOfView", value: function () { return this[bx].options.minimumFieldOfView } }, { key: "getMaximumFieldOfView", value: function () { return this[bx].options.maximumFieldOfView } }, { key: "jumpCameraToGoal", value: function () { this[Bx] = !0, this.requestUpdate(Bx, !1) } }, { key: "resetInteractionPrompt", value: function () { this[Dx] = 0, this[Nx] = 1 / 0, this[Ix] = !1, this[Ox] = this.interactionPrompt === ix.AUTO && this.cameraControls } }, { key: "connectedCallback", value: function () { _get(_getPrototypeOf(x.prototype), "connectedCallback", this).call(this), this[bx].addEventListener("change", this[Ax]), this[bx].addEventListener("pointer-change-start", this[Rx]), this[bx].addEventListener("pointer-change-end", this[Rx]) } }, { key: "disconnectedCallback", value: function () { _get(_getPrototypeOf(x.prototype), "disconnectedCallback", this).call(this), this[bx].removeEventListener("change", this[Ax]), this[bx].removeEventListener("pointer-change-start", this[Rx]), this[bx].removeEventListener("pointer-change-end", this[Rx]) } }, { key: "updated", value: function (e) { var t = this; _get(_getPrototypeOf(x.prototype), "updated", this).call(this, e); var n = this[bx], r = this[Zg]; if (e.has("cameraControls") && (this.cameraControls ? (n.enableInteraction(), this.interactionPrompt === ix.AUTO && (this[Ox] = !0), r.addEventListener("focus", this[Ex]), r.addEventListener("blur", this[Tx])) : (r.removeEventListener("focus", this[Ex]), r.removeEventListener("blur", this[Tx]), n.disableInteraction(), this[wx]())), (e.has("interactionPrompt") || e.has("cameraControls") || e.has("src")) && (this.interactionPrompt === ix.AUTO && this.cameraControls && !this[Ix] ? this[Ox] = !0 : this[wx]()), e.has("interactionPromptStyle") && this[xx].classList.toggle("wiggle", this.interactionPromptStyle === ax.WIGGLE), e.has("interactionPolicy")) { var i = this.interactionPolicy; n.applyOptions({ interactionPolicy: i }) } if (e.has("touchAction")) { var a = this.touchAction; n.applyOptions({ touchAction: a }) } e.has("orbitSensitivity") && (this[bx].sensitivity = this.orbitSensitivity), !0 === this[Bx] && Promise.resolve().then(function () { t[bx].jumpToGoal(), t[Qg].jumpToGoal(), t[Bx] = !1 }) } }, { key: (t = xx, n = _x, r = Fx, i = Dx, a = Nx, o = Ix, s = Ox, l = bx, c = Ux, u = zx, h = Bx, d = Hx, p = Gx, f = Ax, m = Rx, v = Ex, g = Tx, jx), value: function (e) { this[bx].setFieldOfView(180 * e[0] / Math.PI) } }, { key: Vx, value: function (e) { if (this[Gx]) { var t = this.getCameraOrbit(), n = t.theta, r = t.phi; e[0] = n, e[1] = r, this[Gx] = !1 } this[bx].setOrbit(e[0], e[1], e[2]) } }, { key: qx, value: function (e) { this[bx].applyOptions({ minimumAzimuthalAngle: e[0], minimumPolarAngle: e[1], minimumRadius: e[2] }), this.jumpCameraToGoal() } }, { key: Xx, value: function (e) { this[bx].applyOptions({ maximumAzimuthalAngle: e[0], maximumPolarAngle: e[1], maximumRadius: e[2] }), this[Sx](e[2]), this.jumpCameraToGoal() } }, { key: Yx, value: function (e) { this[bx].applyOptions({ minimumFieldOfView: 180 * e[0] / Math.PI }), this.jumpCameraToGoal() } }, { key: Jx, value: function (e) { this[bx].applyOptions({ maximumFieldOfView: 180 * e[0] / Math.PI }), this.jumpCameraToGoal() } }, { key: Wx, value: function (e) { var t = _slicedToArray(e, 3), n = t[0], r = t[1], i = t[2]; this[Qg].setTarget(n, r, i), this[ry].arRenderer.updateTarget() } }, { key: ey, value: function (e, t) { if (_get(_getPrototypeOf(x.prototype), ey, this).call(this, e, t), !this[ry].isPresenting && this[cy]()) { var n = performance.now(); if (this[Ox]) { var r = this.interactionPrompt === ix.AUTO ? this[qg] : this[Fx]; this.loaded && n > r + this.interactionPromptThreshold && (this[Zg].setAttribute("aria-label", "Use mouse, touch or arrow keys to control the camera!"), this[Ox] = !1, this[Nx] = n, this[xx].classList.add("visible")) } if (isFinite(this[Nx]) && this.interactionPromptStyle === ax.WIGGLE) { var i = this[Qg], a = (n - this[Nx]) / 5e3 % 1, o = Jb(a), s = Zb(a); if (this[_x].style.opacity = "".concat(s), o !== this[Dx]) { var l = o * i.width * .05, c = (o - this[Dx]) * Math.PI / 16; this[_x].style.transform = "translateX(".concat(l, "px)"), this[bx].adjustOrbit(c, 0, 0), this[Dx] = o } } this[bx].update(e, t), this[Qg].updateTarget(t) } } }, { key: wx, value: function () { this[Ox] = !1, this[xx].classList.remove("visible"), this[Nx] = 1 / 0 } }, { key: Sx, value: function (e) { var t = this[Qg].model.idealCameraDistance, n = 2 * Math.max(t, e); this[bx].updateNearFar(0, n) } }, { key: Mx, value: function () { var e = this[zx], t = e.theta, n = e.phi, r = this[bx].getCameraSpherical(this[zx]), i = r.theta, a = r.phi, o = this.getRootNode(); if (null != o && o.activeElement === this) { var s = (4 + Math.floor((t % yx + gx) / mx)) % 4, l = (4 + Math.floor((i % yx + gx) / mx)) % 4, c = Math.floor(n / vx), u = Math.floor(a / vx); if (l !== s || u !== c) { var h = tx[l], d = "View from stage ".concat(nx[u]).concat(h); this[Zg].setAttribute("aria-label", d) } } } }, { key: ny, value: function (e) { var t = this[bx], n = this[Qg].framedFieldOfView; _get(_getPrototypeOf(x.prototype), ny, this).call(this, e); var r = this[Qg].framedFieldOfView, i = t.getFieldOfView() / n; this[Ux] = r * i, t.updateAspect(this[Qg].aspect), this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.jumpCameraToGoal() } }, { key: ty, value: function () { _get(_getPrototypeOf(x.prototype), ty, this).call(this); var e = this[Qg].framedFieldOfView; this[Ux] = e, this[Hx] ? this[Gx] = !0 : this[Hx] = !0, this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.requestUpdate("minCameraOrbit", this.minCameraOrbit), this.requestUpdate("maxCameraOrbit", this.maxCameraOrbit), this.requestUpdate("cameraOrbit", this.cameraOrbit), this.requestUpdate("cameraTarget", this.cameraTarget), this.jumpCameraToGoal() } }, { key: Lx, value: function () { var e = this[Zg]; isFinite(this[Fx]) || (this[Fx] = performance.now()); var t = this[Wg]; e.getAttribute("aria-label") !== t && e.setAttribute("aria-label", t), this.interactionPrompt !== ix.WHEN_FOCUSED || this[Ix] || (this[Ox] = !0) } }, { key: kx, value: function () { this.interactionPrompt === ix.WHEN_FOCUSED && (this[Ox] = !1, this[xx].classList.remove("visible"), this[Nx] = 1 / 0, this[Fx] = 1 / 0) } }, { key: Cx, value: function (e) { var t = e.source; this[Mx](), this[$g](), t === Gb && (this[Ix] = !0, this[wx]()), this.dispatchEvent(new CustomEvent("camera-change", { detail: { source: t } })) } }, { key: Px, value: function (e) { "pointer-change-start" === e.type ? this[Jg].classList.add("pointer-tumbling") : this[Jg].classList.remove("pointer-tumbling") } }]), x }(); return Yb([de({ type: Boolean, attribute: "camera-controls" })], y.prototype, "cameraControls", void 0), Yb([Db({ intrinsics: hx, observeEffects: !0, updateHandler: Vx }), de({ type: String, attribute: "camera-orbit", hasChanged: function () { return !0 } })], y.prototype, "cameraOrbit", void 0), Yb([Db({ intrinsics: fx, observeEffects: !0, updateHandler: Wx }), de({ type: String, attribute: "camera-target", hasChanged: function () { return !0 } })], y.prototype, "cameraTarget", void 0), Yb([Db({ intrinsics: lx, observeEffects: !0, updateHandler: jx }), de({ type: String, attribute: "field-of-view", hasChanged: function () { return !0 } })], y.prototype, "fieldOfView", void 0), Yb([Db({ intrinsics: dx, updateHandler: qx }), de({ type: String, attribute: "min-camera-orbit", hasChanged: function () { return !0 } })], y.prototype, "minCameraOrbit", void 0), Yb([Db({ intrinsics: px, updateHandler: Xx }), de({ type: String, attribute: "max-camera-orbit", hasChanged: function () { return !0 } })], y.prototype, "maxCameraOrbit", void 0), Yb([Db({ intrinsics: cx, updateHandler: Yx }), de({ type: String, attribute: "min-field-of-view", hasChanged: function () { return !0 } })], y.prototype, "minFieldOfView", void 0), Yb([Db({ intrinsics: ux, updateHandler: Jx }), de({ type: String, attribute: "max-field-of-view", hasChanged: function () { return !0 } })], y.prototype, "maxFieldOfView", void 0), Yb([de({ type: Number, attribute: "interaction-prompt-threshold" })], y.prototype, "interactionPromptThreshold", void 0), Yb([de({ type: String, attribute: "interaction-prompt-style" })], y.prototype, "interactionPromptStyle", void 0), Yb([de({ type: String, attribute: "interaction-prompt" })], y.prototype, "interactionPrompt", void 0), Yb([de({ type: String, attribute: "interaction-policy" })], y.prototype, "interactionPolicy", void 0), Yb([de({ type: Number, attribute: "orbit-sensitivity" })], y.prototype, "orbitSensitivity", void 0), Yb([de({ type: String, attribute: "touch-action" })], y.prototype, "touchAction", void 0), y }(function (e) { var t, n, r, i, a, o, s, l, c, u, h = function (h) { _inherits(g, e); var d, p, f, m, v = _createSuper(g); function g() { var e; return _classCallCheck(this, g), (e = v.apply(this, arguments)).ar = !1, e.arScale = "auto", e.arModes = Oy, e.iosSrc = null, e.quickLookBrowsers = "safari", e[t] = !1, e[n] = e.shadowRoot.querySelector(".ar-button"), e[r] = document.createElement("a"), e[i] = new Set, e[a] = Iy.NONE, e[o] = !1, e[s] = new Set, e[l] = function (t) { t.preventDefault(), e.activateAR() }, e[c] = function (t) { var n = t.status; n !== Cm.NOT_PRESENTING && e[ry].arRenderer.presentedScene !== e[Qg] || (e.setAttribute("ar-status", n), e.dispatchEvent(new CustomEvent("ar-status", { detail: { status: n } }))) }, e[u] = function (t) { "_apple_ar_quicklook_button_tapped" == t.data && e.dispatchEvent(new CustomEvent("quick-look-button-tapped")) }, e } return _createClass(g, [{ key: "connectedCallback", value: function () { _get(_getPrototypeOf(g.prototype), "connectedCallback", this).call(this), this[ry].arRenderer.addEventListener("status", this[Xy]), this.setAttribute("ar-status", Cm.NOT_PRESENTING), this[jy].addEventListener("message", this[Yy]) } }, { key: "disconnectedCallback", value: function () { _get(_getPrototypeOf(g.prototype), "disconnectedCallback", this).call(this), this[ry].arRenderer.removeEventListener("status", this[Xy]), this[jy].removeEventListener("message", this[Yy]) } }, { key: "update", value: (m = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (_get(_getPrototypeOf(g.prototype), "update", this).call(this, t), t.has("quickLookBrowsers") && (this[Vy] = Cy(this.quickLookBrowsers)), t.has("ar") || t.has("arModes") || t.has("iosSrc")) { e.next = 4; break } return e.abrupt("return"); case 4: t.has("arModes") && (this[Hy] = Py(this.arModes)), t.has("arScale") && (this[Qg].canScale = "fixed" !== this.arScale), this[Jy](); case 7: case "end": return e.stop() } }, e, this) })), function (e) { return m.apply(this, arguments) }) }, { key: "activateAR", value: (f = _asyncToGenerator(regeneratorRuntime.mark(function e() { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: e.t0 = this[By], e.next = e.t0 === Iy.QUICK_LOOK ? 3 : e.t0 === Iy.WEBXR ? 5 : e.t0 === Iy.SCENE_VIEWER ? 8 : 10; break; case 3: return this[Uy](), e.abrupt("break", 12); case 5: return e.next = 7, this[Dy](); case 7: return e.abrupt("break", 12); case 8: return this[Fy](), e.abrupt("break", 12); case 10: return console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities"), e.abrupt("break", 12); case 12: case "end": return e.stop() } }, e, this) })), function () { return f.apply(this, arguments) }) }, { key: (t = zy, n = Ny, r = jy, i = Hy, a = By, o = Wy, s = Vy, l = qy, c = Xy, u = Yy, Jy), value: (p = _asyncToGenerator(regeneratorRuntime.mark(function e() { var t, n, r, i, a; return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (this[By] = Iy.NONE, !this.ar) { e.next = 28; break } t = [], this[Hy].forEach(function (e) { t.push(e) }), n = 0, r = t; case 5: if (!(n < r.length)) { e.next = 28; break } if (i = r[n], e.t0 = "webxr" === i && xe && !ky, !e.t0) { e.next = 12; break } return e.next = 11, this[ry].arRenderer.supportsPresentation(); case 11: e.t0 = e.sent; case 12: if (!e.t0) { e.next = 17; break } return this[By] = Iy.WEBXR, e.abrupt("break", 28); case 17: if ("scene-viewer" !== i || !ke || Ly) { e.next = 22; break } return this[By] = Iy.SCENE_VIEWER, e.abrupt("break", 28); case 22: if (!("quick-look" === i && this.iosSrc && this[Gy] && Me)) { e.next = 25; break } return this[By] = Iy.QUICK_LOOK, e.abrupt("break", 28); case 25: n++, e.next = 5; break; case 28: this.canActivateAR ? (this[Ny].classList.add("enabled"), this[Ny].addEventListener("click", this[qy])) : this[Ny].classList.contains("enabled") && (this[Ny].removeEventListener("click", this[qy]), this[Ny].classList.remove("enabled"), a = Cm.FAILED, this.setAttribute("ar-status", a), this.dispatchEvent(new CustomEvent("ar-status", { detail: { status: a } }))); case 29: case "end": return e.stop() } }, e, this) })), function () { return p.apply(this, arguments) }) }, { key: Dy, value: (d = _asyncToGenerator(regeneratorRuntime.mark(function e() { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: if (console.log("Attempting to present in AR..."), this[Hg]) { e.next = 7; break } return this[Wy] = !0, this[Xg](), e.next = 6, Tm(this, "load"); case 6: this[Wy] = !1; case 7: return e.prev = 7, this[Ny].removeEventListener("click", this[qy]), e.next = 11, this[ry].arRenderer.present(this[Qg]); case 11: e.next = 23; break; case 13: return e.prev = 13, e.t0 = e.catch(7), console.warn("Error while trying to present to AR"), console.error(e.t0), e.next = 19, this[ry].arRenderer.stopPresenting(); case 19: return ky = !0, e.next = 22, this[Jy](); case 22: this.activateAR(); case 23: return e.prev = 23, this[Jy](), e.finish(23); case 26: case "end": return e.stop() } }, e, this, [[7, 13, 23, 26]]) })), function () { return d.apply(this, arguments) }) }, { key: sy, value: function () { return _get(_getPrototypeOf(g.prototype), sy, this).call(this) || this[Wy] } }, { key: Fy, value: function () { var e = this, t = this.src.replace("?", "&"), n = self.location.toString(), r = new URL(n), i = new URL(t, n); r.hash = "#model-viewer-no-ar-fallback"; var a = "?file=".concat(i.toString(), "&mode=ar_only"); t.includes("&link=") || (a += "&link=".concat(n)), t.includes("&title=") || (a += "&title=".concat(encodeURIComponent(this.alt || ""))), "fixed" === this.arScale && (a += "&resizable=false"); var o = "intent://arvr.google.com/scene-viewer/1.0".concat(a, "#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=").concat(encodeURIComponent(r.toString()), ";end;"); self.addEventListener("hashchange", function () { "#model-viewer-no-ar-fallback" === self.location.hash && (Ly = !0, self.history.back(), e[Jy]()) }, { once: !0 }), this[jy].setAttribute("href", o), this[jy].click() } }, { key: Uy, value: function () { var e = new URL(this.iosSrc, self.location.toString()); "fixed" === this.arScale && (e.hash = "allowsContentScaling=0"); var t = this[jy]; t.setAttribute("rel", "ar"); var n = document.createElement("img"); t.appendChild(n), t.setAttribute("href", e.toString()), t.click(), t.removeChild(n) } }, { key: "canActivateAR", get: function () { return this[By] !== Iy.NONE } }, { key: Gy, get: function () { return Ae ? this[Vy].has("chrome") : !!Re && this[Vy].has("safari") } }]), g }(); return Ry([de({ type: Boolean, attribute: "ar" })], h.prototype, "ar", void 0), Ry([de({ type: String, attribute: "ar-scale" })], h.prototype, "arScale", void 0), Ry([de({ type: String, attribute: "ar-modes" })], h.prototype, "arModes", void 0), Ry([de({ type: String, attribute: "ios-src" })], h.prototype, "iosSrc", void 0), Ry([de({ type: String, attribute: "quick-look-browsers" })], h.prototype, "quickLookBrowsers", void 0), h }(function (e) { var t, n, r, i, a, o, s, l, c, u, h, d, p, f = function (f) { _inherits(y, e); var m, v, g = _createSuper(y); function y() { var e; _classCallCheck(this, y); for (var f = arguments.length, m = new Array(f), v = 0; v < f; v++)m[v] = arguments[v]; (e = g.call.apply(g, [this].concat(m))).poster = null, e.reveal = g_.AUTO, e.loading = y_.AUTO, e[t] = !1, e[n] = !1, e[r] = 0, e[i] = null, e[a] = e.shadowRoot.querySelector(".slot.poster"), e[o] = e.shadowRoot.querySelector("#default-poster"), e[s] = e.shadowRoot.querySelector("#default-progress-bar > .bar"), e[l] = e.shadowRoot.querySelector("#default-progress-bar > .mask"), e[c] = e[S_].getAttribute("aria-label"), e[u] = function () { return e[D_]() }, e[h] = function (t) { return e[F_](t) }, e[d] = function (t) { return e[U_](t) }, e[p] = xm(function (t) { var n = e[__].parentNode; requestAnimationFrame(function () { e[w_].style.opacity = "".concat((1 - t) * m_), e[__].style.transform = "scaleX(".concat(t, ")"), 0 === t && (n.removeChild(e[__]), n.appendChild(e[__])), 1 === t ? e[__].classList.add("hide") : e[__].classList.remove("hide") }) }, f_); var b = (self.ModelViewerElement || {}).dracoDecoderLocation || v_; return yp.setDRACODecoderLocation(b), e } return _createClass(y, [{ key: "dismissPoster", value: function () { this[ly]() ? this[A_]() : (this[T_] = b_, this[Xg]()) } }, { key: "getDimensions", value: function () { return uy(this[Qg].model.size) } }, { key: "connectedCallback", value: function () { _get(_getPrototypeOf(y.prototype), "connectedCallback", this).call(this), this[M_].addEventListener("click", this[O_]), this[M_].addEventListener("keydown", this[I_]), this[iy].addEventListener("progress", this[N_]), x_.registerInstance(this) } }, { key: "disconnectedCallback", value: function () { _get(_getPrototypeOf(y.prototype), "disconnectedCallback", this).call(this), this[M_].removeEventListener("click", this[O_]), this[M_].removeEventListener("keydown", this[I_]), this[iy].removeEventListener("progress", this[N_]), x_.unregisterInstance(this) } }, { key: "updated", value: (v = _asyncToGenerator(regeneratorRuntime.mark(function e(t) { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: _get(_getPrototypeOf(y.prototype), "updated", this).call(this, t), t.has("poster") && null != this.poster && (this[S_].style.backgroundImage = "url(".concat(this.poster, ")")), t.has("alt") && this[S_].setAttribute("aria-label", "".concat(this[Wg], ". ").concat(this[P_])), (t.has("reveal") || t.has("loaded")) && (this[ly]() || this[Xg]()); case 4: case "end": return e.stop() } }, e, this) })), function (e) { return v.apply(this, arguments) }) }, { key: (t = R_, n = C_, r = L_, i = T_, a = M_, o = S_, s = __, l = w_, c = P_, u = O_, h = I_, d = N_, p = k_, D_), value: function () { this.reveal !== g_.MANUAL && this.dismissPoster() } }, { key: F_, value: function (e) { if (this.reveal !== g_.MANUAL) switch (e.keyCode) { case 32: case 13: this.dismissPoster() } } }, { key: U_, value: function (e) { var t = e.detail.totalProgress; this[L_] = Math.max(t, this[L_]), 1 === t && (this[k_].flush(), !this[ly]() || null == this[T_] && this.reveal !== g_.AUTO || this[A_]()), this[k_](t), this.dispatchEvent(new CustomEvent("progress", { detail: { totalProgress: t } })) } }, { key: sy, value: function () { return !!this.src && (null != this[T_] || this.loading === y_.EAGER || this.reveal === g_.AUTO && this[Vg]) } }, { key: ly, value: function () { return !!this.src && _get(_getPrototypeOf(y.prototype), ly, this).call(this) && 1 === this[L_] } }, { key: E_, value: function () { var e = this[M_], t = this[S_]; t.removeAttribute("tabindex"), t.removeAttribute("aria-hidden"), e.classList.add("show"); var n = this.modelIsVisible; this[R_] = !1, this[jg](n), this[C_] = !1 } }, { key: A_, value: function () { var e = this; this[T_] = null; var t = this[M_], n = this[S_]; if (t.classList.contains("show")) { t.classList.remove("show"); var r = this.modelIsVisible; this[R_] = !0, this[jg](r), t.addEventListener("transitionend", function () { requestAnimationFrame(function () { e[C_] = !0; var t = e.getRootNode(); t && t.activeElement === e && e[Zg].focus(), n.setAttribute("aria-hidden", "true"), n.tabIndex = -1, e.dispatchEvent(new CustomEvent("poster-dismissed")) }) }, { once: !0 }) } } }, { key: oy, value: function () { return _get(_getPrototypeOf(y.prototype), oy, this).call(this) && this[R_] } }, { key: cy, value: function () { return _get(_getPrototypeOf(y.prototype), cy, this).call(this) && this[C_] } }, { key: Xg, value: (m = _asyncToGenerator(regeneratorRuntime.mark(function e() { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return this[L_] = 0, null != this[Qg].model.currentGLTF && null != this.src && this[sy]() || this[E_](), e.next = 4, _get(_getPrototypeOf(y.prototype), Xg, this).call(this); case 4: case "end": return e.stop() } }, e, this) })), function () { return m.apply(this, arguments) }) }], [{ key: "mapURLs", value: function (e) { lg.singleton.loader[mp].manager.setURLModifier(e) } }, { key: "dracoDecoderLocation", set: function (e) { yp.setDRACODecoderLocation(e) }, get: function () { return yp.getDRACODecoderLocation() } }]), y }(); return p_([de({ type: String })], f.prototype, "poster", void 0), p_([de({ type: String })], f.prototype, "reveal", void 0), p_([de({ type: String })], f.prototype, "loading", void 0), f }(function (e) { var t, n = function (n) { _inherits(a, e); var r, i = _createSuper(a); function a() { var e; return _classCallCheck(this, a), (e = i.apply(this, arguments)).autoplay = !1, e.animationName = void 0, e.animationCrossfadeDuration = 300, e[t] = !0, e } return _createClass(a, [{ key: "pause", value: function () { this[gy] || (this[gy] = !0, this[ry].threeRenderer.shadowMap.autoUpdate = !1, this.dispatchEvent(new CustomEvent("pause"))) } }, { key: "play", value: function () { this[gy] && this.availableAnimations.length > 0 && (this[gy] = !1, this[ry].threeRenderer.shadowMap.autoUpdate = !0, this[Qg].model.hasActiveAnimation || this[vy](), this.dispatchEvent(new CustomEvent("play"))) } }, { key: (t = gy, ty), value: function () { _get(_getPrototypeOf(a.prototype), ty, this).call(this), this[gy] = !0, this.autoplay && (this[vy](), this.play()) } }, { key: ey, value: function (e, t) { _get(_getPrototypeOf(a.prototype), ey, this).call(this, e, t), !this[gy] && this[cy]() && (this[Qg].model.updateAnimation(t / 1e3), this[$g]()) } }, { key: "updated", value: function (e) { _get(_getPrototypeOf(a.prototype), "updated", this).call(this, e), e.has("autoplay") && this.autoplay && this.play(), e.has("animationName") && this[vy]() } }, { key: Xg, value: (r = _asyncToGenerator(regeneratorRuntime.mark(function e() { return regeneratorRuntime.wrap(function (e) { for (; ;)switch (e.prev = e.next) { case 0: return this[Qg].model.stopAnimation(), e.abrupt("return", _get(_getPrototypeOf(a.prototype), Xg, this).call(this)); case 2: case "end": return e.stop() } }, e, this) })), function () { return r.apply(this, arguments) }) }, { key: vy, value: function () { var e = this[Qg].model; e.playAnimation(this.animationName, this.animationCrossfadeDuration / 1e3), this[gy] && (e.updateAnimation(0), this[$g]()) } }, { key: "availableAnimations", get: function () { return this.loaded ? this[Qg].model.animationNames : [] } }, { key: "paused", get: function () { return this[gy] } }, { key: "currentTime", get: function () { return this[Qg].model.animationTime }, set: function (e) { this[Qg].model.animationTime = e, this[ry].threeRenderer.shadowMap.needsUpdate = !0, this[$g]() } }]), a }(); return my([de({ type: Boolean })], n.prototype, "autoplay", void 0), my([de({ type: String, attribute: "animation-name" })], n.prototype, "animationName", void 0), my([de({ type: Number, attribute: "animation-crossfade-duration" })], n.prototype, "animationCrossfadeDuration", void 0), n }(function (e) { var t, n = Symbol("endPolyfillCoordination"), r = function (r) { _inherits(a, e); var i = _createSuper(a); function a() { var e; return _classCallCheck(this, a), (e = i.apply(this, arguments))[t] = null, e } return _createClass(a, [{ key: "connectedCallback", value: function () { _get(_getPrototypeOf(a.prototype), "connectedCallback", this) && _get(_getPrototypeOf(a.prototype), "connectedCallback", this).call(this), null == this[n] && (this[n] = function (e) { if (null == e.shadowRoot || e.hasAttribute("data-js-focus-visible")) return function () { }; if (!self.applyFocusVisiblePolyfill) { var t = function () { self.applyFocusVisiblePolyfill(e.shadowRoot) }; return self.addEventListener("focus-visible-polyfill-ready", t, { once: !0 }), function () { self.removeEventListener("focus-visible-polyfill-ready", t) } } return self.applyFocusVisiblePolyfill(e.shadowRoot), function () { } }(this)) } }, { key: "disconnectedCallback", value: function () { _get(_getPrototypeOf(a.prototype), "disconnectedCallback", this) && _get(_getPrototypeOf(a.prototype), "disconnectedCallback", this).call(this), null != this[n] && (this[n](), this[n] = null) } }]), a }(); return t = n, r }(hy))))))))); customElements.define("model-viewer", PS), e.ModelViewerElement = PS, Object.defineProperty(e, "__esModule", { value: !0 }) });